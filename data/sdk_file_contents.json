{
  "packages/core/__e2e__/pushchain.spec.ts": "import {\n  generatePrivateKey,\n  PrivateKeyAccount,\n  privateKeyToAccount,\n} from 'viem/accounts';\nimport { PUSH_NETWORK, CHAIN } from '../src/lib/constants/enums';\nimport {\n  createPublicClient,\n  createWalletClient,\n  Hex,\n  hexToBytes,\n  http,\n} from 'viem';\nimport { Keypair } from '@solana/web3.js';\nimport { PushChain } from '../src';\nimport { UniversalSigner } from '../src/lib/universal/universal.types';\nimport { CHAIN_INFO } from '../src/lib/constants/chain';\nimport dotenv from 'dotenv';\nimport path from 'path';\nimport { UniversalTxResponse } from '../src/lib/orchestrator/orchestrator.types';\nimport { sepolia, arbitrumSepolia, baseSepolia, bscTestnet } from 'viem/chains';\nimport bs58 from 'bs58';\n\n// Adjust path as needed if your .env is in the root\ndotenv.config({ path: path.resolve(__dirname, '../.env') });\n\ndescribe('PushChain (e2e)', () => {\n  const pushNetwork = PUSH_NETWORK.TESTNET_DONUT;\n  const to = '0x35B84d6848D16415177c64D64504663b998A6ab4';\n  let universalSigner: UniversalSigner;\n  let randomAccount: PrivateKeyAccount;\n  describe('Origin - EVM (Except Push)', () => {\n    describe('ETHEREUM_SEPOLIA', () => {\n      const originChain = CHAIN.ETHEREUM_SEPOLIA;\n      let pushClient: PushChain;\n\n      beforeAll(async () => {\n        const privateKey = process.env['EVM_PRIVATE_KEY'] as Hex;\n        if (!privateKey) throw new Error('EVM_PRIVATE_KEY not set');\n\n        const account = privateKeyToAccount(privateKey);\n        const walletClient = createWalletClient({\n          account,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n\n        universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n          walletClient,\n          {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          }\n        );\n\n        pushClient = await PushChain.initialize(universalSigner, {\n          network: pushNetwork,\n          progressHook: (val: any) => {\n            console.log(val);\n          },\n        });\n\n        // Generate random account\n        randomAccount = privateKeyToAccount(generatePrivateKey());\n        // Try to send Sepolia ETH to random generated address\n        const txHash = await walletClient.sendTransaction({\n          to: randomAccount.address,\n          chain: sepolia,\n          value: PushChain.utils.helpers.parseUnits('1', 14),\n        });\n        const publicClient = createPublicClient({\n          chain: sepolia,\n          transport: http(),\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: txHash,\n        });\n      }, 100000);\n\n      it('should fail to send universal.sendTransaction with invalid feeLockTxHash', async () => {\n        await expect(\n          pushClient.universal.sendTransaction({\n            to,\n            feeLockTxHash: '0xABC', // Invalid txHash\n            value: BigInt(1e3),\n          })\n        ).rejects.toThrow();\n      }, 30000);\n\n      it('should successfully sendTransaction - Transfer Call', async () => {\n        const tx = await pushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e3),\n        });\n        const after = await PushChain.utils.account.convertOriginToExecutor(\n          universalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n        expect(after.deployed).toBe(true);\n        await txValidator(\n          tx,\n          pushClient.universal.origin.address as `0x${string}`,\n          to\n        );\n      }, 300000);\n\n      it('should successfully sendTransaction to funded undeployed UEA', async () => {\n        const walletClient = createWalletClient({\n          account: randomAccount,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n        const randomUniversalSigner =\n          await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          });\n        const UEA = await PushChain.utils.account.convertOriginToExecutor(\n          randomUniversalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n\n        // Fund Undeployed UEA - 1PC\n        await pushClient.universal.sendTransaction({\n          to: UEA.address,\n          value: BigInt(1e18),\n        });\n\n        // Send Tx Via Random Address\n        const randomPushClient = await PushChain.initialize(\n          randomUniversalSigner,\n          {\n            network: pushNetwork,\n          }\n        );\n        await randomPushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e6),\n        });\n      }, 300000);\n    });\n\n    describe('ARBITRUM_SEPOLIA', () => {\n      const originChain = CHAIN.ARBITRUM_SEPOLIA;\n      let pushClient: PushChain;\n\n      beforeAll(async () => {\n        const privateKey = process.env['EVM_PRIVATE_KEY'] as Hex;\n        if (!privateKey) throw new Error('EVM_PRIVATE_KEY not set');\n\n        const account = privateKeyToAccount(privateKey);\n        const walletClient = createWalletClient({\n          account,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n\n        universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n          walletClient,\n          {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          }\n        );\n\n        pushClient = await PushChain.initialize(universalSigner, {\n          network: pushNetwork,\n          progressHook: (val: any) => {\n            console.log(val);\n          },\n        });\n\n        // Generate random account\n        randomAccount = privateKeyToAccount(generatePrivateKey());\n        // Try to send Arbitrum Sepolia ETH to random generated address\n        const txHash = await walletClient.sendTransaction({\n          to: randomAccount.address,\n          chain: arbitrumSepolia,\n          value: PushChain.utils.helpers.parseUnits('1', 14),\n        });\n        const publicClient = createPublicClient({\n          chain: arbitrumSepolia,\n          transport: http(),\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: txHash,\n        });\n      }, 100000);\n\n      it('should fail to send universal.sendTransaction with invalid feeLockTxHash', async () => {\n        await expect(\n          pushClient.universal.sendTransaction({\n            to,\n            feeLockTxHash: '0xABC', // Invalid txHash\n            value: BigInt(1e3),\n          })\n        ).rejects.toThrow();\n      }, 30000);\n\n      it('should successfully sendTransaction - Transfer Call', async () => {\n        const tx = await pushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e3),\n        });\n        const after = await PushChain.utils.account.convertOriginToExecutor(\n          universalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n        expect(after.deployed).toBe(true);\n        await txValidator(\n          tx,\n          pushClient.universal.origin.address as `0x${string}`,\n          to\n        );\n      }, 300000);\n\n      it('should successfully sendTransaction to funded undeployed UEA', async () => {\n        const walletClient = createWalletClient({\n          account: randomAccount,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n        const randomUniversalSigner =\n          await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          });\n        const UEA = await PushChain.utils.account.convertOriginToExecutor(\n          randomUniversalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n\n        // Fund Undeployed UEA - 1PC\n        await pushClient.universal.sendTransaction({\n          to: UEA.address,\n          value: BigInt(1e18),\n        });\n\n        // Send Tx Via Random Address\n        const randomPushClient = await PushChain.initialize(\n          randomUniversalSigner,\n          {\n            network: pushNetwork,\n          }\n        );\n        await randomPushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e6),\n        });\n      }, 300000);\n    });\n\n    describe('BASE_SEPOLIA', () => {\n      const originChain = CHAIN.BASE_SEPOLIA;\n      let pushClient: PushChain;\n\n      beforeAll(async () => {\n        const privateKey = process.env['EVM_PRIVATE_KEY'] as Hex;\n        if (!privateKey) throw new Error('EVM_PRIVATE_KEY not set');\n\n        const account = privateKeyToAccount(privateKey);\n        const walletClient = createWalletClient({\n          account,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n\n        universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n          walletClient,\n          {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          }\n        );\n\n        pushClient = await PushChain.initialize(universalSigner, {\n          network: pushNetwork,\n          progressHook: (val: any) => {\n            console.log(val);\n          },\n        });\n\n        // Generate random account\n        randomAccount = privateKeyToAccount(generatePrivateKey());\n        // Try to send Base Sepolia ETH to random generated address\n        const txHash = await walletClient.sendTransaction({\n          to: randomAccount.address,\n          chain: baseSepolia,\n          value: PushChain.utils.helpers.parseUnits('1', 14),\n        });\n        const publicClient = createPublicClient({\n          chain: baseSepolia,\n          transport: http(),\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: txHash,\n        });\n      }, 100000);\n\n      it('should fail to send universal.sendTransaction with invalid feeLockTxHash', async () => {\n        await expect(\n          pushClient.universal.sendTransaction({\n            to,\n            feeLockTxHash: '0xABC', // Invalid txHash\n            value: BigInt(1e3),\n          })\n        ).rejects.toThrow();\n      }, 30000);\n\n      it('should successfully sendTransaction - Transfer Call', async () => {\n        const tx = await pushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e3),\n        });\n        const after = await PushChain.utils.account.convertOriginToExecutor(\n          universalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n        expect(after.deployed).toBe(true);\n        await txValidator(\n          tx,\n          pushClient.universal.origin.address as `0x${string}`,\n          to\n        );\n      }, 300000);\n\n      it('should successfully sendTransaction to funded undeployed UEA', async () => {\n        const walletClient = createWalletClient({\n          account: randomAccount,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n        const randomUniversalSigner =\n          await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          });\n        const UEA = await PushChain.utils.account.convertOriginToExecutor(\n          randomUniversalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n\n        // Fund Undeployed UEA - 1PC\n        await pushClient.universal.sendTransaction({\n          to: UEA.address,\n          value: BigInt(1e18),\n        });\n\n        // Send Tx Via Random Address\n        const randomPushClient = await PushChain.initialize(\n          randomUniversalSigner,\n          {\n            network: pushNetwork,\n          }\n        );\n        await randomPushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e6),\n        });\n      }, 300000);\n    });\n\n    describe('BNB_TESTNET', () => {\n      const originChain = CHAIN.BNB_TESTNET;\n      let pushClient: PushChain;\n\n      beforeAll(async () => {\n        const privateKey = process.env['EVM_PRIVATE_KEY'] as Hex;\n        if (!privateKey) throw new Error('EVM_PRIVATE_KEY not set');\n\n        const account = privateKeyToAccount(privateKey);\n        const walletClient = createWalletClient({\n          account,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n\n        universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n          walletClient,\n          {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          }\n        );\n\n        pushClient = await PushChain.initialize(universalSigner, {\n          network: pushNetwork,\n          progressHook: (val: any) => {\n            console.log(val);\n          },\n        });\n\n        // Generate random account\n        randomAccount = privateKeyToAccount(generatePrivateKey());\n        // Try to send BNB Testnet ETH to random generated address\n        const txHash = await walletClient.sendTransaction({\n          to: randomAccount.address,\n          chain: bscTestnet,\n          value: PushChain.utils.helpers.parseUnits('1', 14),\n        });\n        const publicClient = createPublicClient({\n          chain: bscTestnet,\n          transport: http(),\n        });\n        await publicClient.waitForTransactionReceipt({\n          hash: txHash,\n        });\n      }, 100000);\n\n      it('should fail to send universal.sendTransaction with invalid feeLockTxHash', async () => {\n        await expect(\n          pushClient.universal.sendTransaction({\n            to,\n            feeLockTxHash: '0xABC', // Invalid txHash\n            value: BigInt(1e3),\n          })\n        ).rejects.toThrow();\n      }, 30000);\n\n      it('should successfully sendTransaction - Transfer Call', async () => {\n        const tx = await pushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e3),\n        });\n        const after = await PushChain.utils.account.convertOriginToExecutor(\n          universalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n        expect(after.deployed).toBe(true);\n        await txValidator(\n          tx,\n          pushClient.universal.origin.address as `0x${string}`,\n          to\n        );\n      }, 300000);\n\n      it('should successfully sendTransaction to funded undeployed UEA', async () => {\n        const walletClient = createWalletClient({\n          account: randomAccount,\n          transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n        });\n        const randomUniversalSigner =\n          await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          });\n        const UEA = await PushChain.utils.account.convertOriginToExecutor(\n          randomUniversalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n\n        // Fund Undeployed UEA - 1PC\n        await pushClient.universal.sendTransaction({\n          to: UEA.address,\n          value: BigInt(1e18),\n        });\n\n        // Send Tx Via Random Address\n        const randomPushClient = await PushChain.initialize(\n          randomUniversalSigner,\n          {\n            network: pushNetwork,\n          }\n        );\n        await randomPushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1e6),\n        });\n      }, 300000);\n    });\n  });\n  describe('Origin - Push', () => {\n    const originChain = CHAIN.PUSH_TESTNET_DONUT;\n    let pushClient: PushChain;\n    let account: PrivateKeyAccount;\n\n    beforeAll(async () => {\n      const privateKey = process.env['PUSH_PRIVATE_KEY'] as Hex;\n      if (!privateKey) throw new Error('PUSH_PRIVATE_KEY not set');\n\n      account = privateKeyToAccount(privateKey);\n      const walletClient = createWalletClient({\n        account,\n        transport: http(CHAIN_INFO[originChain].defaultRPC[0]),\n      });\n\n      universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: originChain,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      pushClient = await PushChain.initialize(universalSigner, {\n        network: pushNetwork,\n        progressHook: (val: any) => {\n          console.log(val);\n        },\n      });\n    });\n\n    it('should sendTransaction', async () => {\n      const from = pushClient.universal.account;\n      const tx = await pushClient.universal.sendTransaction({\n        to,\n        value: BigInt(2),\n      });\n      await txValidator(tx, from, to);\n    });\n  });\n  describe('Origin - SVM', () => {\n    describe('SOLANA_DEVNET', () => {\n      const originChain = CHAIN.SOLANA_DEVNET;\n      let pushClient: PushChain;\n\n      beforeAll(async () => {\n        const privateKeyHex = process.env['SOLANA_PRIVATE_KEY'];\n        if (!privateKeyHex) throw new Error('SOLANA_PRIVATE_KEY not set');\n\n        const privateKey = bs58.decode(privateKeyHex);\n\n        const account = Keypair.fromSecretKey(privateKey);\n\n        universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n          account,\n          {\n            chain: originChain,\n            library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n          }\n        );\n\n        pushClient = await PushChain.initialize(universalSigner, {\n          network: pushNetwork,\n          progressHook: (val: any) => {\n            console.log(val);\n          },\n        });\n      });\n\n      it('should fail to send universal.sendTransaction with invalid feeLockTxHash', async () => {\n        await expect(\n          pushClient.universal.sendTransaction({\n            to,\n            feeLockTxHash: '0xABC', // Invalid txHash\n            value: BigInt(1e1),\n          })\n        ).rejects.toThrow();\n      }, 30000);\n\n      it('should successfully send universal.sendTransaction', async () => {\n        const uea = pushClient.universal.account;\n        const tx = await pushClient.universal.sendTransaction({\n          to,\n          value: BigInt(1),\n        });\n        const after = await PushChain.utils.account.convertOriginToExecutor(\n          universalSigner.account,\n          {\n            onlyCompute: true,\n          }\n        );\n        expect(after.deployed).toBe(true);\n        await txValidator(tx, pushClient.universal.origin.address, to);\n      }, 300000);\n    });\n  });\n});\n\nconst txValidator = async (\n  tx: UniversalTxResponse,\n  from: string,\n  to: `0x${string}`\n) => {\n  expect(tx).toBeDefined();\n\n  // 1. Identity fields\n  expect(tx.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n  expect(tx.origin).toBeDefined();\n  expect(tx.origin).toMatch(\n    /^[a-zA-Z0-9_-]+:[a-zA-Z0-9]+:(0x[a-fA-F0-9]{40,64}|[1-9A-HJ-NP-Za-km-z]{43,44})$/\n  ); // Format: namespace:chainId:address (supports both EVM and Solana)\n\n  // 2. Block Info\n  expect(typeof tx.blockNumber).toBe('bigint');\n  expect(tx.blockNumber).toBeGreaterThanOrEqual(BigInt(0));\n  expect(typeof tx.blockHash).toBe('string');\n  expect(typeof tx.transactionIndex).toBe('number');\n  expect(typeof tx.chainId).toBe('string');\n\n  // 3. Execution Context\n  expect(tx.to?.toLowerCase()).toBe(to.toLowerCase());\n  expect(tx.origin.split(':')[2].toLowerCase()).toBe(from.toLowerCase());\n  // Always validate that from and to exist and are strings\n  expect(tx.from).toBeDefined();\n  expect(typeof tx.from).toBe('string');\n  if (tx.to) {\n    expect(typeof tx.to).toBe('string');\n  }\n  expect(typeof tx.nonce).toBe('number');\n\n  // 4. Payload\n  expect(typeof tx.data).toBe('string');\n  expect(tx.data).toMatch(/^0x/);\n  expect(typeof tx.value).toBe('bigint');\n\n  // 5. Gas-related (changed from tx.gas to tx.gasLimit)\n  expect(typeof tx.gasLimit).toBe('bigint');\n  expect(tx.gasLimit).toBeGreaterThanOrEqual(BigInt(0));\n\n  if (tx.maxFeePerGas !== undefined) {\n    expect(typeof tx.maxFeePerGas).toBe('bigint');\n    expect(tx.maxFeePerGas >= BigInt(0)).toBe(true);\n  }\n\n  if (tx.maxPriorityFeePerGas !== undefined) {\n    expect(typeof tx.maxPriorityFeePerGas).toBe('bigint');\n    expect(tx.maxPriorityFeePerGas >= BigInt(0)).toBe(true);\n  }\n\n  expect(Array.isArray(tx.accessList)).toBe(true);\n\n  // 6. Utilities\n  expect(typeof tx.wait).toBe('function');\n\n  // 7. Metadata - New fields\n  expect(typeof tx.type).toBe('string');\n  expect(['99', '2', '1', '0']).toContain(tx.type); // Universal, EIP-1559, EIP-2930, Legacy\n\n  expect(typeof tx.typeVerbose).toBe('string');\n  expect(['universal', 'eip1559', 'eip2930', 'eip4844', 'legacy']).toContain(\n    tx.typeVerbose\n  );\n\n  // Signature object validation\n  expect(tx.signature).toBeDefined();\n  expect(typeof tx.signature.r).toBe('string');\n  expect(typeof tx.signature.s).toBe('string');\n  expect(typeof tx.signature.v).toBe('number');\n  expect(typeof tx.signature.yParity).toBe('number');\n  expect(tx.signature.r).toMatch(/^0x[a-fA-F0-9]+$/);\n  expect(tx.signature.s).toMatch(/^0x[a-fA-F0-9]+$/);\n  expect([0, 1]).toContain(tx.signature.yParity);\n\n  // 8. Raw Universal Fields (optional)\n  if (tx.raw) {\n    expect(typeof tx.raw.from).toBe('string');\n    expect(typeof tx.raw.to).toBe('string');\n    expect(typeof tx.raw.nonce).toBe('number');\n    expect(typeof tx.raw.data).toBe('string');\n    expect(typeof tx.raw.value).toBe('bigint');\n  }\n\n  // Optional: Wait for receipt and confirm it's mined\n  const receipt = await tx.wait();\n  expect(receipt).toBeDefined();\n  expect(receipt.hash).toBe(tx.hash); // Same transaction\n  expect(receipt.blockNumber).toBeGreaterThan(BigInt(0));\n};\n\ndescribe('UniversalTxReceipt Type Validation', () => {\n  const pushNetwork = PUSH_NETWORK.TESTNET_DONUT;\n  const to = '0x35B84d6848D16415177c64D64504663b998A6ab4';\n  let fromEVM: `0x${string}`;\n  let fromPush: `0x${string}`;\n  let fromSolana: string;\n  let universalSignerPush: UniversalSigner;\n  let universalSignerSepolia: UniversalSigner;\n  let universalSignerSolana: UniversalSigner;\n  let pushClientPush: PushChain;\n  let pushClientSepolia: PushChain;\n  let pushClientSolana: PushChain;\n\n  beforeAll(async () => {\n    const privateKeyEVM = process.env['EVM_PRIVATE_KEY'] as Hex;\n    if (!privateKeyEVM) throw new Error('EVM_PRIVATE_KEY not set');\n    const privateKeyPush = process.env['PUSH_PRIVATE_KEY'] as Hex;\n    if (!privateKeyPush) throw new Error('EVM_PRIVATE_KEY not set');\n    const privateKeySolana = process.env['SOLANA_PRIVATE_KEY'];\n    if (!privateKeySolana) throw new Error('SOLANA_PRIVATE_KEY not set');\n    const accountSolana = Keypair.fromSecretKey(\n      hexToBytes(`0x${privateKeySolana}`)\n    );\n    fromEVM = privateKeyToAccount(privateKeyEVM).address;\n    fromPush = privateKeyToAccount(privateKeyPush).address;\n    fromSolana = accountSolana.publicKey.toBase58();\n\n    const walletClientPush = createWalletClient({\n      account: privateKeyToAccount(privateKeyPush),\n      transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET].defaultRPC[0]),\n    });\n    const walletClientSepolia = createWalletClient({\n      account: privateKeyToAccount(privateKeyEVM),\n      chain: sepolia,\n      transport: http(CHAIN_INFO[CHAIN.ETHEREUM_SEPOLIA].defaultRPC[0]),\n    });\n\n    universalSignerPush = await PushChain.utils.signer.toUniversal(\n      walletClientPush\n    );\n    universalSignerSepolia = await PushChain.utils.signer.toUniversal(\n      walletClientSepolia\n    );\n    universalSignerSolana = await PushChain.utils.signer.toUniversalFromKeypair(\n      accountSolana,\n      {\n        chain: CHAIN.SOLANA_DEVNET,\n        library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n      }\n    );\n    pushClientPush = await PushChain.initialize(universalSignerPush, {\n      network: pushNetwork,\n    });\n    pushClientSepolia = await PushChain.initialize(universalSignerSepolia, {\n      network: pushNetwork,\n    });\n    pushClientSolana = await PushChain.initialize(universalSignerSolana, {\n      network: pushNetwork,\n    });\n  });\n\n  describe('Response Type Structure', () => {\n    it('should return UniversalTxReceipt with all required fields', async () => {\n      const txPush = await pushClientPush.universal.sendTransaction({\n        to,\n        value: BigInt(1000),\n      });\n      const txSepolia = await pushClientSepolia.universal.sendTransaction({\n        to,\n        value: BigInt(1000),\n      });\n      const txSolana = await pushClientSolana.universal.sendTransaction({\n        to,\n        value: BigInt(1000),\n      });\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      await txPush.wait();\n      await txSepolia.wait();\n      await txSolana.wait();\n\n      // Use the existing txValidator function with skipAddressValidation\n      await txValidator(txPush, fromPush, to);\n      await txValidator(txSepolia, fromEVM, to);\n      await txValidator(txSolana, fromSolana, to);\n    }, 60000);\n\n    it('should have valid origin field format', async () => {\n      const txPush = await pushClientPush.universal.sendTransaction({\n        to,\n        value: BigInt(100),\n      });\n      const txSepolia = await pushClientSepolia.universal.sendTransaction({\n        to,\n        value: BigInt(100),\n      });\n      const txSolana = await pushClientSolana.universal.sendTransaction({\n        to,\n        value: BigInt(100),\n      });\n\n      await txPush.wait();\n      await txSepolia.wait();\n      await txSolana.wait();\n\n      // Use txValidator for comprehensive validation (includes origin format validation)\n      await txValidator(txPush, fromPush, to);\n      await txValidator(txSepolia, fromEVM, to);\n      await txValidator(txSolana, fromSolana, to);\n\n      // Additional specific origin content validations\n      expect(txPush.origin).toContain('eip155'); // EVM namespace\n      expect(txSepolia.origin).toContain('eip155'); // EVM namespace\n      expect(txSolana.origin).toContain('solana'); // Solana namespace\n      expect(txPush.origin).toContain('42101'); // Push chain ID\n      expect(txSepolia.origin).toContain('11155111'); // Push chain ID\n      expect(txSolana.origin).toContain('EtWTRABZaYq6iMfeYKouRu166VU2xqa1'); // Push chain ID\n      expect(txPush.origin).toContain(txPush.from);\n      expect(txSepolia.origin).not.toContain(txSepolia.from);\n      expect(txSolana.origin).not.toContain(txSolana.from);\n      expect(txPush.origin).toContain(universalSignerPush.account.address);\n      expect(txSepolia.origin.toLowerCase()).toContain(\n        universalSignerSepolia.account.address.toLowerCase()\n      );\n      expect(txSolana.origin.toLowerCase()).toContain(\n        universalSignerSolana.account.address.toLowerCase()\n      );\n    }, 60000);\n\n    it('should have raw transaction data when available', async () => {\n      const testTo = '0x35B84d6848D16415177c64D64504663b998A6ab4';\n      const testValue = BigInt(300);\n      const testData = '0x1234';\n      const txPush = await pushClientPush.universal.sendTransaction({\n        to: testTo,\n        value: testValue,\n        data: testData,\n      });\n      await txValidator(txPush, fromPush, to);\n\n      // Additional specific raw data validations\n      if (txPush.raw) {\n        expect(txPush.raw.to).toBe(testTo);\n        expect(txPush.raw.value).toBe(testValue);\n        expect(txPush.raw.data).toBe(testData);\n        expect(txPush.raw.from).toBe(universalSignerPush.account.address);\n      }\n    }, 60000);\n\n    it('should maintain wait function compatibility', async () => {\n      const tx = await pushClientPush.universal.sendTransaction({\n        to,\n        value: BigInt(150),\n      });\n\n      expect(typeof tx.wait).toBe('function');\n\n      // Wait function should return UniversalTxReceipt\n      const waitResult = await tx.wait();\n\n      // --- Identity ---\n      expect(waitResult.hash).toBeDefined();\n      expect(typeof waitResult.hash).toBe('string');\n\n      // --- Block Info ---\n      expect(waitResult.blockNumber).toBeDefined();\n      expect(typeof waitResult.blockNumber).toBe('bigint');\n      expect(waitResult.blockNumber).toBeGreaterThanOrEqual(BigInt(0));\n      expect(waitResult.blockHash).toBeDefined();\n      expect(typeof waitResult.blockHash).toBe('string');\n      expect(waitResult.transactionIndex).toBeDefined();\n      expect(typeof waitResult.transactionIndex).toBe('number');\n      expect(waitResult.transactionIndex).toBeGreaterThanOrEqual(0);\n\n      // --- Execution Context ---\n      expect(waitResult.from).toBeDefined();\n      expect(typeof waitResult.from).toBe('string');\n      expect(waitResult.from).toMatch(/^0x[a-fA-F0-9]{40}$/);\n      expect(waitResult.to).toBeDefined();\n      expect(typeof waitResult.to).toBe('string');\n      expect(waitResult.to).toMatch(/^0x[a-fA-F0-9]{40}$/);\n      expect(\n        waitResult.contractAddress === null ||\n          typeof waitResult.contractAddress === 'string'\n      ).toBe(true);\n      if (waitResult.contractAddress) {\n        expect(waitResult.contractAddress).toMatch(/^0x[a-fA-F0-9]{40}$/);\n      }\n\n      // --- Gas & Usage ---\n      expect(waitResult.gasPrice).toBeDefined();\n      expect(typeof waitResult.gasPrice).toBe('bigint');\n      expect(waitResult.gasPrice).toBeGreaterThanOrEqual(BigInt(0));\n      expect(waitResult.gasUsed).toBeDefined();\n      expect(typeof waitResult.gasUsed).toBe('bigint');\n      expect(waitResult.gasUsed).toBeGreaterThanOrEqual(BigInt(0));\n      expect(waitResult.cumulativeGasUsed).toBeDefined();\n      expect(typeof waitResult.cumulativeGasUsed).toBe('bigint');\n      expect(waitResult.cumulativeGasUsed).toBeGreaterThanOrEqual(BigInt(0));\n\n      // --- Logs ---\n      expect(Array.isArray(waitResult.logs)).toBe(true);\n      expect(waitResult.logsBloom).toBeDefined();\n      expect(typeof waitResult.logsBloom).toBe('string');\n\n      // --- Outcome ---\n      expect([0, 1]).toContain(waitResult.status);\n\n      // --- Raw ---\n      expect(waitResult.raw).toBeDefined();\n      expect(typeof waitResult.raw).toBe('object');\n      expect(waitResult.raw.from).toBeDefined();\n      expect(typeof waitResult.raw.from).toBe('string');\n      expect(waitResult.raw.from).toMatch(/^0x[a-fA-F0-9]{40}$/);\n      expect(waitResult.raw.to).toBeDefined();\n      expect(typeof waitResult.raw.to).toBe('string');\n      expect(waitResult.raw.to).toMatch(/^0x[a-fA-F0-9]{40}$/);\n    }, 60000);\n  });\n});\n\n/** CLI COMMANDS\n \nTO GENERATE UNSIGNED TX\n  pchaind tx bank send acc1 push1f5th78lzntc2h0krzqn5yldvwg43lcrgkqxtsv 1000npush \\\n  --generate-only --output json > unsigned.json\n\nTO SIGN THE TX & GENERATE SIGNED TX ( VIA ACC 1 )\n  pchaind tx sign unsigned.json \\\n  --from acc1 --chain-id localchain_9000-1 \\\n  --keyring-backend test \\\n  --output-document signed.json\n\nTO ENCODE TX\n  pchaind tx encode signed.json\n\nTO DECODE TX\n  pchaind tx decode base64EncodedString\n\n */\n",
  "packages/core/jest.config.ts": "export default {\n  displayName: 'core',\n  preset: '../../jest.preset.js',\n  testEnvironment: 'node',\n  setupFiles: ['dotenv/config'],\n  transform: {\n    '^.+\\\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],\n  },\n  moduleFileExtensions: ['ts', 'js', 'html'],\n  coverageDirectory: '../../coverage/packages/core',\n  testTimeout: 300000, // Allow long-running integration tests (5 min)\n};\n",
  "packages/core/src/index.ts": "import './lib/internal/global-buffer-polyfill';\n\nexport * from './lib';\n// trigger major release 2.0.0\n// trigger github action 2\n",
  "packages/core/src/lib/cache/cache.ts": "import { CHAIN, PUSH_NETWORK, VM } from '../constants/enums';\n\ntype CacheEntry = {\n  value: any;\n  createdAt: number;\n  ttl?: number;\n};\n\nexport class CacheKeys {\n  static ueaAddressOnchain(\n    chain: CHAIN,\n    address: string,\n    pushNetwork: PUSH_NETWORK,\n    vm: VM\n  ): string {\n    return `uea_address_onchain:${chain}:${address}:${pushNetwork}:${vm}`;\n  }\n\n  static deploymentStatus(address: string): string {\n    return `deployment_status:${address}`;\n  }\n}\n\nexport class Cache {\n  private cache: Map<string, CacheEntry>;\n  private maxSize: number;\n\n  constructor(maxSize = 100) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n\n  private isExpired(entry: CacheEntry): boolean {\n    if (!entry.ttl) return false;\n    return Date.now() > entry.createdAt + entry.ttl;\n  }\n\n  get(key: string): any | null {\n    if (!this.cache.has(key)) return null;\n\n    const entry = this.cache.get(key);\n\n    if (entry != undefined) {\n      if (this.isExpired(entry)) {\n        this.cache.delete(key);\n        return null;\n      }\n\n      this.cache.delete(key);\n      this.cache.set(key, entry);\n      return entry.value;\n    }\n    return null;\n  }\n\n  set(key: string, value: any, ttl?: number): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      const oldestKey = this.cache.keys().next().value;\n      if (oldestKey != undefined) {\n        this.cache.delete(oldestKey);\n      }\n    }\n\n    this.cache.set(key, {\n      value,\n      createdAt: Date.now(),\n      ttl,\n    });\n  }\n\n  clear(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clearAll(): void {\n    this.cache.clear();\n  }\n\n  size(): number {\n    return this.cache.size;\n  }\n}\n",
  "packages/core/src/lib/constants/abi/erc20.evm.ts": "export const ERC20_EVM = [\n  {\n    type: 'function',\n    name: 'allowance',\n    inputs: [\n      { name: 'owner', type: 'address', internalType: 'address' },\n      { name: 'spender', type: 'address', internalType: 'address' },\n    ],\n    outputs: [{ name: '', type: 'uint256', internalType: 'uint256' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'approve',\n    inputs: [\n      { name: 'spender', type: 'address', internalType: 'address' },\n      { name: 'amount', type: 'uint256', internalType: 'uint256' },\n    ],\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'transfer',\n    inputs: [\n      { name: 'recipient', type: 'address', internalType: 'address' },\n      { name: 'amount', type: 'uint256', internalType: 'uint256' },\n    ],\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'transferFrom',\n    inputs: [\n      { name: 'sender', type: 'address', internalType: 'address' },\n      { name: 'recipient', type: 'address', internalType: 'address' },\n      { name: 'amount', type: 'uint256', internalType: 'uint256' },\n    ],\n  },\n] as const;\n",
  "packages/core/src/lib/constants/abi/factoryV1.ts": "export const FACTORY_V1 = [\n  {\n    type: 'constructor',\n    inputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'CHAIN_to_VM',\n    inputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'UEA_VM',\n    inputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'UOA_to_UEA',\n    inputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'computeUEA',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'deployUEA',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'generateSalt',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'pure',\n  },\n  {\n    type: 'function',\n    name: 'getOriginForUEA',\n    inputs: [\n      {\n        name: 'addr',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [\n      {\n        name: 'account',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n      {\n        name: 'isUEA',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getUEA',\n    inputs: [\n      {\n        name: '_chainHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getUEAForOrigin',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: 'uea',\n        type: 'address',\n        internalType: 'address',\n      },\n      {\n        name: 'isDeployed',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getVMType',\n    inputs: [\n      {\n        name: '_chainHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'vmHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'isRegistered',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'hasCode',\n    inputs: [\n      {\n        name: '_addr',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initialize',\n    inputs: [\n      {\n        name: 'initialOwner',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'owner',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'registerMultipleUEA',\n    inputs: [\n      {\n        name: '_chainHashes',\n        type: 'bytes32[]',\n        internalType: 'bytes32[]',\n      },\n      {\n        name: '_vmHashes',\n        type: 'bytes32[]',\n        internalType: 'bytes32[]',\n      },\n      {\n        name: '_UEA',\n        type: 'address[]',\n        internalType: 'address[]',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'registerNewChain',\n    inputs: [\n      {\n        name: '_chainHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: '_vmHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'registerUEA',\n    inputs: [\n      {\n        name: '_chainHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: '_vmHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: '_UEA',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'renounceOwnership',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'transferOwnership',\n    inputs: [\n      {\n        name: 'newOwner',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'event',\n    name: 'ChainRegistered',\n    inputs: [\n      {\n        name: 'chainHash',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'vmHash',\n        type: 'bytes32',\n        indexed: false,\n        internalType: 'bytes32',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'Initialized',\n    inputs: [\n      {\n        name: 'version',\n        type: 'uint64',\n        indexed: false,\n        internalType: 'uint64',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'OwnershipTransferred',\n    inputs: [\n      {\n        name: 'previousOwner',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'newOwner',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'UEADeployed',\n    inputs: [\n      {\n        name: 'UEA',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'owner',\n        type: 'bytes',\n        indexed: false,\n        internalType: 'bytes',\n      },\n      {\n        name: 'sourceChainId',\n        type: 'string',\n        indexed: false,\n        internalType: 'string',\n      },\n      {\n        name: 'chainHash',\n        type: 'bytes32',\n        indexed: false,\n        internalType: 'bytes32',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'UEARegistered',\n    inputs: [\n      {\n        name: 'chainHash',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'UEA_Logic',\n        type: 'address',\n        indexed: false,\n        internalType: 'address',\n      },\n      {\n        name: 'vmHash',\n        type: 'bytes32',\n        indexed: false,\n        internalType: 'bytes32',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'error',\n    name: 'AccountAlreadyExists',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'FailedDeployment',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'InsufficientBalance',\n    inputs: [\n      {\n        name: 'balance',\n        type: 'uint256',\n        internalType: 'uint256',\n      },\n      {\n        name: 'needed',\n        type: 'uint256',\n        internalType: 'uint256',\n      },\n    ],\n  },\n  {\n    type: 'error',\n    name: 'InvalidInitialization',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'InvalidInputArgs',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'NotInitializing',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'OwnableInvalidOwner',\n    inputs: [\n      {\n        name: 'owner',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n  },\n  {\n    type: 'error',\n    name: 'OwnableUnauthorizedAccount',\n    inputs: [\n      {\n        name: 'account',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n  },\n];\n",
  "packages/core/src/lib/constants/abi/feeLocker.evm.ts": "export const FEE_LOCKER_EVM = [\n  {\n    type: 'function',\n    name: 'DEFAULT_ADMIN_ROLE',\n    inputs: [],\n    outputs: [{ name: '', type: 'bytes32', internalType: 'bytes32' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'UNISWAP_ROUTER',\n    inputs: [],\n    outputs: [{ name: '', type: 'address', internalType: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'UPGRADE_INTERFACE_VERSION',\n    inputs: [],\n    outputs: [{ name: '', type: 'string', internalType: 'string' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'USDT',\n    inputs: [],\n    outputs: [{ name: '', type: 'address', internalType: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'WETH',\n    inputs: [],\n    outputs: [{ name: '', type: 'address', internalType: 'address' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'addFunds',\n    inputs: [\n      {\n        name: '_transactionHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'ethUsdPriceFeed',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'contract AggregatorV3Interface',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getEthUsdPrice',\n    inputs: [],\n    outputs: [\n      { name: '', type: 'uint256', internalType: 'uint256' },\n      { name: '', type: 'uint8', internalType: 'uint8' },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getEthUsdPrice_old',\n    inputs: [],\n    outputs: [\n      { name: '', type: 'uint256', internalType: 'uint256' },\n      { name: '', type: 'uint8', internalType: 'uint8' },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'getRoleAdmin',\n    inputs: [{ name: 'role', type: 'bytes32', internalType: 'bytes32' }],\n    outputs: [{ name: '', type: 'bytes32', internalType: 'bytes32' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'grantRole',\n    inputs: [\n      { name: 'role', type: 'bytes32', internalType: 'bytes32' },\n      { name: 'account', type: 'address', internalType: 'address' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'hasRole',\n    inputs: [\n      { name: 'role', type: 'bytes32', internalType: 'bytes32' },\n      { name: 'account', type: 'address', internalType: 'address' },\n    ],\n    outputs: [{ name: '', type: 'bool', internalType: 'bool' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initialize',\n    inputs: [\n      { name: '_admin', type: 'address', internalType: 'address' },\n      { name: '_weth', type: 'address', internalType: 'address' },\n      { name: '_usdt', type: 'address', internalType: 'address' },\n      { name: '_router', type: 'address', internalType: 'address' },\n      { name: '_priceFeed', type: 'address', internalType: 'address' },\n      {\n        name: '_usdtPriceFeed',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'proxiableUUID',\n    inputs: [],\n    outputs: [{ name: '', type: 'bytes32', internalType: 'bytes32' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'recoverToken',\n    inputs: [\n      { name: '_recipient', type: 'address', internalType: 'address' },\n      { name: 'amount', type: 'uint256', internalType: 'uint256' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'renounceRole',\n    inputs: [\n      { name: 'role', type: 'bytes32', internalType: 'bytes32' },\n      {\n        name: 'callerConfirmation',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'revokeRole',\n    inputs: [\n      { name: 'role', type: 'bytes32', internalType: 'bytes32' },\n      { name: 'account', type: 'address', internalType: 'address' },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'supportsInterface',\n    inputs: [{ name: 'interfaceId', type: 'bytes4', internalType: 'bytes4' }],\n    outputs: [{ name: '', type: 'bool', internalType: 'bool' }],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'upgradeToAndCall',\n    inputs: [\n      {\n        name: 'newImplementation',\n        type: 'address',\n        internalType: 'address',\n      },\n      { name: 'data', type: 'bytes', internalType: 'bytes' },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'usdtUsdPriceFeed',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'contract AggregatorV3Interface',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'event',\n    name: 'FundsAdded',\n    inputs: [\n      {\n        name: 'user',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'transactionHash',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'AmountInUSD',\n        type: 'tuple',\n        indexed: false,\n        internalType: 'struct UniversalGateway.AmountInUSD',\n        components: [\n          {\n            name: 'amountInUSD',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          { name: 'decimals', type: 'uint8', internalType: 'uint8' },\n        ],\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'Initialized',\n    inputs: [\n      {\n        name: 'version',\n        type: 'uint64',\n        indexed: false,\n        internalType: 'uint64',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'RoleAdminChanged',\n    inputs: [\n      {\n        name: 'role',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'previousAdminRole',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'newAdminRole',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'RoleGranted',\n    inputs: [\n      {\n        name: 'role',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'account',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'sender',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'RoleRevoked',\n    inputs: [\n      {\n        name: 'role',\n        type: 'bytes32',\n        indexed: true,\n        internalType: 'bytes32',\n      },\n      {\n        name: 'account',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'sender',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'TokenRecovered',\n    inputs: [\n      {\n        name: 'admin',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n      {\n        name: 'amount',\n        type: 'uint256',\n        indexed: true,\n        internalType: 'uint256',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'event',\n    name: 'Upgraded',\n    inputs: [\n      {\n        name: 'implementation',\n        type: 'address',\n        indexed: true,\n        internalType: 'address',\n      },\n    ],\n    anonymous: false,\n  },\n  { type: 'error', name: 'AccessControlBadConfirmation', inputs: [] },\n  {\n    type: 'error',\n    name: 'AccessControlUnauthorizedAccount',\n    inputs: [\n      { name: 'account', type: 'address', internalType: 'address' },\n      { name: 'neededRole', type: 'bytes32', internalType: 'bytes32' },\n    ],\n  },\n  {\n    type: 'error',\n    name: 'AddressEmptyCode',\n    inputs: [{ name: 'target', type: 'address', internalType: 'address' }],\n  },\n  {\n    type: 'error',\n    name: 'ERC1967InvalidImplementation',\n    inputs: [\n      {\n        name: 'implementation',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n  },\n  { type: 'error', name: 'ERC1967NonPayable', inputs: [] },\n  { type: 'error', name: 'FailedCall', inputs: [] },\n  { type: 'error', name: 'InvalidInitialization', inputs: [] },\n  { type: 'error', name: 'NotInitializing', inputs: [] },\n  { type: 'error', name: 'ReentrancyGuardReentrantCall', inputs: [] },\n  {\n    type: 'error',\n    name: 'SafeERC20FailedOperation',\n    inputs: [{ name: 'token', type: 'address', internalType: 'address' }],\n  },\n  { type: 'error', name: 'UUPSUnauthorizedCallContext', inputs: [] },\n  {\n    type: 'error',\n    name: 'UUPSUnsupportedProxiableUUID',\n    inputs: [{ name: 'slot', type: 'bytes32', internalType: 'bytes32' }],\n  },\n];\n",
  "packages/core/src/lib/constants/abi/index.ts": "export { FEE_LOCKER_EVM } from './feeLocker.evm';\nexport { default as FEE_LOCKER_SVM } from './feeLocker.json';\nexport { FACTORY_V1 } from './factoryV1';\nexport { UEA_EVM } from './uea.evm';\nexport { UEA_SVM } from './uea.svm';\nexport { UNIVERSAL_GATEWAY_V0 } from './universalGatewayV0.evm';\nexport { ERC20_EVM } from './erc20.evm';\nexport { default as SVM_GATEWAY_IDL } from './universalGatewayV0.json';\n",
  "packages/core/src/lib/constants/abi/uea.evm.ts": "export const UEA_EVM = [\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'VERSION',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'string',\n        internalType: 'string',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'domainSeparator',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'executePayload',\n    inputs: [\n      {\n        name: 'payload',\n        type: 'tuple',\n        internalType: 'struct UniversalPayload',\n        components: [\n          {\n            name: 'to',\n            type: 'address',\n            internalType: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n          {\n            name: 'gasLimit',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'vType',\n            type: 'uint8',\n            internalType: 'enum VerificationType',\n          },\n        ],\n      },\n      {\n        name: 'signature',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'getTransactionHash',\n    inputs: [\n      {\n        name: 'payload',\n        type: 'tuple',\n        internalType: 'struct UniversalPayload',\n        components: [\n          {\n            name: 'to',\n            type: 'address',\n            internalType: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n          {\n            name: 'gasLimit',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'vType',\n            type: 'uint8',\n            internalType: 'enum VerificationType',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initialize',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'nonce',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'uint256',\n        internalType: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'universalAccount',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'verifyPayloadSignature',\n    inputs: [\n      {\n        name: 'messageHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'signature',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'event',\n    name: 'PayloadExecuted',\n    inputs: [\n      {\n        name: 'caller',\n        type: 'bytes',\n        indexed: false,\n        internalType: 'bytes',\n      },\n      {\n        name: 'target',\n        type: 'address',\n        indexed: false,\n        internalType: 'address',\n      },\n      {\n        name: 'data',\n        type: 'bytes',\n        indexed: false,\n        internalType: 'bytes',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'error',\n    name: 'AlreadyInitialized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ECDSAInvalidSignature',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ECDSAInvalidSignatureLength',\n    inputs: [\n      {\n        name: 'length',\n        type: 'uint256',\n        internalType: 'uint256',\n      },\n    ],\n  },\n  {\n    type: 'error',\n    name: 'ECDSAInvalidSignatureS',\n    inputs: [\n      {\n        name: 's',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n  },\n  {\n    type: 'error',\n    name: 'ExecutionFailed',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ExpiredDeadline',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'InvalidEVMSignature',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ReentrancyGuardReentrantCall',\n    inputs: [],\n  },\n];\n",
  "packages/core/src/lib/constants/abi/uea.svm.ts": "export const UEA_SVM = [\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'VERIFIER_PRECOMPILE',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'address',\n        internalType: 'address',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'VERSION',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'string',\n        internalType: 'string',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'domainSeparator',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'executePayload',\n    inputs: [\n      {\n        name: 'payload',\n        type: 'tuple',\n        internalType: 'struct UniversalPayload',\n        components: [\n          {\n            name: 'to',\n            type: 'address',\n            internalType: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n          {\n            name: 'gasLimit',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'vType',\n            type: 'uint8',\n            internalType: 'enum VerificationType',\n          },\n        ],\n      },\n      {\n        name: 'signature',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'getTransactionHash',\n    inputs: [\n      {\n        name: 'payload',\n        type: 'tuple',\n        internalType: 'struct UniversalPayload',\n        components: [\n          {\n            name: 'to',\n            type: 'address',\n            internalType: 'address',\n          },\n          {\n            name: 'value',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'data',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n          {\n            name: 'gasLimit',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'nonce',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n            internalType: 'uint256',\n          },\n          {\n            name: 'vType',\n            type: 'uint8',\n            internalType: 'enum VerificationType',\n          },\n        ],\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'initialize',\n    inputs: [\n      {\n        name: '_id',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n  {\n    type: 'function',\n    name: 'nonce',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'uint256',\n        internalType: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'universalAccount',\n    inputs: [],\n    outputs: [\n      {\n        name: '',\n        type: 'tuple',\n        internalType: 'struct UniversalAccountId',\n        components: [\n          {\n            name: 'chainNamespace',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'chainId',\n            type: 'string',\n            internalType: 'string',\n          },\n          {\n            name: 'owner',\n            type: 'bytes',\n            internalType: 'bytes',\n          },\n        ],\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'function',\n    name: 'verifyPayloadSignature',\n    inputs: [\n      {\n        name: 'messageHash',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'signature',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        name: '',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'event',\n    name: 'PayloadExecuted',\n    inputs: [\n      {\n        name: 'caller',\n        type: 'bytes',\n        indexed: false,\n        internalType: 'bytes',\n      },\n      {\n        name: 'target',\n        type: 'address',\n        indexed: false,\n        internalType: 'address',\n      },\n      {\n        name: 'data',\n        type: 'bytes',\n        indexed: false,\n        internalType: 'bytes',\n      },\n    ],\n    anonymous: false,\n  },\n  {\n    type: 'error',\n    name: 'AlreadyInitialized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ExecutionFailed',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ExpiredDeadline',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'InvalidSVMSignature',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'PrecompileCallFailed',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'ReentrancyGuardReentrantCall',\n    inputs: [],\n  },\n];\n",
  "packages/core/src/lib/constants/abi/universalGatewayV0.evm.ts": "export const UNIVERSAL_GATEWAY_V0 = [\n  { inputs: [], name: 'AccessControlBadConfirmation', type: 'error' },\n  {\n    inputs: [\n      { internalType: 'address', name: 'account', type: 'address' },\n      { internalType: 'bytes32', name: 'neededRole', type: 'bytes32' },\n    ],\n    name: 'AccessControlUnauthorizedAccount',\n    type: 'error',\n  },\n  { inputs: [], name: 'BlockCapLimitExceeded', type: 'error' },\n  { inputs: [], name: 'DepositFailed', type: 'error' },\n  { inputs: [], name: 'EnforcedPause', type: 'error' },\n  { inputs: [], name: 'ExpectedPause', type: 'error' },\n  { inputs: [], name: 'InvalidAmount', type: 'error' },\n  { inputs: [], name: 'InvalidCapRange', type: 'error' },\n  { inputs: [], name: 'InvalidData', type: 'error' },\n  { inputs: [], name: 'InvalidInitialization', type: 'error' },\n  { inputs: [], name: 'InvalidInput', type: 'error' },\n  { inputs: [], name: 'InvalidRecipient', type: 'error' },\n  { inputs: [], name: 'InvalidTxType', type: 'error' },\n  { inputs: [], name: 'NotInitializing', type: 'error' },\n  { inputs: [], name: 'NotSupported', type: 'error' },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'token', type: 'address' }],\n    name: 'SafeERC20FailedOperation',\n    type: 'error',\n  },\n  { inputs: [], name: 'SlippageExceededOrExpired', type: 'error' },\n  { inputs: [], name: 'WithdrawFailed', type: 'error' },\n  { inputs: [], name: 'ZeroAddress', type: 'error' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'minCapUsd',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'maxCapUsd',\n        type: 'uint256',\n      },\n    ],\n    name: 'CapsUpdated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'oldDuration',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'newDuration',\n        type: 'uint256',\n      },\n    ],\n    name: 'EpochDurationUpdated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: 'address', name: 'user', type: 'address' },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'transactionHash',\n        type: 'bytes32',\n      },\n      {\n        components: [\n          { internalType: 'uint256', name: 'amountInUSD', type: 'uint256' },\n          { internalType: 'uint8', name: 'decimals', type: 'uint8' },\n        ],\n        indexed: false,\n        internalType: 'struct UniversalGatewayV0.AmountInUSD',\n        name: 'AmountInUSD',\n        type: 'tuple',\n      },\n    ],\n    name: 'FundsAdded',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint64',\n        name: 'version',\n        type: 'uint64',\n      },\n    ],\n    name: 'Initialized',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'Paused',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'previousAdminRole',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'newAdminRole',\n        type: 'bytes32',\n      },\n    ],\n    name: 'RoleAdminChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n    ],\n    name: 'RoleGranted',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n    ],\n    name: 'RoleRevoked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'newThreshold',\n        type: 'uint256',\n      },\n    ],\n    name: 'TokenLimitThresholdUpdated',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'recipient',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'token',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bytes', name: 'payload', type: 'bytes' },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        indexed: false,\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      {\n        indexed: false,\n        internalType: 'enum TX_TYPE',\n        name: 'txType',\n        type: 'uint8',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'signatureData',\n        type: 'bytes',\n      },\n    ],\n    name: 'UniversalTx',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n    ],\n    name: 'Unpaused',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'recipient',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'tokenAddress',\n        type: 'address',\n      },\n    ],\n    name: 'WithdrawFunds',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'BLOCK_USD_CAP',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'DEFAULT_ADMIN_ROLE',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'MAX_CAP_UNIVERSAL_TX_USD',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'MIN_CAP_UNIVERSAL_TX_USD',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'PAUSER_ROLE',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'POOL_FEE',\n    outputs: [{ internalType: 'uint24', name: '', type: 'uint24' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'TSS_ADDRESS',\n    outputs: [{ internalType: 'address', name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'TSS_ROLE',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'USDT',\n    outputs: [{ internalType: 'address', name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'WETH',\n    outputs: [{ internalType: 'address', name: '', type: 'address' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'amountWei', type: 'uint256' }],\n    name: '_checkBlockUSDCap',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'amount', type: 'uint256' }],\n    name: '_checkUSDCaps',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: '_transactionHash', type: 'bytes32' },\n    ],\n    name: 'addFunds',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'chainlinkEthUsdDecimals',\n    outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'chainlinkStalePeriod',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'token', type: 'address' }],\n    name: 'currentTokenUsage',\n    outputs: [\n      { internalType: 'uint256', name: 'used', type: 'uint256' },\n      { internalType: 'uint256', name: 'remaining', type: 'uint256' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'defaultSwapDeadlineSec',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'epochDurationSec',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'ethUsdFeed',\n    outputs: [\n      {\n        internalType: 'contract AggregatorV3Interface',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getEthUsdPrice',\n    outputs: [\n      { internalType: 'uint256', name: '', type: 'uint256' },\n      { internalType: 'uint8', name: '', type: 'uint8' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getEthUsdPrice_old',\n    outputs: [\n      { internalType: 'uint256', name: '', type: 'uint256' },\n      { internalType: 'uint8', name: '', type: 'uint8' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getMinMaxValueForNative',\n    outputs: [\n      { internalType: 'uint256', name: 'minValue', type: 'uint256' },\n      { internalType: 'uint256', name: 'maxValue', type: 'uint256' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes32', name: 'role', type: 'bytes32' }],\n    name: 'getRoleAdmin',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      { internalType: 'address', name: 'account', type: 'address' },\n    ],\n    name: 'grantRole',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      { internalType: 'address', name: 'account', type: 'address' },\n    ],\n    name: 'hasRole',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'admin', type: 'address' },\n      { internalType: 'address', name: 'pauser', type: 'address' },\n      { internalType: 'address', name: 'tss', type: 'address' },\n      { internalType: 'uint256', name: 'minCapUsd', type: 'uint256' },\n      { internalType: 'uint256', name: 'maxCapUsd', type: 'uint256' },\n      { internalType: 'address', name: 'factory', type: 'address' },\n      { internalType: 'address', name: 'router', type: 'address' },\n      { internalType: 'address', name: '_wethAddress', type: 'address' },\n      { internalType: 'address', name: '_usdtAddress', type: 'address' },\n      { internalType: 'address', name: '_usdtUsdPriceFeed', type: 'address' },\n      { internalType: 'address', name: '_ethUsdPriceFeed', type: 'address' },\n    ],\n    name: 'initialize',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: '', type: 'address' }],\n    name: 'isSupportedToken',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'l2SequencerFeed',\n    outputs: [\n      {\n        internalType: 'contract AggregatorV3Interface',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'l2SequencerGracePeriodSec',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address[]', name: 'tokens', type: 'address[]' },\n      { internalType: 'bool[]', name: 'isSupported', type: 'bool[]' },\n    ],\n    name: 'modifySupportForToken',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'pause',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'paused',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'amountWei', type: 'uint256' }],\n    name: 'quoteEthAmountInUsd1e18',\n    outputs: [{ internalType: 'uint256', name: 'usd1e18', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      { internalType: 'address', name: 'callerConfirmation', type: 'address' },\n    ],\n    name: 'renounceRole',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'token', type: 'address' },\n      { internalType: 'uint256', name: 'amount', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n    ],\n    name: 'revertWithdrawFunds',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes32', name: 'role', type: 'bytes32' },\n      { internalType: 'address', name: 'account', type: 'address' },\n    ],\n    name: 'revokeRole',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'recipient', type: 'address' },\n      { internalType: 'address', name: 'bridgeToken', type: 'address' },\n      { internalType: 'uint256', name: 'bridgeAmount', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n    ],\n    name: 'sendFunds',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'bridgeToken', type: 'address' },\n      { internalType: 'uint256', name: 'bridgeAmount', type: 'uint256' },\n      { internalType: 'address', name: 'gasToken', type: 'address' },\n      { internalType: 'uint256', name: 'gasAmount', type: 'uint256' },\n      { internalType: 'uint256', name: 'amountOutMinETH', type: 'uint256' },\n      { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithFunds',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'bridgeToken', type: 'address' },\n      { internalType: 'uint256', name: 'bridgeAmount', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithFunds',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'bridgeToken', type: 'address' },\n      { internalType: 'uint256', name: 'bridgeAmount', type: 'uint256' },\n      { internalType: 'address', name: 'gasToken', type: 'address' },\n      { internalType: 'uint256', name: 'gasAmount', type: 'uint256' },\n      { internalType: 'uint256', name: 'amountOutMinETH', type: 'uint256' },\n      { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithFunds_new',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'bridgeToken', type: 'address' },\n      { internalType: 'uint256', name: 'bridgeAmount', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithFunds_new',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithGas',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'tokenIn', type: 'address' },\n      { internalType: 'uint256', name: 'amountIn', type: 'uint256' },\n      {\n        components: [\n          { internalType: 'address', name: 'to', type: 'address' },\n          { internalType: 'uint256', name: 'value', type: 'uint256' },\n          { internalType: 'bytes', name: 'data', type: 'bytes' },\n          { internalType: 'uint256', name: 'gasLimit', type: 'uint256' },\n          { internalType: 'uint256', name: 'maxFeePerGas', type: 'uint256' },\n          {\n            internalType: 'uint256',\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n          {\n            internalType: 'enum VerificationType',\n            name: 'vType',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct UniversalPayload',\n        name: 'payload',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { internalType: 'address', name: 'fundRecipient', type: 'address' },\n          { internalType: 'bytes', name: 'revertMsg', type: 'bytes' },\n        ],\n        internalType: 'struct RevertInstructions',\n        name: 'revertInstruction',\n        type: 'tuple',\n      },\n      { internalType: 'uint256', name: 'amountOutMinETH', type: 'uint256' },\n      { internalType: 'uint256', name: 'deadline', type: 'uint256' },\n      { internalType: 'bytes', name: 'signatureData', type: 'bytes' },\n    ],\n    name: 'sendTxWithGas',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'cap1e18', type: 'uint256' }],\n    name: 'setBlockUsdCap',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'minCapUsd', type: 'uint256' },\n      { internalType: 'uint256', name: 'maxCapUsd', type: 'uint256' },\n    ],\n    name: 'setCapsUSD',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'stalePeriodSec', type: 'uint256' },\n    ],\n    name: 'setChainlinkStalePeriod',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: 'deadlineSec', type: 'uint256' }],\n    name: 'setDefaultSwapDeadline',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'feed', type: 'address' }],\n    name: 'setEthUsdFeed',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'feed', type: 'address' }],\n    name: 'setL2SequencerFeed',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'gracePeriodSec', type: 'uint256' },\n    ],\n    name: 'setL2SequencerGracePeriod',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'factory', type: 'address' },\n      { internalType: 'address', name: 'router', type: 'address' },\n    ],\n    name: 'setRouters',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'newTSS', type: 'address' }],\n    name: 'setTSSAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address[]', name: 'tokens', type: 'address[]' },\n      { internalType: 'uint256[]', name: 'thresholds', type: 'uint256[]' },\n    ],\n    name: 'setTokenLimitThresholds',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint24', name: 'a', type: 'uint24' },\n      { internalType: 'uint24', name: 'b', type: 'uint24' },\n      { internalType: 'uint24', name: 'c', type: 'uint24' },\n    ],\n    name: 'setV3FeeOrder',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: '', type: 'address' }],\n    name: 'tokenToLimitThreshold',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'uniV3Factory',\n    outputs: [\n      { internalType: 'contract IUniswapV3Factory', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'uniV3Router',\n    outputs: [\n      {\n        internalType: 'contract ISwapRouterSepolia',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unpause',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'newDurationSec', type: 'uint256' },\n    ],\n    name: 'updateEpochDuration',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address[]', name: 'tokens', type: 'address[]' },\n      { internalType: 'uint256[]', name: 'thresholds', type: 'uint256[]' },\n    ],\n    name: 'updateTokenLimitThreshold',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'usdtUsdPriceFeed',\n    outputs: [\n      {\n        internalType: 'contract AggregatorV3Interface',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    name: 'v3FeeOrder',\n    outputs: [{ internalType: 'uint24', name: '', type: 'uint24' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [{ internalType: 'string', name: '', type: 'string' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'recipient', type: 'address' },\n      { internalType: 'address', name: 'token', type: 'address' },\n      { internalType: 'uint256', name: 'amount', type: 'uint256' },\n    ],\n    name: 'withdrawFunds',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n];\n",
  "packages/core/src/lib/constants/chain.ts": "import { CHAIN, PUSH_NETWORK, VM } from './enums';\nimport {\n  mainnet,\n  sepolia,\n  arbitrumSepolia,\n  baseSepolia,\n  bscTestnet,\n} from 'viem/chains';\n\n/**\n * Maps VM type to its namespace\n * References -\n * https://chainagnostic.org/CAIPs/caip-2\n */\nexport const VM_NAMESPACE: Record<VM, string> = {\n  [VM.EVM]: 'eip155',\n  [VM.SVM]: 'solana',\n};\n\n/**\n * Maps Push Network  VM  UEA implementation address.\n */\nexport const UEA_PROXY: Record<PUSH_NETWORK, `0x${string}`> = {\n  [PUSH_NETWORK.MAINNET]: '0xTBD',\n  [PUSH_NETWORK.TESTNET_DONUT]: '0x53179F638eC4613015EC1aA83e89B48BE6ed6d6d',\n  [PUSH_NETWORK.TESTNET]: '0x53179F638eC4613015EC1aA83e89B48BE6ed6d6d',\n  [PUSH_NETWORK.LOCALNET]: '0x2FE70447492307108Bdc7Ff6BaB33Ff37Dacc479',\n};\n\n/**\n * Addresses for wrapped ETH/SOL/ARBITRUM assets by Push network.\n * Includes pETH and PUSDT bridged from origin on test networks.\n */\nexport const SYNTHETIC_PUSH_ERC20: Record<\n  PUSH_NETWORK,\n  {\n    pETH: `0x${string}`;\n    pETH_ARB: `0x${string}`;\n    pETH_BASE: `0x${string}`;\n    pETH_BNB: `0x${string}`;\n    pSOL: `0x${string}`;\n    USDT_ETH: `0x${string}`;\n    USDC_ETH: `0x${string}`;\n    USDT_ARB: `0x${string}`;\n    USDC_ARB: `0x${string}`;\n    USDT_SOL: `0x${string}`;\n    USDC_SOL: `0x${string}`;\n    USDT_BNB: `0x${string}`;\n    USDT_BASE: `0x${string}`;\n    USDC_BASE: `0x${string}`;\n  }\n> = {\n  [PUSH_NETWORK.TESTNET_DONUT]: {\n    pETH: '0x2971824Db68229D087931155C2b8bB820B275809',\n    pETH_ARB: '0xc0a821a1AfEd1322c5e15f1F4586C0B8cE65400e',\n    pETH_BASE: '0xc7007af2B24D4eb963fc9633B0c66e1d2D90Fc21',\n    pETH_BNB: '0x7a9082dA308f3fa005beA7dB0d203b3b86664E36',\n    pSOL: '0x5D525Df2bD99a6e7ec58b76aF2fd95F39874EBed',\n    USDT_ETH: '0xCA0C5E6F002A389E1580F0DB7cd06e4549B5F9d3',\n    USDC_ETH: '0x387b9C8Db60E74999aAAC5A2b7825b400F12d68E',\n    USDT_ARB: '0x76Ad08339dF606BeEDe06f90e3FaF82c5b2fb2E9',\n    USDC_ARB: '0xa261A10e94aE4bA88EE8c5845CbE7266bD679DD6',\n    USDT_SOL: '0x4f1A3D22d170a2F4Bddb37845a962322e24f4e34',\n    USDC_SOL: '0x04B8F634ABC7C879763F623e0f0550a4b5c4426F',\n    USDT_BNB: '0x2f98B4235FD2BA0173a2B056D722879360B12E7b',\n    USDT_BASE: '0x2C455189D2af6643B924A981a9080CcC63d5a567',\n    USDC_BASE: '0x84B62e44F667F692F7739Ca6040cD17DA02068A8',\n  },\n  [PUSH_NETWORK.TESTNET]: {\n    pETH: '0x2971824Db68229D087931155C2b8bB820B275809',\n    pETH_ARB: '0xc0a821a1AfEd1322c5e15f1F4586C0B8cE65400e',\n    pETH_BASE: '0xc7007af2B24D4eb963fc9633B0c66e1d2D90Fc21',\n    pETH_BNB: '0x7a9082dA308f3fa005beA7dB0d203b3b86664E36',\n    pSOL: '0x5D525Df2bD99a6e7ec58b76aF2fd95F39874EBed',\n    USDT_ETH: '0xCA0C5E6F002A389E1580F0DB7cd06e4549B5F9d3',\n    USDC_ETH: '0x387b9C8Db60E74999aAAC5A2b7825b400F12d68E',\n    USDT_ARB: '0x76Ad08339dF606BeEDe06f90e3FaF82c5b2fb2E9',\n    USDC_ARB: '0xa261A10e94aE4bA88EE8c5845CbE7266bD679DD6',\n    USDT_SOL: '0x4f1A3D22d170a2F4Bddb37845a962322e24f4e34',\n    USDC_SOL: '0x04B8F634ABC7C879763F623e0f0550a4b5c4426F',\n    USDT_BNB: '0x2f98B4235FD2BA0173a2B056D722879360B12E7b',\n    USDT_BASE: '0x2C455189D2af6643B924A981a9080CcC63d5a567',\n    USDC_BASE: '0x84B62e44F667F692F7739Ca6040cD17DA02068A8',\n  },\n  [PUSH_NETWORK.LOCALNET]: {\n    pETH: '0xTBD',\n    pETH_ARB: '0xTBD',\n    pETH_BASE: '0xTBD',\n    pETH_BNB: '0xTBD',\n    pSOL: '0xTBD',\n    USDT_ETH: '0xTBD',\n    USDC_ETH: '0xTBD',\n    USDT_ARB: '0xTBD',\n    USDC_ARB: '0xTBD',\n    USDT_SOL: '0xTBD',\n    USDC_SOL: '0xTBD',\n    USDT_BNB: '0xTBD',\n    USDT_BASE: '0xTBD',\n    USDC_BASE: '0xTBD',\n  },\n  [PUSH_NETWORK.MAINNET]: {\n    pETH: '0xTBD',\n    pETH_ARB: '0xTBD',\n    pETH_BASE: '0xTBD',\n    pETH_BNB: '0xTBD',\n    pSOL: '0xTBD',\n    USDT_ETH: '0xTBD',\n    USDC_ETH: '0xTBD',\n    USDT_ARB: '0xTBD',\n    USDC_ARB: '0xTBD',\n    USDT_SOL: '0xTBD',\n    USDC_SOL: '0xTBD',\n    USDT_BNB: '0xTBD',\n    USDT_BASE: '0xTBD',\n    USDC_BASE: '0xTBD',\n  },\n};\n\n/**\n * Canonical metadata for each chain supported by the SDK.\n * Acts as a single source of truth for chainId, vm type, locker contract, etc.\n * References -\n * https://namespaces.chainagnostic.org/solana/caip2\n */\nexport const CHAIN_INFO: Record<\n  CHAIN,\n  {\n    chainId: string;\n    vm: VM;\n    lockerContract?: string;\n    defaultRPC: string[];\n    confirmations: number; // Confirmations required to mark a tx as finalized\n    timeout: number; // Wait timeout in ms for required confirmations : Ideal value = (confirmations + 1)* Avg Chain Block time\n    dex?: {\n      uniV3Factory?: `0x${string}`;\n      uniV3QuoterV2?: `0x${string}`;\n      weth?: `0x${string}`;\n    };\n  }\n> = {\n  // Push\n  [CHAIN.PUSH_MAINNET]: {\n    chainId: 'TBD',\n    vm: VM.EVM,\n    defaultRPC: [''],\n    confirmations: 6,\n    timeout: 30000,\n  },\n  [CHAIN.PUSH_TESTNET_DONUT]: {\n    chainId: '42101',\n    vm: VM.EVM,\n    defaultRPC: ['https://evm.donut.rpc.push.org/'],\n    confirmations: 3,\n    timeout: 30000,\n    // Push Chain AMM - Uniswap V3\n    dex: {\n      uniV3Factory: '0x81b8Bca02580C7d6b636051FDb7baAC436bFb454',\n      uniV3QuoterV2: '0x83316275f7C2F79BC4E26f089333e88E89093037',\n      weth: '0xE17DD2E0509f99E9ee9469Cf6634048Ec5a3ADe9',\n    },\n  },\n  [CHAIN.PUSH_LOCALNET]: {\n    chainId: '9000',\n    vm: VM.EVM,\n    defaultRPC: ['http://localhost:8545'],\n    confirmations: 3,\n    timeout: 30000,\n  },\n\n  // Ethereum\n  [CHAIN.ETHEREUM_MAINNET]: {\n    chainId: '1',\n    vm: VM.EVM,\n    lockerContract: 'TBD',\n    defaultRPC: [mainnet.rpcUrls.default.http[0]],\n    confirmations: 6,\n    timeout: 60000,\n  },\n  [CHAIN.ETHEREUM_SEPOLIA]: {\n    chainId: '11155111',\n    vm: VM.EVM,\n    lockerContract: '0x05bD7a3D18324c1F7e216f7fBF2b15985aE5281A',\n    defaultRPC: [sepolia.rpcUrls.default.http[0]],\n    confirmations: 2,\n    timeout: 120000,\n    dex: {\n      uniV3Factory: '0x0227628f3F023bb0B980b67D528571c95c6DaC1c',\n      uniV3QuoterV2: '0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3',\n      weth: '0xfff9976782d46cc05630d1f6ebab18b2324d6b14',\n    },\n  },\n  [CHAIN.ARBITRUM_SEPOLIA]: {\n    chainId: '421614',\n    vm: VM.EVM,\n    lockerContract: '0x2cd870e0166Ba458dEC615168Fd659AacD795f34',\n    defaultRPC: [arbitrumSepolia.rpcUrls.default.http[0]],\n    confirmations: 1,\n    timeout: 30000,\n    dex: {\n      uniV3Factory: '0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24',\n      uniV3QuoterV2: '0xTBD',\n      weth: '0x980B62Da83eFf3D4576C647993b0c1D7faf17c73',\n    },\n  },\n  [CHAIN.BASE_SEPOLIA]: {\n    chainId: '84532',\n    vm: VM.EVM,\n    lockerContract: '0xFD4fef1F43aFEc8b5bcdEEc47f35a1431479aC16',\n    defaultRPC: [baseSepolia.rpcUrls.default.http[0]],\n    confirmations: 1,\n    timeout: 30000,\n    dex: {\n      uniV3Factory: '0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24',\n      uniV3QuoterV2: '0xTBD',\n      weth: '0x4200000000000000000000000000000000000006',\n    },\n  },\n  [CHAIN.BNB_TESTNET]: {\n    chainId: '97',\n    vm: VM.EVM,\n    lockerContract: '0x44aFFC61983F4348DdddB886349eb992C061EaC0',\n    defaultRPC: [bscTestnet.rpcUrls.default.http[0]],\n    confirmations: 1,\n    timeout: 30000,\n  },\n\n  // Solana\n  [CHAIN.SOLANA_MAINNET]: {\n    chainId: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\n    vm: VM.SVM,\n    lockerContract: 'TBD',\n    defaultRPC: [''],\n    confirmations: 6,\n    timeout: 15000,\n  },\n  [CHAIN.SOLANA_TESTNET]: {\n    chainId: '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',\n    vm: VM.SVM,\n    lockerContract: '',\n    defaultRPC: ['https://api.testnet.solana.com'],\n    confirmations: 6,\n    timeout: 55000,\n  },\n  [CHAIN.SOLANA_DEVNET]: {\n    chainId: 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1',\n    vm: VM.SVM,\n    lockerContract: 'CFVSincHYbETh2k7w6u1ENEkjbSLtveRCEBupKidw2VS',\n    defaultRPC: ['https://api.devnet.solana.com'],\n    confirmations: 2,\n    timeout: 120000,\n  },\n};\n\n/**\n * Extra required info regarding Push Chain\n */\nexport const PUSH_CHAIN_INFO: Record<\n  CHAIN.PUSH_MAINNET | CHAIN.PUSH_TESTNET_DONUT | CHAIN.PUSH_LOCALNET,\n  (typeof CHAIN_INFO)[CHAIN.PUSH_MAINNET] & {\n    denom: string;\n    tendermintRpc: string;\n    prefix: string;\n    factoryAddress: `0x${string}`;\n    pushDecimals: bigint;\n    usdcDecimals: bigint;\n    pushToUsdcNumerator: bigint;\n    pushToUsdcDenominator: bigint;\n  }\n> = {\n  [CHAIN.PUSH_MAINNET]: {\n    ...CHAIN_INFO[CHAIN.PUSH_MAINNET],\n    denom: 'upc',\n    tendermintRpc: 'TBD',\n    prefix: 'push',\n    factoryAddress: '0xTBD',\n    pushDecimals: BigInt(1e18),\n    usdcDecimals: BigInt(1e8),\n    pushToUsdcNumerator: BigInt(1e7), // 0.1 USDC\n    pushToUsdcDenominator: BigInt(1e18),\n  },\n  [CHAIN.PUSH_TESTNET_DONUT]: {\n    ...CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT],\n    denom: 'upc',\n    tendermintRpc: 'https://donut.rpc.push.org/',\n    prefix: 'push',\n    factoryAddress: '0x00000000000000000000000000000000000000eA',\n    pushDecimals: BigInt(1e18),\n    usdcDecimals: BigInt(1e8),\n    pushToUsdcNumerator: BigInt(1e7), // 0.1 USDC\n    pushToUsdcDenominator: BigInt(1e18),\n  },\n  [CHAIN.PUSH_LOCALNET]: {\n    ...CHAIN_INFO[CHAIN.PUSH_LOCALNET],\n    denom: 'upc',\n    tendermintRpc: 'http://localhost:26657',\n    prefix: 'push',\n    factoryAddress: '0x00000000000000000000000000000000000000eA',\n    pushDecimals: BigInt(1e18),\n    usdcDecimals: BigInt(1e8),\n    pushToUsdcNumerator: BigInt(1e7), // 0.1 USDC\n    pushToUsdcDenominator: BigInt(1e18),\n  },\n};\n",
  "packages/core/src/lib/constants/enums.ts": "/**\n * Specifies the Push Chain environment the SDK will connect to.\n * Determines the RPC endpoints, contract addresses, and network context\n * for interacting with Push Chain.\n */\nexport enum PUSH_NETWORK {\n  MAINNET = 'MAINNET',\n  TESTNET_DONUT = 'TESTNET_DONUT',\n  TESTNET = 'TESTNET',\n  LOCALNET = 'LOCALNET',\n}\n\n/**\n * Supported Chains\n */\nexport enum CHAIN {\n  // Push\n  PUSH_MAINNET = 'eip155:9',\n  PUSH_TESTNET = 'eip155:42101',\n  PUSH_TESTNET_DONUT = PUSH_TESTNET,\n  PUSH_LOCALNET = 'eip155:9001',\n\n  // Ethereum\n  ETHEREUM_MAINNET = 'eip155:1',\n  ETHEREUM_SEPOLIA = 'eip155:11155111',\n  ARBITRUM_SEPOLIA = 'eip155:421614',\n  BASE_SEPOLIA = 'eip155:84532',\n  BNB_TESTNET = 'eip155:97',\n\n  // Solana\n  SOLANA_MAINNET = 'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp',\n  SOLANA_TESTNET = 'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z',\n  SOLANA_DEVNET = 'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1',\n}\n\n/**\n * Represents the virtual machine or execution environment for a chain.\n */\nexport enum VM {\n  EVM = 'EVM',\n  SVM = 'SVM',\n}\n\nexport enum LIBRARY {\n  ETHEREUM_VIEM = 'viem',\n  SOLANA_WEB3JS = 'solana-web3js',\n  ETHEREUM_ETHERSV6 = 'ethers-v6',\n}\n",
  "packages/core/src/lib/constants/index.ts": "import { CHAIN, LIBRARY, PUSH_NETWORK } from './enums';\nimport { TypedDataDomain, TypedData } from '../universal/signer/signer.types';\nexport type { MoveableToken, PayableToken } from './tokens';\n\n// NOTE - Only include enums & constants which need to be exported to end user.\nexport const CONSTANTS = {\n  PUSH_NETWORK,\n  CHAIN,\n  LIBRARY,\n};\n\nexport type { TypedDataDomain, TypedData };\n",
  "packages/core/src/lib/constants/tokens.ts": "import { CHAIN } from './enums';\n\nexport interface MoveableToken {\n  symbol: string;\n  decimals: number;\n  address: string; // chain-native may use a sentinel value\n  // TODO: If true, then we do a ERC-20 approve. If false, then permit2 or similar.\n  // TODO: Rename it to `mechanism`. Then have it as enum: `approve` or `permit2` or `native`\n  // requiresApprove: boolean; // true for ERC20/SPL, false for native tokens\n  mechanism: 'approve' | 'permit2' | 'native';\n}\n\nexport interface PayableToken {\n  symbol: string;\n  decimals: number;\n  address: string;\n  mechanism: 'approve' | 'permit2' | 'native';\n}\n\n// Explicit token symbol maps to enable dot-access (no index signature errors)\nexport type MoveableTokenMap = Partial<{\n  ETH: MoveableToken;\n  SOL: MoveableToken;\n  USDT: MoveableToken;\n  WETH: MoveableToken;\n}>;\n\nexport type PayableTokenMap = Partial<{\n  ETH: PayableToken;\n  USDT: PayableToken;\n  WETH: PayableToken;\n  USDC: PayableToken;\n}>;\n\n// Strongly-typed accessors that throw at runtime if a token is unavailable,\n// while providing non-undefined types at compile time.\nexport class MoveableTokenAccessor {\n  constructor(private readonly tokens: Record<string, MoveableToken>) {}\n\n  private require(name: keyof MoveableTokenMap): MoveableToken {\n    const t = this.tokens[name as string];\n    if (!t)\n      throw new Error(`${String(name)} token not available on this chain`);\n    return t;\n  }\n\n  get ETH(): MoveableToken {\n    return this.require('ETH');\n  }\n  get SOL(): MoveableToken {\n    return this.require('SOL');\n  }\n  get USDT(): MoveableToken {\n    return this.require('USDT');\n  }\n  get WETH(): MoveableToken {\n    return this.require('WETH');\n  }\n}\n\nexport class PayableTokenAccessor {\n  constructor(private readonly tokens: Record<string, PayableToken>) {}\n\n  private require(name: keyof PayableTokenMap): PayableToken {\n    const t = this.tokens[name as string];\n    if (!t)\n      throw new Error(`${String(name)} token not available on this chain`);\n    return t;\n  }\n\n  get ETH(): PayableToken {\n    return this.require('ETH');\n  }\n  get USDT(): PayableToken {\n    return this.require('USDT');\n  }\n  get USDC(): PayableToken {\n    return this.require('USDC');\n  }\n  get WETH(): PayableToken {\n    return this.require('WETH');\n  }\n}\n\nexport interface ConversionQuote {\n  amountIn: string; // smallest units\n  amountOut: string; // smallest units\n  rate: number; // normalized (tokenOut per tokenIn)\n  route?: string[]; // optional: swap path if available\n  timestamp: number; // unix ms\n}\n\n// Native token sentinel addresses\nconst EVM_NATIVE: `0x${string}` = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';\n\n// Centralized token metadata by chain to avoid duplication (symbol, decimals, address, mechanism)\ntype TokenMeta = {\n  symbol: string;\n  decimals: number;\n  address: string;\n  mechanism: 'approve' | 'permit2' | 'native';\n};\n\nconst TOKEN_META: Partial<Record<CHAIN, Record<string, TokenMeta>>> = {\n  // Ethereum Sepolia (testnet)\n  [CHAIN.ETHEREUM_SEPOLIA]: {\n    ETH: {\n      symbol: 'ETH',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: '0x7169D38820dfd117C3FA1f22a697dBA58d90BA06',\n      mechanism: 'approve',\n    },\n    WETH: {\n      symbol: 'WETH',\n      decimals: 18,\n      address: '0xfff9976782d46cc05630d1f6ebab18b2324d6b14',\n      mechanism: 'approve',\n    },\n    USDC: {\n      symbol: 'USDC',\n      decimals: 6,\n      address: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',\n      mechanism: 'approve',\n    },\n  },\n\n  // Ethereum Mainnet\n  [CHAIN.ETHEREUM_MAINNET]: {\n    ETH: {\n      symbol: 'ETH',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',\n      mechanism: 'approve',\n    },\n    WETH: {\n      symbol: 'WETH',\n      decimals: 18,\n      address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n      mechanism: 'approve',\n    },\n  },\n\n  // Arbitrum Sepolia\n  [CHAIN.ARBITRUM_SEPOLIA]: {\n    ETH: {\n      symbol: 'ETH',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: '0x1419d7C74D234fA6B73E06A2ce7822C1d37922f0',\n      mechanism: 'approve',\n    },\n    WETH: {\n      symbol: 'WETH',\n      decimals: 18,\n      address: '0x980B62Da83eFf3D4576C647993b0c1D7faf17c73',\n      mechanism: 'approve',\n    },\n  },\n\n  // Base Sepolia\n  [CHAIN.BASE_SEPOLIA]: {\n    ETH: {\n      symbol: 'ETH',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: '0x9FF5a186f53F6E6964B00320Da1D2024DE11E0cB',\n      mechanism: 'approve',\n    },\n    WETH: {\n      symbol: 'WETH',\n      decimals: 18,\n      address: '0xfff9976782d46cc05630d1f6ebab18b2324d6b14',\n      mechanism: 'approve',\n    },\n  },\n\n  // BNB Testnet\n  [CHAIN.BNB_TESTNET]: {\n    // NOTE: Both symbols are provided to mirror existing usage across maps\n    BNB: {\n      symbol: 'BNB',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    ETH: {\n      symbol: 'ETH',\n      decimals: 18,\n      address: EVM_NATIVE,\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: '0xBC14F348BC9667be46b35Edc9B68653d86013DC5',\n      mechanism: 'approve',\n    },\n  },\n\n  // Solana Devnet\n  [CHAIN.SOLANA_DEVNET]: {\n    SOL: {\n      symbol: 'SOL',\n      decimals: 9,\n      address: 'solana-native',\n      mechanism: 'native',\n    },\n    USDT: {\n      symbol: 'USDT',\n      decimals: 6,\n      address: 'EiXDnrAg9ea2Q6vEPV7E5TpTU1vh41jcuZqKjU5Dc4ZF',\n      mechanism: 'approve',\n    },\n  },\n};\n\nfunction makeToken(chain: CHAIN, symbol: string) {\n  const meta = TOKEN_META[chain]?.[symbol];\n  if (!meta) throw new Error(`Token ${symbol} not available on chain ${chain}`);\n  return {\n    symbol: meta.symbol,\n    decimals: meta.decimals,\n    address: meta.address,\n    mechanism: meta.mechanism,\n  };\n}\n\n// Minimal initial registries. These can be extended safely without breaking the API.\nexport const MOVEABLE_TOKENS: Partial<Record<CHAIN, MoveableToken[]>> = {\n  [CHAIN.ETHEREUM_SEPOLIA]: [\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'USDT'),\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'WETH'),\n  ],\n  [CHAIN.ETHEREUM_MAINNET]: [\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'ETH'),\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'USDT'),\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'WETH'),\n  ],\n  [CHAIN.ARBITRUM_SEPOLIA]: [\n    makeToken(CHAIN.ARBITRUM_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.ARBITRUM_SEPOLIA, 'USDT'),\n    makeToken(CHAIN.ARBITRUM_SEPOLIA, 'WETH'),\n  ],\n  [CHAIN.BASE_SEPOLIA]: [\n    makeToken(CHAIN.BASE_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.BASE_SEPOLIA, 'USDT'),\n    makeToken(CHAIN.BASE_SEPOLIA, 'WETH'),\n  ],\n  [CHAIN.BNB_TESTNET]: [\n    makeToken(CHAIN.BNB_TESTNET, 'ETH'),\n    makeToken(CHAIN.BNB_TESTNET, 'USDT'),\n  ],\n  [CHAIN.SOLANA_DEVNET]: [\n    makeToken(CHAIN.SOLANA_DEVNET, 'SOL'),\n    makeToken(CHAIN.SOLANA_DEVNET, 'USDT'),\n  ],\n};\n\nexport const PAYABLE_TOKENS: Partial<Record<CHAIN, PayableToken[]>> = {\n  [CHAIN.ETHEREUM_SEPOLIA]: [\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'USDT'),\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'USDC'),\n    makeToken(CHAIN.ETHEREUM_SEPOLIA, 'WETH'),\n  ],\n  [CHAIN.ETHEREUM_MAINNET]: [\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'ETH'),\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'USDT'),\n    makeToken(CHAIN.ETHEREUM_MAINNET, 'WETH'),\n  ],\n  [CHAIN.ARBITRUM_SEPOLIA]: [\n    makeToken(CHAIN.ARBITRUM_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.ARBITRUM_SEPOLIA, 'USDT'),\n  ],\n  [CHAIN.BASE_SEPOLIA]: [\n    makeToken(CHAIN.BASE_SEPOLIA, 'ETH'),\n    makeToken(CHAIN.BASE_SEPOLIA, 'USDT'),\n  ],\n  [CHAIN.BNB_TESTNET]: [\n    makeToken(CHAIN.BNB_TESTNET, 'BNB'),\n    makeToken(CHAIN.BNB_TESTNET, 'USDT'),\n  ],\n  [CHAIN.SOLANA_DEVNET]: [\n    makeToken(CHAIN.SOLANA_DEVNET, 'SOL'),\n    makeToken(CHAIN.SOLANA_DEVNET, 'USDT'),\n  ],\n};\n",
  "packages/core/src/lib/generated/uexecutor/v1/query.ts": "// Minimal generated types for uexecutor.v1 Query service\n// Hand-authored to avoid requiring protoc at build time in this repo\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';\nimport type { UniversalTx as UniversalTxMsg } from './types';\nimport { UniversalTx as UniversalTxCodec } from './types';\n\nexport const protobufPackage = 'uexecutor.v1';\n\nexport interface QueryGetUniversalTxRequest {\n  id: string;\n}\n\nexport interface QueryGetUniversalTxResponse {\n  universalTx?: UniversalTxMsg | undefined;\n}\n\nfunction createBaseQueryGetUniversalTxRequest(): QueryGetUniversalTxRequest {\n  return { id: '' };\n}\n\nexport const QueryGetUniversalTxRequest = {\n  encode(\n    message: QueryGetUniversalTxRequest,\n    writer: BinaryWriter = new BinaryWriter()\n  ): BinaryWriter {\n    if (message.id !== '') writer.uint32(10).string(message.id);\n    return writer;\n  },\n  decode(\n    input: BinaryReader | Uint8Array,\n    length?: number\n  ): QueryGetUniversalTxRequest {\n    const reader =\n      input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseQueryGetUniversalTxRequest();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        default:\n          if ((tag & 7) === 4 || tag === 0) {\n            return message;\n          }\n          reader.skip(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial(object: { id?: string }): QueryGetUniversalTxRequest {\n    return { id: object.id ?? '' };\n  },\n};\n\nfunction createBaseQueryGetUniversalTxResponse(): QueryGetUniversalTxResponse {\n  return { universalTx: undefined };\n}\n\nexport const QueryGetUniversalTxResponse = {\n  encode(\n    message: QueryGetUniversalTxResponse,\n    writer: BinaryWriter = new BinaryWriter()\n  ): BinaryWriter {\n    if (message.universalTx !== undefined) {\n      UniversalTxCodec.encode(\n        message.universalTx,\n        writer.uint32(10).fork()\n      ).join();\n    }\n    return writer;\n  },\n  decode(\n    input: BinaryReader | Uint8Array,\n    length?: number\n  ): QueryGetUniversalTxResponse {\n    const reader =\n      input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseQueryGetUniversalTxResponse();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.universalTx = UniversalTxCodec.decode(\n            reader,\n            reader.uint32()\n          );\n          break;\n        default:\n          if ((tag & 7) === 4 || tag === 0) {\n            return message;\n          }\n          reader.skip(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromPartial(object: {\n    universalTx?: UniversalTxMsg;\n  }): QueryGetUniversalTxResponse {\n    return { universalTx: object.universalTx ?? undefined };\n  },\n};\n",
  "packages/core/src/lib/generated/uexecutor/v1/types.ts": "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.0\n//   protoc               v5.29.3\n// source: uexecutor/v1/types.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"uexecutor.v1\";\n\nexport enum VerificationType {\n  signedVerification = 0,\n  universalTxVerification = 1,\n  UNRECOGNIZED = -1,\n}\n\nexport function verificationTypeFromJSON(object: any): VerificationType {\n  switch (object) {\n    case 0:\n    case \"signedVerification\":\n      return VerificationType.signedVerification;\n    case 1:\n    case \"universalTxVerification\":\n      return VerificationType.universalTxVerification;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VerificationType.UNRECOGNIZED;\n  }\n}\n\nexport function verificationTypeToJSON(object: VerificationType): string {\n  switch (object) {\n    case VerificationType.signedVerification:\n      return \"signedVerification\";\n    case VerificationType.universalTxVerification:\n      return \"universalTxVerification\";\n    case VerificationType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\nexport enum UniversalTxStatus {\n  UNIVERSAL_TX_STATUS_UNSPECIFIED = 0,\n  INBOUND_SUCCESS = 1,\n  PENDING_INBOUND_EXECUTION = 2,\n  PC_EXECUTED_SUCCESS = 3,\n  PC_EXECUTED_FAILED = 4,\n  PC_PENDING_REVERT = 5,\n  OUTBOUND_PENDING = 6,\n  OUTBOUND_SUCCESS = 7,\n  OUTBOUND_FAILED = 8,\n  CANCELED = 9,\n  UNRECOGNIZED = -1,\n}\n\nexport function universalTxStatusFromJSON(object: any): UniversalTxStatus {\n  switch (object) {\n    case 0:\n    case \"UNIVERSAL_TX_STATUS_UNSPECIFIED\":\n      return UniversalTxStatus.UNIVERSAL_TX_STATUS_UNSPECIFIED;\n    case 1:\n    case \"INBOUND_SUCCESS\":\n      return UniversalTxStatus.INBOUND_SUCCESS;\n    case 2:\n    case \"PENDING_INBOUND_EXECUTION\":\n      return UniversalTxStatus.PENDING_INBOUND_EXECUTION;\n    case 3:\n    case \"PC_EXECUTED_SUCCESS\":\n      return UniversalTxStatus.PC_EXECUTED_SUCCESS;\n    case 4:\n    case \"PC_EXECUTED_FAILED\":\n      return UniversalTxStatus.PC_EXECUTED_FAILED;\n    case 5:\n    case \"PC_PENDING_REVERT\":\n      return UniversalTxStatus.PC_PENDING_REVERT;\n    case 6:\n    case \"OUTBOUND_PENDING\":\n      return UniversalTxStatus.OUTBOUND_PENDING;\n    case 7:\n    case \"OUTBOUND_SUCCESS\":\n      return UniversalTxStatus.OUTBOUND_SUCCESS;\n    case 8:\n    case \"OUTBOUND_FAILED\":\n      return UniversalTxStatus.OUTBOUND_FAILED;\n    case 9:\n    case \"CANCELED\":\n      return UniversalTxStatus.CANCELED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return UniversalTxStatus.UNRECOGNIZED;\n  }\n}\n\nexport function universalTxStatusToJSON(object: UniversalTxStatus): string {\n  switch (object) {\n    case UniversalTxStatus.UNIVERSAL_TX_STATUS_UNSPECIFIED:\n      return \"UNIVERSAL_TX_STATUS_UNSPECIFIED\";\n    case UniversalTxStatus.INBOUND_SUCCESS:\n      return \"INBOUND_SUCCESS\";\n    case UniversalTxStatus.PENDING_INBOUND_EXECUTION:\n      return \"PENDING_INBOUND_EXECUTION\";\n    case UniversalTxStatus.PC_EXECUTED_SUCCESS:\n      return \"PC_EXECUTED_SUCCESS\";\n    case UniversalTxStatus.PC_EXECUTED_FAILED:\n      return \"PC_EXECUTED_FAILED\";\n    case UniversalTxStatus.PC_PENDING_REVERT:\n      return \"PC_PENDING_REVERT\";\n    case UniversalTxStatus.OUTBOUND_PENDING:\n      return \"OUTBOUND_PENDING\";\n    case UniversalTxStatus.OUTBOUND_SUCCESS:\n      return \"OUTBOUND_SUCCESS\";\n    case UniversalTxStatus.OUTBOUND_FAILED:\n      return \"OUTBOUND_FAILED\";\n    case UniversalTxStatus.CANCELED:\n      return \"CANCELED\";\n    case UniversalTxStatus.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\nexport interface UniversalPayload {\n  to: string;\n  value: string;\n  data: string;\n  gasLimit: string;\n  maxFeePerGas: string;\n  maxPriorityFeePerGas: string;\n  nonce: string;\n  deadline: string;\n  vType: VerificationType;\n}\n\nexport interface Inbound {\n  sourceChain: string;\n  txHash: string;\n  sender: string;\n  recipient: string;\n  amount: string;\n  assetAddr: string;\n  txType: number;\n  universalPayload?: UniversalPayload | undefined;\n  verificationData: string;\n}\n\nexport interface PCTx {\n  txHash: string;\n  sender: string;\n  gasUsed: number;\n  blockHeight: number;\n  status: string;\n  errorMsg: string;\n}\n\nexport interface OutboundTx {\n  destinationChain: string;\n  txHash: string;\n  recipient: string;\n  amount: string;\n  assetAddr: string;\n}\n\nexport interface UniversalTx {\n  inboundTx?: Inbound | undefined;\n  pcTx: PCTx[];\n  outboundTx?: OutboundTx | undefined;\n  universalStatus: UniversalTxStatus;\n}\n\nfunction createBaseUniversalPayload(): UniversalPayload {\n  return {\n    to: \"\",\n    value: \"\",\n    data: \"\",\n    gasLimit: \"\",\n    maxFeePerGas: \"\",\n    maxPriorityFeePerGas: \"\",\n    nonce: \"\",\n    deadline: \"\",\n    vType: 0,\n  };\n}\n\nexport const UniversalPayload: MessageFns<UniversalPayload> = {\n  encode(message: UniversalPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.to !== \"\") {\n      writer.uint32(10).string(message.to);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    if (message.data !== \"\") {\n      writer.uint32(26).string(message.data);\n    }\n    if (message.gasLimit !== \"\") {\n      writer.uint32(34).string(message.gasLimit);\n    }\n    if (message.maxFeePerGas !== \"\") {\n      writer.uint32(42).string(message.maxFeePerGas);\n    }\n    if (message.maxPriorityFeePerGas !== \"\") {\n      writer.uint32(50).string(message.maxPriorityFeePerGas);\n    }\n    if (message.nonce !== \"\") {\n      writer.uint32(58).string(message.nonce);\n    }\n    if (message.deadline !== \"\") {\n      writer.uint32(66).string(message.deadline);\n    }\n    if (message.vType !== 0) {\n      writer.uint32(72).int32(message.vType);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): UniversalPayload {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUniversalPayload();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.to = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.value = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.data = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.gasLimit = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.maxFeePerGas = reader.string();\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.maxPriorityFeePerGas = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.nonce = reader.string();\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.deadline = reader.string();\n          continue;\n        }\n        case 9: {\n          if (tag !== 72) {\n            break;\n          }\n\n          message.vType = reader.int32() as any;\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UniversalPayload {\n    return {\n      to: isSet(object.to) ? globalThis.String(object.to) : \"\",\n      value: isSet(object.value) ? globalThis.String(object.value) : \"\",\n      data: isSet(object.data) ? globalThis.String(object.data) : \"\",\n      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : \"\",\n      maxFeePerGas: isSet(object.maxFeePerGas) ? globalThis.String(object.maxFeePerGas) : \"\",\n      maxPriorityFeePerGas: isSet(object.maxPriorityFeePerGas) ? globalThis.String(object.maxPriorityFeePerGas) : \"\",\n      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : \"\",\n      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : \"\",\n      vType: isSet(object.vType) ? verificationTypeFromJSON(object.vType) : 0,\n    };\n  },\n\n  toJSON(message: UniversalPayload): unknown {\n    const obj: any = {};\n    if (message.to !== \"\") {\n      obj.to = message.to;\n    }\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    if (message.data !== \"\") {\n      obj.data = message.data;\n    }\n    if (message.gasLimit !== \"\") {\n      obj.gasLimit = message.gasLimit;\n    }\n    if (message.maxFeePerGas !== \"\") {\n      obj.maxFeePerGas = message.maxFeePerGas;\n    }\n    if (message.maxPriorityFeePerGas !== \"\") {\n      obj.maxPriorityFeePerGas = message.maxPriorityFeePerGas;\n    }\n    if (message.nonce !== \"\") {\n      obj.nonce = message.nonce;\n    }\n    if (message.deadline !== \"\") {\n      obj.deadline = message.deadline;\n    }\n    if (message.vType !== 0) {\n      obj.vType = verificationTypeToJSON(message.vType);\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<UniversalPayload>, I>>(base?: I): UniversalPayload {\n    return UniversalPayload.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<UniversalPayload>, I>>(object: I): UniversalPayload {\n    const message = createBaseUniversalPayload();\n    message.to = object.to ?? \"\";\n    message.value = object.value ?? \"\";\n    message.data = object.data ?? \"\";\n    message.gasLimit = object.gasLimit ?? \"\";\n    message.maxFeePerGas = object.maxFeePerGas ?? \"\";\n    message.maxPriorityFeePerGas = object.maxPriorityFeePerGas ?? \"\";\n    message.nonce = object.nonce ?? \"\";\n    message.deadline = object.deadline ?? \"\";\n    message.vType = object.vType ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseInbound(): Inbound {\n  return {\n    sourceChain: \"\",\n    txHash: \"\",\n    sender: \"\",\n    recipient: \"\",\n    amount: \"\",\n    assetAddr: \"\",\n    txType: 0,\n    universalPayload: undefined,\n    verificationData: \"\",\n  };\n}\n\nexport const Inbound: MessageFns<Inbound> = {\n  encode(message: Inbound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.sourceChain !== \"\") {\n      writer.uint32(10).string(message.sourceChain);\n    }\n    if (message.txHash !== \"\") {\n      writer.uint32(18).string(message.txHash);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(26).string(message.sender);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(34).string(message.recipient);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(42).string(message.amount);\n    }\n    if (message.assetAddr !== \"\") {\n      writer.uint32(50).string(message.assetAddr);\n    }\n    if (message.txType !== 0) {\n      writer.uint32(56).int32(message.txType);\n    }\n    if (message.universalPayload !== undefined) {\n      UniversalPayload.encode(message.universalPayload, writer.uint32(66).fork()).join();\n    }\n    if (message.verificationData !== \"\") {\n      writer.uint32(74).string(message.verificationData);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Inbound {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseInbound();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.sourceChain = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.txHash = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.sender = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.recipient = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.amount = reader.string();\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.assetAddr = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 56) {\n            break;\n          }\n\n          message.txType = reader.int32();\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.universalPayload = UniversalPayload.decode(reader, reader.uint32());\n          continue;\n        }\n        case 9: {\n          if (tag !== 74) {\n            break;\n          }\n\n          message.verificationData = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Inbound {\n    return {\n      sourceChain: isSet(object.sourceChain) ? globalThis.String(object.sourceChain) : \"\",\n      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : \"\",\n      sender: isSet(object.sender) ? globalThis.String(object.sender) : \"\",\n      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : \"\",\n      amount: isSet(object.amount) ? globalThis.String(object.amount) : \"\",\n      assetAddr: isSet(object.assetAddr) ? globalThis.String(object.assetAddr) : \"\",\n      txType: isSet(object.txType) ? globalThis.Number(object.txType) : 0,\n      universalPayload: isSet(object.universalPayload) ? UniversalPayload.fromJSON(object.universalPayload) : undefined,\n      verificationData: isSet(object.verificationData) ? globalThis.String(object.verificationData) : \"\",\n    };\n  },\n\n  toJSON(message: Inbound): unknown {\n    const obj: any = {};\n    if (message.sourceChain !== \"\") {\n      obj.sourceChain = message.sourceChain;\n    }\n    if (message.txHash !== \"\") {\n      obj.txHash = message.txHash;\n    }\n    if (message.sender !== \"\") {\n      obj.sender = message.sender;\n    }\n    if (message.recipient !== \"\") {\n      obj.recipient = message.recipient;\n    }\n    if (message.amount !== \"\") {\n      obj.amount = message.amount;\n    }\n    if (message.assetAddr !== \"\") {\n      obj.assetAddr = message.assetAddr;\n    }\n    if (message.txType !== 0) {\n      obj.txType = Math.round(message.txType);\n    }\n    if (message.universalPayload !== undefined) {\n      obj.universalPayload = UniversalPayload.toJSON(message.universalPayload);\n    }\n    if (message.verificationData !== \"\") {\n      obj.verificationData = message.verificationData;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Inbound>, I>>(base?: I): Inbound {\n    return Inbound.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Inbound>, I>>(object: I): Inbound {\n    const message = createBaseInbound();\n    message.sourceChain = object.sourceChain ?? \"\";\n    message.txHash = object.txHash ?? \"\";\n    message.sender = object.sender ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount = object.amount ?? \"\";\n    message.assetAddr = object.assetAddr ?? \"\";\n    message.txType = object.txType ?? 0;\n    message.universalPayload = (object.universalPayload !== undefined && object.universalPayload !== null)\n      ? UniversalPayload.fromPartial(object.universalPayload)\n      : undefined;\n    message.verificationData = object.verificationData ?? \"\";\n    return message;\n  },\n};\n\nfunction createBasePCTx(): PCTx {\n  return { txHash: \"\", sender: \"\", gasUsed: 0, blockHeight: 0, status: \"\", errorMsg: \"\" };\n}\n\nexport const PCTx: MessageFns<PCTx> = {\n  encode(message: PCTx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.txHash !== \"\") {\n      writer.uint32(10).string(message.txHash);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(18).string(message.sender);\n    }\n    if (message.gasUsed !== 0) {\n      writer.uint32(24).uint64(message.gasUsed);\n    }\n    if (message.blockHeight !== 0) {\n      writer.uint32(32).uint64(message.blockHeight);\n    }\n    if (message.status !== \"\") {\n      writer.uint32(50).string(message.status);\n    }\n    if (message.errorMsg !== \"\") {\n      writer.uint32(58).string(message.errorMsg);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): PCTx {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBasePCTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.txHash = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.sender = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 24) {\n            break;\n          }\n\n          message.gasUsed = longToNumber(reader.uint64());\n          continue;\n        }\n        case 4: {\n          if (tag !== 32) {\n            break;\n          }\n\n          message.blockHeight = longToNumber(reader.uint64());\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.status = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.errorMsg = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): PCTx {\n    return {\n      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : \"\",\n      sender: isSet(object.sender) ? globalThis.String(object.sender) : \"\",\n      gasUsed: isSet(object.gasUsed) ? globalThis.Number(object.gasUsed) : 0,\n      blockHeight: isSet(object.blockHeight) ? globalThis.Number(object.blockHeight) : 0,\n      status: isSet(object.status) ? globalThis.String(object.status) : \"\",\n      errorMsg: isSet(object.errorMsg) ? globalThis.String(object.errorMsg) : \"\",\n    };\n  },\n\n  toJSON(message: PCTx): unknown {\n    const obj: any = {};\n    if (message.txHash !== \"\") {\n      obj.txHash = message.txHash;\n    }\n    if (message.sender !== \"\") {\n      obj.sender = message.sender;\n    }\n    if (message.gasUsed !== 0) {\n      obj.gasUsed = Math.round(message.gasUsed);\n    }\n    if (message.blockHeight !== 0) {\n      obj.blockHeight = Math.round(message.blockHeight);\n    }\n    if (message.status !== \"\") {\n      obj.status = message.status;\n    }\n    if (message.errorMsg !== \"\") {\n      obj.errorMsg = message.errorMsg;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<PCTx>, I>>(base?: I): PCTx {\n    return PCTx.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<PCTx>, I>>(object: I): PCTx {\n    const message = createBasePCTx();\n    message.txHash = object.txHash ?? \"\";\n    message.sender = object.sender ?? \"\";\n    message.gasUsed = object.gasUsed ?? 0;\n    message.blockHeight = object.blockHeight ?? 0;\n    message.status = object.status ?? \"\";\n    message.errorMsg = object.errorMsg ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseOutboundTx(): OutboundTx {\n  return { destinationChain: \"\", txHash: \"\", recipient: \"\", amount: \"\", assetAddr: \"\" };\n}\n\nexport const OutboundTx: MessageFns<OutboundTx> = {\n  encode(message: OutboundTx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.destinationChain !== \"\") {\n      writer.uint32(10).string(message.destinationChain);\n    }\n    if (message.txHash !== \"\") {\n      writer.uint32(18).string(message.txHash);\n    }\n    if (message.recipient !== \"\") {\n      writer.uint32(26).string(message.recipient);\n    }\n    if (message.amount !== \"\") {\n      writer.uint32(34).string(message.amount);\n    }\n    if (message.assetAddr !== \"\") {\n      writer.uint32(42).string(message.assetAddr);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): OutboundTx {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseOutboundTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.destinationChain = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.txHash = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.recipient = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.amount = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.assetAddr = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): OutboundTx {\n    return {\n      destinationChain: isSet(object.destinationChain) ? globalThis.String(object.destinationChain) : \"\",\n      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : \"\",\n      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : \"\",\n      amount: isSet(object.amount) ? globalThis.String(object.amount) : \"\",\n      assetAddr: isSet(object.assetAddr) ? globalThis.String(object.assetAddr) : \"\",\n    };\n  },\n\n  toJSON(message: OutboundTx): unknown {\n    const obj: any = {};\n    if (message.destinationChain !== \"\") {\n      obj.destinationChain = message.destinationChain;\n    }\n    if (message.txHash !== \"\") {\n      obj.txHash = message.txHash;\n    }\n    if (message.recipient !== \"\") {\n      obj.recipient = message.recipient;\n    }\n    if (message.amount !== \"\") {\n      obj.amount = message.amount;\n    }\n    if (message.assetAddr !== \"\") {\n      obj.assetAddr = message.assetAddr;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<OutboundTx>, I>>(base?: I): OutboundTx {\n    return OutboundTx.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<OutboundTx>, I>>(object: I): OutboundTx {\n    const message = createBaseOutboundTx();\n    message.destinationChain = object.destinationChain ?? \"\";\n    message.txHash = object.txHash ?? \"\";\n    message.recipient = object.recipient ?? \"\";\n    message.amount = object.amount ?? \"\";\n    message.assetAddr = object.assetAddr ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseUniversalTx(): UniversalTx {\n  return { inboundTx: undefined, pcTx: [], outboundTx: undefined, universalStatus: 0 };\n}\n\nexport const UniversalTx: MessageFns<UniversalTx> = {\n  encode(message: UniversalTx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.inboundTx !== undefined) {\n      Inbound.encode(message.inboundTx, writer.uint32(10).fork()).join();\n    }\n    for (const v of message.pcTx) {\n      PCTx.encode(v!, writer.uint32(18).fork()).join();\n    }\n    if (message.outboundTx !== undefined) {\n      OutboundTx.encode(message.outboundTx, writer.uint32(26).fork()).join();\n    }\n    if (message.universalStatus !== 0) {\n      writer.uint32(32).int32(message.universalStatus);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): UniversalTx {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUniversalTx();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.inboundTx = Inbound.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.pcTx.push(PCTx.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.outboundTx = OutboundTx.decode(reader, reader.uint32());\n          continue;\n        }\n        case 4: {\n          if (tag !== 32) {\n            break;\n          }\n\n          message.universalStatus = reader.int32() as any;\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UniversalTx {\n    return {\n      inboundTx: isSet(object.inboundTx) ? Inbound.fromJSON(object.inboundTx) : undefined,\n      pcTx: globalThis.Array.isArray(object?.pcTx) ? object.pcTx.map((e: any) => PCTx.fromJSON(e)) : [],\n      outboundTx: isSet(object.outboundTx) ? OutboundTx.fromJSON(object.outboundTx) : undefined,\n      universalStatus: isSet(object.universalStatus) ? universalTxStatusFromJSON(object.universalStatus) : 0,\n    };\n  },\n\n  toJSON(message: UniversalTx): unknown {\n    const obj: any = {};\n    if (message.inboundTx !== undefined) {\n      obj.inboundTx = Inbound.toJSON(message.inboundTx);\n    }\n    if (message.pcTx?.length) {\n      obj.pcTx = message.pcTx.map((e) => PCTx.toJSON(e));\n    }\n    if (message.outboundTx !== undefined) {\n      obj.outboundTx = OutboundTx.toJSON(message.outboundTx);\n    }\n    if (message.universalStatus !== 0) {\n      obj.universalStatus = universalTxStatusToJSON(message.universalStatus);\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<UniversalTx>, I>>(base?: I): UniversalTx {\n    return UniversalTx.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<UniversalTx>, I>>(object: I): UniversalTx {\n    const message = createBaseUniversalTx();\n    message.inboundTx = (object.inboundTx !== undefined && object.inboundTx !== null)\n      ? Inbound.fromPartial(object.inboundTx)\n      : undefined;\n    message.pcTx = object.pcTx?.map((e) => PCTx.fromPartial(e)) || [];\n    message.outboundTx = (object.outboundTx !== undefined && object.outboundTx !== null)\n      ? OutboundTx.fromPartial(object.outboundTx)\n      : undefined;\n    message.universalStatus = object.universalStatus ?? 0;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction longToNumber(int64: { toString(): string }): number {\n  const num = globalThis.Number(int64.toString());\n  if (num > globalThis.Number.MAX_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (num < globalThis.Number.MIN_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return num;\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n",
  "packages/core/src/lib/generated/v1/tx.ts": "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.0\n//   protoc               v5.29.3\n// source: v1/tx.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"ue.v1\";\n\n/** Signature verification types */\nexport enum VerificationType {\n  // Old, now we are using the universalTxVerification instead, so we pass the signedPayload as `0x` instead when using the universalTxVerification.\n  /** signedVerification - Signed verification using a signature */ // eip712 signature\n  signedVerification = 0,\n  /** universalTxVerification - Universal transaction verification */\n  universalTxVerification = 1,\n  UNRECOGNIZED = -1,\n}\n\nexport function verificationTypeFromJSON(object: any): VerificationType {\n  switch (object) {\n    case 0:\n    case \"signedVerification\":\n      return VerificationType.signedVerification;\n    case 1:\n    case \"universalTxVerification\":\n      return VerificationType.universalTxVerification;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return VerificationType.UNRECOGNIZED;\n  }\n}\n\nexport function verificationTypeToJSON(object: VerificationType): string {\n  switch (object) {\n    case VerificationType.signedVerification:\n      return \"signedVerification\";\n    case VerificationType.universalTxVerification:\n      return \"universalTxVerification\";\n    case VerificationType.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/** UniversalAccount is the identifier of a owner account */\nexport interface UniversalAccountId {\n  /** chain_namespace is the CAIP-2 namespace of the chain where the owner is located (e.g. \"eip155\" for Ethereum) */\n  chainNamespace: string;\n  /** chain_id is the chain ID of the chain where the owner is located */\n  chainId: string;\n  /** Owner's public key bytes or address in hex format */\n  owner: string;\n}\n\n/** MsgDeployUEA is the message used to deploy a new smart account. */\nexport interface MsgDeployUEA {\n  /** signer is the Cosmos address initiating the tx (used for tx signing) */\n  signer: string;\n  /** universal_account is the identifier of the owner account */\n  universalAccountId?:\n    | UniversalAccountId\n    | undefined;\n  /** tx_hash is the hash of the transaction in which user locked the tokens */\n  txHash: string;\n}\n\n/**\n * MsgMintPC represents a message to mint PUSH tokens to a smart account,\n * based on the amount locked by the user in the gateway contract.\n */\nexport interface MsgMintPC {\n  /** signer is the Cosmos address initiating the tx (used for tx signing) */\n  signer: string;\n  /** universal_account is the identifier of the owner account */\n  universalAccountId?:\n    | UniversalAccountId\n    | undefined;\n  /** tx_hash is the hash of the transaction in which user locked the tokens */\n  txHash: string;\n}\n\n/** UniversalPayload mirrors the Solidity struct */\nexport interface UniversalPayload {\n  /** EVM address as hex string (0x...) */\n  to: string;\n  /** Amount in upc as string (uint256) */\n  value: string;\n  /** ABI-encoded calldata */\n  data: string;\n  /** uint256 as string */\n  gasLimit: string;\n  /** uint256 as string */\n  maxFeePerGas: string;\n  /** uint256 as string */\n  maxPriorityFeePerGas: string;\n  /** uint256 as string */\n  nonce: string;\n  /** uint256 as string */\n  deadline: string;\n  /** Type of signature verification */\n  vType: VerificationType;\n}\n\n/** MsgExecutePayload defines a message for executing a universal payload */\nexport interface MsgExecutePayload {\n  /** signer is the Cosmos address initiating the tx (used for tx signing) */\n  signer: string;\n  /** universal_account is the identifier of the owner account */\n  universalAccountId?:\n    | UniversalAccountId\n    | undefined;\n  /** payload is the universal payload to be executed */\n  universalPayload?:\n    | UniversalPayload\n    | undefined;\n  /** signature is the signature of the payload by user */\n  verificationData: string;\n}\n\nfunction createBaseUniversalAccountId(): UniversalAccountId {\n  return { chainNamespace: \"\", chainId: \"\", owner: \"\" };\n}\n\nexport const UniversalAccountId: MessageFns<UniversalAccountId> = {\n  encode(message: UniversalAccountId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.chainNamespace !== \"\") {\n      writer.uint32(10).string(message.chainNamespace);\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (message.owner !== \"\") {\n      writer.uint32(26).string(message.owner);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): UniversalAccountId {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUniversalAccountId();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.chainNamespace = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.chainId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.owner = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UniversalAccountId {\n    return {\n      chainNamespace: isSet(object.chainNamespace) ? globalThis.String(object.chainNamespace) : \"\",\n      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : \"\",\n      owner: isSet(object.owner) ? globalThis.String(object.owner) : \"\",\n    };\n  },\n\n  toJSON(message: UniversalAccountId): unknown {\n    const obj: any = {};\n    if (message.chainNamespace !== \"\") {\n      obj.chainNamespace = message.chainNamespace;\n    }\n    if (message.chainId !== \"\") {\n      obj.chainId = message.chainId;\n    }\n    if (message.owner !== \"\") {\n      obj.owner = message.owner;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<UniversalAccountId>, I>>(base?: I): UniversalAccountId {\n    return UniversalAccountId.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<UniversalAccountId>, I>>(object: I): UniversalAccountId {\n    const message = createBaseUniversalAccountId();\n    message.chainNamespace = object.chainNamespace ?? \"\";\n    message.chainId = object.chainId ?? \"\";\n    message.owner = object.owner ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgDeployUEA(): MsgDeployUEA {\n  return { signer: \"\", universalAccountId: undefined, txHash: \"\" };\n}\n\nexport const MsgDeployUEA: MessageFns<MsgDeployUEA> = {\n  encode(message: MsgDeployUEA, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.signer !== \"\") {\n      writer.uint32(10).string(message.signer);\n    }\n    if (message.universalAccountId !== undefined) {\n      UniversalAccountId.encode(message.universalAccountId, writer.uint32(18).fork()).join();\n    }\n    if (message.txHash !== \"\") {\n      writer.uint32(26).string(message.txHash);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeployUEA {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgDeployUEA();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.signer = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.universalAccountId = UniversalAccountId.decode(reader, reader.uint32());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.txHash = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgDeployUEA {\n    return {\n      signer: isSet(object.signer) ? globalThis.String(object.signer) : \"\",\n      universalAccountId: isSet(object.universalAccountId)\n        ? UniversalAccountId.fromJSON(object.universalAccountId)\n        : undefined,\n      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : \"\",\n    };\n  },\n\n  toJSON(message: MsgDeployUEA): unknown {\n    const obj: any = {};\n    if (message.signer !== \"\") {\n      obj.signer = message.signer;\n    }\n    if (message.universalAccountId !== undefined) {\n      obj.universalAccountId = UniversalAccountId.toJSON(message.universalAccountId);\n    }\n    if (message.txHash !== \"\") {\n      obj.txHash = message.txHash;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<MsgDeployUEA>, I>>(base?: I): MsgDeployUEA {\n    return MsgDeployUEA.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<MsgDeployUEA>, I>>(object: I): MsgDeployUEA {\n    const message = createBaseMsgDeployUEA();\n    message.signer = object.signer ?? \"\";\n    message.universalAccountId = (object.universalAccountId !== undefined && object.universalAccountId !== null)\n      ? UniversalAccountId.fromPartial(object.universalAccountId)\n      : undefined;\n    message.txHash = object.txHash ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMsgMintPC(): MsgMintPC {\n  return { signer: \"\", universalAccountId: undefined, txHash: \"\" };\n}\n\nexport const MsgMintPC: MessageFns<MsgMintPC> = {\n  encode(message: MsgMintPC, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.signer !== \"\") {\n      writer.uint32(10).string(message.signer);\n    }\n    if (message.universalAccountId !== undefined) {\n      UniversalAccountId.encode(message.universalAccountId, writer.uint32(18).fork()).join();\n    }\n    if (message.txHash !== \"\") {\n      writer.uint32(26).string(message.txHash);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintPC {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgMintPC();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.signer = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.universalAccountId = UniversalAccountId.decode(reader, reader.uint32());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.txHash = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgMintPC {\n    return {\n      signer: isSet(object.signer) ? globalThis.String(object.signer) : \"\",\n      universalAccountId: isSet(object.universalAccountId)\n        ? UniversalAccountId.fromJSON(object.universalAccountId)\n        : undefined,\n      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : \"\",\n    };\n  },\n\n  toJSON(message: MsgMintPC): unknown {\n    const obj: any = {};\n    if (message.signer !== \"\") {\n      obj.signer = message.signer;\n    }\n    if (message.universalAccountId !== undefined) {\n      obj.universalAccountId = UniversalAccountId.toJSON(message.universalAccountId);\n    }\n    if (message.txHash !== \"\") {\n      obj.txHash = message.txHash;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<MsgMintPC>, I>>(base?: I): MsgMintPC {\n    return MsgMintPC.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<MsgMintPC>, I>>(object: I): MsgMintPC {\n    const message = createBaseMsgMintPC();\n    message.signer = object.signer ?? \"\";\n    message.universalAccountId = (object.universalAccountId !== undefined && object.universalAccountId !== null)\n      ? UniversalAccountId.fromPartial(object.universalAccountId)\n      : undefined;\n    message.txHash = object.txHash ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseUniversalPayload(): UniversalPayload {\n  return {\n    to: \"\",\n    value: \"\",\n    data: \"\",\n    gasLimit: \"\",\n    maxFeePerGas: \"\",\n    maxPriorityFeePerGas: \"\",\n    nonce: \"\",\n    deadline: \"\",\n    vType: 0,\n  };\n}\n\nexport const UniversalPayload: MessageFns<UniversalPayload> = {\n  encode(message: UniversalPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.to !== \"\") {\n      writer.uint32(10).string(message.to);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    if (message.data !== \"\") {\n      writer.uint32(26).string(message.data);\n    }\n    if (message.gasLimit !== \"\") {\n      writer.uint32(34).string(message.gasLimit);\n    }\n    if (message.maxFeePerGas !== \"\") {\n      writer.uint32(42).string(message.maxFeePerGas);\n    }\n    if (message.maxPriorityFeePerGas !== \"\") {\n      writer.uint32(50).string(message.maxPriorityFeePerGas);\n    }\n    if (message.nonce !== \"\") {\n      writer.uint32(58).string(message.nonce);\n    }\n    if (message.deadline !== \"\") {\n      writer.uint32(66).string(message.deadline);\n    }\n    if (message.vType !== 0) {\n      writer.uint32(72).int32(message.vType);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): UniversalPayload {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseUniversalPayload();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.to = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.value = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.data = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.gasLimit = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.maxFeePerGas = reader.string();\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.maxPriorityFeePerGas = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.nonce = reader.string();\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.deadline = reader.string();\n          continue;\n        }\n        case 9: {\n          if (tag !== 72) {\n            break;\n          }\n\n          message.vType = reader.int32() as any;\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): UniversalPayload {\n    return {\n      to: isSet(object.to) ? globalThis.String(object.to) : \"\",\n      value: isSet(object.value) ? globalThis.String(object.value) : \"\",\n      data: isSet(object.data) ? globalThis.String(object.data) : \"\",\n      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : \"\",\n      maxFeePerGas: isSet(object.maxFeePerGas) ? globalThis.String(object.maxFeePerGas) : \"\",\n      maxPriorityFeePerGas: isSet(object.maxPriorityFeePerGas) ? globalThis.String(object.maxPriorityFeePerGas) : \"\",\n      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : \"\",\n      deadline: isSet(object.deadline) ? globalThis.String(object.deadline) : \"\",\n      vType: isSet(object.vType) ? verificationTypeFromJSON(object.vType) : 0,\n    };\n  },\n\n  toJSON(message: UniversalPayload): unknown {\n    const obj: any = {};\n    if (message.to !== \"\") {\n      obj.to = message.to;\n    }\n    if (message.value !== \"\") {\n      obj.value = message.value;\n    }\n    if (message.data !== \"\") {\n      obj.data = message.data;\n    }\n    if (message.gasLimit !== \"\") {\n      obj.gasLimit = message.gasLimit;\n    }\n    if (message.maxFeePerGas !== \"\") {\n      obj.maxFeePerGas = message.maxFeePerGas;\n    }\n    if (message.maxPriorityFeePerGas !== \"\") {\n      obj.maxPriorityFeePerGas = message.maxPriorityFeePerGas;\n    }\n    if (message.nonce !== \"\") {\n      obj.nonce = message.nonce;\n    }\n    if (message.deadline !== \"\") {\n      obj.deadline = message.deadline;\n    }\n    if (message.vType !== 0) {\n      obj.vType = verificationTypeToJSON(message.vType);\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<UniversalPayload>, I>>(base?: I): UniversalPayload {\n    return UniversalPayload.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<UniversalPayload>, I>>(object: I): UniversalPayload {\n    const message = createBaseUniversalPayload();\n    message.to = object.to ?? \"\";\n    message.value = object.value ?? \"\";\n    message.data = object.data ?? \"\";\n    message.gasLimit = object.gasLimit ?? \"\";\n    message.maxFeePerGas = object.maxFeePerGas ?? \"\";\n    message.maxPriorityFeePerGas = object.maxPriorityFeePerGas ?? \"\";\n    message.nonce = object.nonce ?? \"\";\n    message.deadline = object.deadline ?? \"\";\n    message.vType = object.vType ?? 0;\n    return message;\n  },\n};\n\nfunction createBaseMsgExecutePayload(): MsgExecutePayload {\n  return { signer: \"\", universalAccountId: undefined, universalPayload: undefined, verificationData: \"\" };\n}\n\nexport const MsgExecutePayload: MessageFns<MsgExecutePayload> = {\n  encode(message: MsgExecutePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.signer !== \"\") {\n      writer.uint32(10).string(message.signer);\n    }\n    if (message.universalAccountId !== undefined) {\n      UniversalAccountId.encode(message.universalAccountId, writer.uint32(18).fork()).join();\n    }\n    if (message.universalPayload !== undefined) {\n      UniversalPayload.encode(message.universalPayload, writer.uint32(26).fork()).join();\n    }\n    if (message.verificationData !== \"\") {\n      writer.uint32(34).string(message.verificationData);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): MsgExecutePayload {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMsgExecutePayload();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.signer = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.universalAccountId = UniversalAccountId.decode(reader, reader.uint32());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.universalPayload = UniversalPayload.decode(reader, reader.uint32());\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.verificationData = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): MsgExecutePayload {\n    return {\n      signer: isSet(object.signer) ? globalThis.String(object.signer) : \"\",\n      universalAccountId: isSet(object.universalAccountId)\n        ? UniversalAccountId.fromJSON(object.universalAccountId)\n        : undefined,\n      universalPayload: isSet(object.universalPayload) ? UniversalPayload.fromJSON(object.universalPayload) : undefined,\n      verificationData: isSet(object.verificationData) ? globalThis.String(object.verificationData) : \"\",\n    };\n  },\n\n  toJSON(message: MsgExecutePayload): unknown {\n    const obj: any = {};\n    if (message.signer !== \"\") {\n      obj.signer = message.signer;\n    }\n    if (message.universalAccountId !== undefined) {\n      obj.universalAccountId = UniversalAccountId.toJSON(message.universalAccountId);\n    }\n    if (message.universalPayload !== undefined) {\n      obj.universalPayload = UniversalPayload.toJSON(message.universalPayload);\n    }\n    if (message.verificationData !== \"\") {\n      obj.verificationData = message.verificationData;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<MsgExecutePayload>, I>>(base?: I): MsgExecutePayload {\n    return MsgExecutePayload.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<MsgExecutePayload>, I>>(object: I): MsgExecutePayload {\n    const message = createBaseMsgExecutePayload();\n    message.signer = object.signer ?? \"\";\n    message.universalAccountId = (object.universalAccountId !== undefined && object.universalAccountId !== null)\n      ? UniversalAccountId.fromPartial(object.universalAccountId)\n      : undefined;\n    message.universalPayload = (object.universalPayload !== undefined && object.universalPayload !== null)\n      ? UniversalPayload.fromPartial(object.universalPayload)\n      : undefined;\n    message.verificationData = object.verificationData ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n",
  "packages/core/src/lib/index.ts": "import { PushChain } from './push-chain/push-chain';\nexport type { ConversionQuote } from './constants/tokens';\n\nexport { PushChain };\n",
  "packages/core/src/lib/internal/buffer.ts": "import { Buffer as PolyBuffer } from 'buffer';\n\nexport const Buffer: typeof PolyBuffer =\n  (globalThis as any).Buffer ?? PolyBuffer;\n",
  "packages/core/src/lib/internal/global-buffer-polyfill.ts": "import { Buffer as PolyBuffer } from './buffer';\n\nconst g: any = globalThis;\nif (!g.Buffer || !g.Buffer.from || !g.Buffer.alloc) {\n  g.Buffer = PolyBuffer;\n}\n",
  "packages/core/src/lib/orchestrator/orchestrator.spec.ts": "import { Orchestrator } from './orchestrator';\nimport { CHAIN, LIBRARY, PUSH_NETWORK } from '../constants/enums';\nimport { UniversalSigner } from '../universal/universal.types';\nimport { bytesToHex, createWalletClient, Hex, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { Keypair } from '@solana/web3.js';\nimport { toUniversalFromKeypair } from '../universal/signer/signer';\nimport { SvmClient } from '../vm-client/svm-client';\nimport { CHAIN_INFO } from '../constants/chain';\nimport { VerificationType } from '../generated/v1/tx';\nimport { utils } from '@coral-xyz/anchor';\nimport dotenv from 'dotenv';\nimport path from 'path';\n\n// Adjust path as needed if your .env is in the root\ndotenv.config({ path: path.resolve(__dirname, '../../../.env') });\n\ndescribe('Orchestrator', () => {\n  const mockSigner: UniversalSigner = {\n    account: {\n      address: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n      chain: CHAIN.ETHEREUM_SEPOLIA,\n    },\n    signMessage: async (data: Uint8Array) => {\n      return data;\n    },\n    signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n      return unsignedTx;\n    },\n  };\n\n  describe('lockFee', () => {\n    it('eth sepolia', async () => {\n      // Create orchestrator for eth_sepolia signer\n\n      const chain = CHAIN.ETHEREUM_SEPOLIA;\n      const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as Hex | undefined;\n\n      if (!PRIVATE_KEY) {\n        throw new Error('SEPOLIA_PRIVATE_KEY environment variable is not set');\n      }\n\n      const account = privateKeyToAccount(PRIVATE_KEY);\n      const walletClient = createWalletClient({\n        account: account,\n        transport: http(CHAIN_INFO[chain].defaultRPC[0]),\n      });\n\n      const ethSepoliaSigner: UniversalSigner = await toUniversalFromKeypair(\n        walletClient,\n        {\n          chain,\n          library: LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      const orchestrator = new Orchestrator(\n        ethSepoliaSigner,\n        PUSH_NETWORK.TESTNET_DONUT\n      );\n      const txHashBytes = await orchestrator['lockFee'](BigInt(1)); // 0.00000001 USDC\n      const txHash = bytesToHex(txHashBytes);\n      console.log('lockFee txHash:', txHash);\n      expect(txHash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n    });\n\n    it('solana devnet', async () => {\n      const chain = CHAIN.SOLANA_DEVNET;\n      const privateKeyHex = process.env['SOLANA_PRIVATE_KEY'];\n      if (!privateKeyHex) {\n        throw new Error('SOLANA_PRIVATE_KEY environment variable is not set');\n      }\n      const privateKey = Uint8Array.from(Buffer.from(privateKeyHex, 'hex'));\n\n      // Generate a keypair from the private key in .env\n      const testAccount = Keypair.fromSecretKey(privateKey);\n\n      const solanaDevnetSigner = await toUniversalFromKeypair(testAccount, {\n        chain,\n        library: LIBRARY.SOLANA_WEB3JS,\n      });\n\n      const svmClient = new SvmClient({\n        rpcUrls: ['https://api.devnet.solana.com'],\n      });\n\n      const balance = await svmClient.getBalance(\n        solanaDevnetSigner.account.address\n      );\n      console.log(\n        'balance:',\n        balance,\n        'address: ',\n        solanaDevnetSigner.account.address\n      );\n\n      const orchestrator = new Orchestrator(\n        solanaDevnetSigner,\n        PUSH_NETWORK.TESTNET_DONUT\n      );\n\n      const amount = BigInt(100); // 0.000001 USDC\n      const dummyTxHash =\n        '25ytBco5ZxMaaatzKwcw28emNHD42JzCVe5wUy78mTA8ophwLCZN6dXKkXaRfxhgCdWdqSKpvGNuKvbqJQjzLKwy';\n\n      const txHashBytes = await orchestrator['lockFee'](amount, dummyTxHash);\n      const txHash = utils.bytes.bs58.encode(txHashBytes);\n      console.log('lockFee txHash:', txHash);\n      expect(txHash).toMatch(/^[1-9A-HJ-NP-Za-km-z]{87,88}$/);\n    });\n  });\n\n  describe('computeExecutionHash', () => {\n    const orc = new Orchestrator(mockSigner, PUSH_NETWORK.TESTNET_DONUT);\n    const expectedHash =\n      '0xb6830a8b7684694a071dbeb780edc7627b0f8d9076492d59ea06df60cf04618c';\n    it('should return the expected Hash', () => {\n      const value = {\n        to: '0x527F3692F5C53CfA83F7689885995606F93b6164' as `0x{string}`,\n        value: '0',\n        data: '0x2ba2ed980000000000000000000000000000000000000000000000000000000000000312' as `0x{string}`,\n        gasLimit: '21000000',\n        maxFeePerGas: '10000000000000000',\n        maxPriorityFeePerGas: '2',\n        nonce: '1',\n        deadline: '9999999999',\n        vType: VerificationType.signedVerification,\n      };\n\n      const hash = orc['computeExecutionHash']({\n        payload: value,\n        verifyingContract: '0x48445e02796af0b076f96fc013536f1c879e282c',\n      });\n      expect(hash === expectedHash).toBe(true);\n    });\n\n    it('should return different hash on changing params', () => {\n      const value = {\n        to: '0x527F3692F5C53CfA83F7689885995606F93b6164' as `0x{string}`,\n        value: '0',\n        data: '0x2ba2ed980000000000000000000000000000000000000000000000000000000000000312' as `0x{string}`,\n        gasLimit: '21000000',\n        maxFeePerGas: '10000000000000000',\n        maxPriorityFeePerGas: '2',\n        nonce: '1',\n        deadline: '9999999998',\n        vType: VerificationType.signedVerification,\n      };\n\n      const hash = orc['computeExecutionHash']({\n        payload: value,\n        verifyingContract: '0x48445e02796af0b076f96fc013536f1c879e282c',\n      });\n      expect(hash === expectedHash).toBe(false);\n    });\n  });\n\n  describe('calculateUEAOffchain', () => {\n    describe('EVM signers', () => {\n      it('should calculate consistent UEA address for Ethereum Sepolia signer', async () => {\n        const ethSepoliaSigner: UniversalSigner = {\n          account: {\n            address: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n            chain: CHAIN.ETHEREUM_SEPOLIA,\n          },\n          signMessage: async (data: Uint8Array) => {\n            return data;\n          },\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n            return unsignedTx;\n          },\n        };\n\n        const orchestrator = new Orchestrator(\n          ethSepoliaSigner,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const ueaAddress = await orchestrator.computeUEAOffchain();\n\n        // Should return a valid Ethereum address\n        expect(ueaAddress).toMatch(/^0x[a-fA-F0-9]{40}$/);\n\n        // Should be consistent across multiple calls\n        const ueaAddress2 = await orchestrator.computeUEAOffchain();\n        expect(ueaAddress).toBe(ueaAddress2);\n      });\n\n      it('should calculate different UEA addresses for different EVM addresses', async () => {\n        const signer1: UniversalSigner = {\n          account: {\n            address: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n            chain: CHAIN.ETHEREUM_SEPOLIA,\n          },\n          signMessage: async (data: Uint8Array) => data,\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => unsignedTx,\n        };\n\n        const signer2: UniversalSigner = {\n          account: {\n            address: '0x1234567890123456789012345678901234567890',\n            chain: CHAIN.ETHEREUM_SEPOLIA,\n          },\n          signMessage: async (data: Uint8Array) => data,\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => unsignedTx,\n        };\n\n        const orchestrator1 = new Orchestrator(\n          signer1,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n        const orchestrator2 = new Orchestrator(\n          signer2,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const ueaAddress1 = await orchestrator1.computeUEAOffchain();\n        const ueaAddress2 = await orchestrator2.computeUEAOffchain();\n\n        expect(ueaAddress1).not.toBe(ueaAddress2);\n      });\n    });\n\n    describe('SVM signers', () => {\n      it('should calculate consistent UEA address for Solana Devnet signer', async () => {\n        // Create a test Solana keypair\n        const testKeypair = Keypair.generate();\n\n        const solanaSigner: UniversalSigner = {\n          account: {\n            address: testKeypair.publicKey.toString(),\n            chain: CHAIN.SOLANA_DEVNET,\n          },\n          signMessage: async (data: Uint8Array) => {\n            return data;\n          },\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n            return unsignedTx;\n          },\n        };\n\n        const orchestrator = new Orchestrator(\n          solanaSigner,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const ueaAddress = await orchestrator.computeUEAOffchain();\n\n        // Should return a valid Ethereum address\n        expect(ueaAddress).toMatch(/^0x[a-fA-F0-9]{40}$/);\n\n        // Should be consistent across multiple calls\n        const ueaAddress2 = await orchestrator.computeUEAOffchain();\n        expect(ueaAddress).toBe(ueaAddress2);\n      });\n\n      it('should calculate different UEA addresses for different Solana addresses', async () => {\n        const keypair1 = Keypair.generate();\n        const keypair2 = Keypair.generate();\n\n        const signer1: UniversalSigner = {\n          account: {\n            address: keypair1.publicKey.toString(),\n            chain: CHAIN.SOLANA_DEVNET,\n          },\n          signMessage: async (data: Uint8Array) => data,\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => unsignedTx,\n        };\n\n        const signer2: UniversalSigner = {\n          account: {\n            address: keypair2.publicKey.toString(),\n            chain: CHAIN.SOLANA_DEVNET,\n          },\n          signMessage: async (data: Uint8Array) => data,\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => unsignedTx,\n        };\n\n        const orchestrator1 = new Orchestrator(\n          signer1,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n        const orchestrator2 = new Orchestrator(\n          signer2,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const ueaAddress1 = await orchestrator1.computeUEAOffchain();\n        const ueaAddress2 = await orchestrator2.computeUEAOffchain();\n\n        expect(ueaAddress1).not.toBe(ueaAddress2);\n      });\n    });\n\n    describe('address consistency', () => {\n      it('should return the same address as UEA for EVM signer', async () => {\n        const ethSepoliaSigner: UniversalSigner = {\n          account: {\n            address: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n            chain: CHAIN.ETHEREUM_SEPOLIA,\n          },\n          signMessage: async (data: Uint8Array) => {\n            return data;\n          },\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n            return unsignedTx;\n          },\n        };\n\n        const orchestrator = new Orchestrator(\n          ethSepoliaSigner,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const offchainAddress = await orchestrator.computeUEAOffchain();\n        const UEAResult = await orchestrator.computeUEA();\n\n        expect(offchainAddress).toBe(UEAResult.address);\n      });\n\n      it('should return the same address as UEA for SVM signer', async () => {\n        const testKeypair = Keypair.generate();\n\n        const solanaSigner: UniversalSigner = {\n          account: {\n            address: testKeypair.publicKey.toString(),\n            chain: CHAIN.SOLANA_DEVNET,\n          },\n          signMessage: async (data: Uint8Array) => {\n            return data;\n          },\n          signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n            return unsignedTx;\n          },\n        };\n\n        const orchestrator = new Orchestrator(\n          solanaSigner,\n          PUSH_NETWORK.TESTNET_DONUT\n        );\n\n        const offchainAddress = await orchestrator.computeUEAOffchain();\n        const UEAResult = await orchestrator.computeUEA();\n\n        expect(offchainAddress).toBe(UEAResult.address);\n      });\n    });\n  });\n});\n",
  "packages/core/src/lib/orchestrator/orchestrator.ts": "import {\n  Abi,\n  toBytes,\n  keccak256,\n  sha256,\n  encodeAbiParameters,\n  encodePacked,\n  bytesToHex,\n  stringToBytes,\n  getCreate2Address,\n  hexToBytes,\n  TransactionReceipt,\n  getAddress,\n  decodeFunctionData,\n  parseAbi,\n  encodeFunctionData,\n  zeroAddress,\n} from 'viem';\nimport { PushChain } from '../push-chain/push-chain';\nimport { CHAIN, PUSH_NETWORK, VM } from '../constants/enums';\nimport { buildExecuteMulticall } from './payload-builders';\nimport {\n  UniversalAccount,\n  UniversalSigner,\n} from '../universal/universal.types';\nimport { ExecuteParams, MultiCall } from './orchestrator.types';\nimport { EvmClient } from '../vm-client/evm-client';\nimport {\n  CHAIN_INFO,\n  SYNTHETIC_PUSH_ERC20,\n  UEA_PROXY,\n  VM_NAMESPACE,\n} from '../constants/chain';\nimport {\n  FACTORY_V1,\n  UEA_SVM,\n  ERC20_EVM,\n  UNIVERSAL_GATEWAY_V0,\n  SVM_GATEWAY_IDL,\n} from '../constants/abi';\nimport { PushClient } from '../push-client/push-client';\nimport { SvmClient } from '../vm-client/svm-client';\nimport { PublicKey, SystemProgram, Connection } from '@solana/web3.js';\nimport * as anchor from '@coral-xyz/anchor';\nimport { Any } from 'cosmjs-types/google/protobuf/any';\nimport {\n  UniversalPayload,\n  VerificationType,\n  UniversalAccountId,\n} from '../generated/v1/tx';\nimport { PriceFetch } from '../price-fetch/price-fetch';\nimport { utils } from '@coral-xyz/anchor';\nimport {\n  PROGRESS_HOOK,\n  ProgressEvent,\n} from '../progress-hook/progress-hook.types';\nimport PROGRESS_HOOKS from '../progress-hook/progress-hook';\nimport { TxResponse } from '../vm-client/vm-client.types';\nimport { UEA_EVM } from '../constants/abi/uea.evm';\nimport {\n  UniversalTxResponse,\n  Signature,\n  UniversalTxReceipt,\n} from './orchestrator.types';\nimport { UniversalTx } from '../generated/uexecutor/v1/types';\nimport {\n  ConversionQuote,\n  MOVEABLE_TOKENS,\n  MoveableToken,\n  PAYABLE_TOKENS,\n  PayableToken,\n} from '../constants/tokens';\n\nexport class Orchestrator {\n  private pushClient: PushClient;\n  private ueaVersionCache?: string;\n\n  constructor(\n    private readonly universalSigner: UniversalSigner,\n    private pushNetwork: PUSH_NETWORK,\n    private readonly rpcUrls: Partial<Record<CHAIN, string[]>> = {},\n    private readonly printTraces = false,\n    private progressHook?: (progress: ProgressEvent) => void\n  ) {\n    let pushChain: CHAIN;\n    if (pushNetwork === PUSH_NETWORK.MAINNET) {\n      pushChain = CHAIN.PUSH_MAINNET;\n    } else if (\n      pushNetwork === PUSH_NETWORK.TESTNET_DONUT ||\n      pushNetwork === PUSH_NETWORK.TESTNET\n    ) {\n      pushChain = CHAIN.PUSH_TESTNET_DONUT;\n    } else {\n      pushChain = CHAIN.PUSH_LOCALNET;\n    }\n\n    const pushChainRPCs: string[] =\n      this.rpcUrls[pushChain] || CHAIN_INFO[pushChain].defaultRPC;\n\n    this.pushClient = new PushClient({\n      rpcUrls: pushChainRPCs,\n      network: pushNetwork,\n    });\n  }\n\n  /**\n   * Read-only accessors for current Orchestrator configuration\n   */\n  public getNetwork(): PUSH_NETWORK {\n    return this.pushNetwork;\n  }\n\n  public getRpcUrls(): Partial<Record<CHAIN, string[]>> {\n    return this.rpcUrls;\n  }\n\n  public getPrintTraces(): boolean {\n    return this.printTraces;\n  }\n\n  public getProgressHook(): ((progress: ProgressEvent) => void) | undefined {\n    return this.progressHook;\n  }\n\n  /**\n   * Executes an interaction on Push Chain\n   */\n  async execute(execute: ExecuteParams): Promise<UniversalTxResponse> {\n    try {\n      // FUNDS_TX short-circuit: Bridge tokens from origin chain to Push Chain\n      // - EVM (Sepolia): UniversalGatewayV0\n      // - SVM (Solana Devnet): pushsolanagateway\n      if (execute.funds) {\n        if (!execute.data || execute.data === '0x') {\n          // @@@@@@@@@@@@@@@\n          // @@@@@@@@@@@@@@@\n          // @@@@@@@@@@@@@@@\n          // @@@@@@@@@@@@@@@\n          // @@@@@@@@@@@@@@@\n          // @@@@@@@@@@@@@@@\n          // // Disallow user-provided `value` for funds-only bridging. The SDK derives\n          // // origin-chain msg.value automatically from the funds input:\n          // //  - Native path: msg.value = bridgeAmount\n          // //  - ERC-20 path: msg.value = 0\n          // if (execute.value !== undefined && execute.value !== BigInt(0)) {\n          //   throw new Error(\n          //     'Do not set `value` when using funds bridging; the SDK sets origin msg.value from `funds.amount` automatically'\n          //   );\n          // }\n          const chain = this.universalSigner.account.chain;\n          const { vm } = CHAIN_INFO[chain];\n          if (\n            !(\n              chain === CHAIN.ETHEREUM_SEPOLIA ||\n              chain === CHAIN.ARBITRUM_SEPOLIA ||\n              chain === CHAIN.BASE_SEPOLIA ||\n              chain === CHAIN.BNB_TESTNET ||\n              chain === CHAIN.SOLANA_DEVNET\n            )\n          ) {\n            throw new Error(\n              'Funds bridging is only supported on Ethereum Sepolia, Arbitrum Sepolia, Base Sepolia, BNB Testnet, and Solana Devnet for now'\n            );\n          }\n\n          // Progress: Origin chain detected\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_01, chain);\n\n          const { defaultRPC, lockerContract } = CHAIN_INFO[chain];\n          const rpcUrls: string[] = this.rpcUrls[chain] || defaultRPC;\n\n          // Resolve token: default to native token based on VM (ETH for EVM, SOL for SVM)\n          if (!execute.funds.token) {\n            const available: MoveableToken[] =\n              (MOVEABLE_TOKENS[chain] as MoveableToken[] | undefined) || [];\n            const vm = CHAIN_INFO[chain].vm;\n            const preferredSymbol =\n              vm === VM.EVM ? 'ETH' : vm === VM.SVM ? 'SOL' : undefined;\n            const nativeToken = preferredSymbol\n              ? available.find((t) => t.symbol === preferredSymbol)\n              : undefined;\n            if (!nativeToken) {\n              throw new Error('Native token not configured for this chain');\n            }\n            execute.funds.token = nativeToken;\n          }\n\n          const amount = execute.funds.amount;\n          const symbol = execute.funds.token.symbol;\n\n          // Funds Flow: Preparing funds transfer\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_06_01,\n            amount,\n            execute.funds.token.decimals,\n            symbol\n          );\n\n          if (vm === VM.EVM) {\n            const evmClient = new EvmClient({ rpcUrls });\n            const gatewayAddress = lockerContract as `0x${string}`;\n            const tokenAddr = execute.funds.token.address as `0x${string}`;\n            // Approve gateway to pull tokens if ERC-20 (not native sentinel)\n            if (execute.funds.token.mechanism === 'approve') {\n              await this.ensureErc20Allowance(\n                evmClient,\n                tokenAddr,\n                gatewayAddress,\n                amount\n              );\n            } else if (execute.funds.token.mechanism === 'permit2') {\n              throw new Error('Permit2 is not supported yet');\n            } else if (execute.funds.token.mechanism === 'native') {\n              // Native flow uses msg.value == bridgeAmount and bridgeToken = address(0)\n            }\n          }\n\n          const bridgeAmount = amount;\n\n          const revertCFG = {\n            fundRecipient: this.universalSigner.account\n              .address as `0x${string}`,\n            revertMsg: '0x',\n          } as unknown as never; // typed by viem via ABI\n\n          if (vm === VM.EVM) {\n            const evmClient = new EvmClient({ rpcUrls });\n            const gatewayAddress = lockerContract as `0x${string}`;\n            const tokenAddr = execute.funds.token.address as `0x${string}`;\n            // Call UniversalGatewayV0.sendFunds(recipient, bridgeToken, bridgeAmount, revertCFG)\n            const recipient = execute.to; // funds to recipient on Push Chain\n            const isNative = execute.funds.token.mechanism === 'native';\n            const bridgeToken =\n              execute.funds.token.mechanism === 'approve'\n                ? tokenAddr\n                : ('0x0000000000000000000000000000000000000000' as `0x${string}`);\n            const { nonce } = await this.getUeaStatusAndNonce();\n            const { payload: universalPayload } =\n              await this.buildGatewayPayloadAndGas(\n                execute,\n                nonce,\n                'sendFunds',\n                bridgeAmount\n              );\n\n            // Get UEA info\n            const ueaAddress = this.computeUEAOffchain();\n            const ueaVersion = await this.fetchUEAVersion();\n\n            const eip712Signature = await this.signUniversalPayload(\n              universalPayload,\n              ueaAddress,\n              ueaVersion\n            );\n            const eip712SignatureHex = bytesToHex(eip712Signature);\n\n            let txHash: `0x${string}`;\n            try {\n              // Compute minimal native amount to deposit for gas on Push Chain\n              const ueaAddressForGas = this.computeUEAOffchain();\n              const ueaBalanceForGas = await this.pushClient.getBalance(\n                ueaAddressForGas\n              );\n              const nativeAmount = await this.calculateNativeAmountForDeposit(\n                chain,\n                BigInt(0),\n                ueaBalanceForGas\n              );\n\n              const ueaAddress = this.computeUEAOffchain();\n              if (execute.to.toLowerCase() === ueaAddress.toLowerCase()) {\n                txHash = await evmClient.writeContract({\n                  abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n                  address: gatewayAddress,\n                  functionName: 'sendFunds',\n                  args: [recipient, bridgeToken, bridgeAmount, revertCFG],\n                  signer: this.universalSigner,\n                  value: isNative ? bridgeAmount : BigInt(0),\n                });\n              } else {\n                txHash = await evmClient.writeContract({\n                  abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n                  address: gatewayAddress,\n                  functionName: 'sendTxWithFunds_new',\n                  args: [\n                    tokenAddr,\n                    bridgeAmount,\n                    universalPayload,\n                    revertCFG,\n                    '0x',\n                  ],\n                  signer: this.universalSigner,\n                  value: nativeAmount,\n                });\n              }\n            } catch (err) {\n              this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_04);\n              throw err;\n            }\n\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_03);\n            this.executeProgressHook(\n              PROGRESS_HOOK.SEND_TX_06_02,\n              txHash,\n              bridgeAmount,\n              execute.funds.token.decimals,\n              symbol\n            );\n\n            await this.waitForEvmConfirmationsWithCountdown(\n              evmClient,\n              txHash,\n              4,\n              210000\n            );\n\n            const pushChainUniversalTx =\n              await this.queryUniversalTxStatusFromGatewayTx(\n                evmClient,\n                gatewayAddress,\n                txHash,\n                execute.to === ueaAddress ? 'sendFunds' : 'sendTxWithFunds'\n              );\n            const lastPcTransaction = pushChainUniversalTx?.pcTx.at(-1);\n            const tx = await this.pushClient.getTransaction(\n              lastPcTransaction?.txHash as `0x${string}`\n            );\n            const response = await this.transformToUniversalTxResponse(tx);\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, [response]);\n            return response;\n          } else {\n            // SVM path (Solana Devnet)\n            const svmClient = new SvmClient({ rpcUrls });\n            const programId = new PublicKey(SVM_GATEWAY_IDL.address);\n            const [configPda] = PublicKey.findProgramAddressSync(\n              [stringToBytes('config')],\n              programId\n            );\n            const [vaultPda] = PublicKey.findProgramAddressSync(\n              [stringToBytes('vault')],\n              programId\n            );\n            const [whitelistPda] = PublicKey.findProgramAddressSync(\n              [stringToBytes('whitelist')],\n              programId\n            );\n\n            const userPk = new PublicKey(this.universalSigner.account.address);\n\n            // pay-with-token gas abstraction is not supported on Solana\n            if (execute.payGasWith !== undefined) {\n              throw new Error('Pay-with token is not supported on Solana');\n            }\n\n            let txSignature: string;\n            // SVM-specific RevertSettings: bytes must be a Buffer\n            const revertSvm = {\n              fundRecipient: userPk,\n              revertMsg: Buffer.from([]),\n            } as unknown as never;\n            // New gateway expects EVM recipient as [u8; 20]\n            const recipientEvm20: number[] = Array.from(\n              Buffer.from(\n                (execute.to as `0x${string}`).slice(2).padStart(40, '0'),\n                'hex'\n              ).subarray(0, 20)\n            );\n            if (execute.funds.token.mechanism === 'native') {\n              // Native SOL funds-only\n              // Compute a local whitelist PDA to avoid TS scope issues\n              const [whitelistPdaLocal] = PublicKey.findProgramAddressSync(\n                [stringToBytes('whitelist')],\n                programId\n              );\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              //////// @@@@@@@\n              // DO THE SAME AS FOR BELOW, BUT NOW FOR NATIVE.\n              // for sendTxWithFunds multicall\n              const ueaAddress = this.computeUEAOffchain();\n              if (execute.to === ueaAddress) {\n                txSignature = await svmClient.writeContract({\n                  abi: SVM_GATEWAY_IDL,\n                  address: programId.toBase58(),\n                  functionName: 'sendFunds', // -> unified sendFunds(recipient, bridge_token, bridge_amount, revert_cfg)\n                  args: [\n                    recipientEvm20,\n                    PublicKey.default,\n                    bridgeAmount,\n                    revertSvm,\n                  ],\n                  signer: this.universalSigner,\n                  accounts: {\n                    config: configPda,\n                    vault: vaultPda,\n                    user: userPk,\n                    tokenWhitelist: whitelistPdaLocal,\n                    userTokenAccount: userPk,\n                    gatewayTokenAccount: vaultPda,\n                    bridgeToken: PublicKey.default,\n                    tokenProgram: new PublicKey(\n                      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n                    ),\n                    systemProgram: SystemProgram.programId,\n                  },\n                });\n              } else {\n                const { nonce } = await this.getUeaStatusAndNonce();\n                const { payload: universalPayload } =\n                  await this.buildGatewayPayloadAndGas(\n                    execute,\n                    nonce,\n                    'sendFunds',\n                    execute.funds.amount\n                  );\n                const ueaBalanceForGas = await this.pushClient.getBalance(\n                  ueaAddress\n                );\n                txSignature = await this._sendSVMTxWithFunds({\n                  execute,\n                  mechanism: execute.funds.token.mechanism,\n                  universalPayload,\n                  bridgeAmount,\n                  nativeAmount: await this.calculateNativeAmountForDeposit(\n                    chain,\n                    BigInt(0),\n                    ueaBalanceForGas\n                  ),\n                });\n              }\n            } else if (execute.funds.token.mechanism === 'approve') {\n              // SPL token funds-only (requires pre-existing ATAs)\n              const mintPk = new PublicKey(execute.funds.token.address);\n              // Associated Token Accounts\n              const TOKEN_PROGRAM_ID = new PublicKey(\n                'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n              );\n              const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\n                'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\n              );\n              const userAta = PublicKey.findProgramAddressSync(\n                [\n                  userPk.toBuffer(),\n                  TOKEN_PROGRAM_ID.toBuffer(),\n                  mintPk.toBuffer(),\n                ],\n                ASSOCIATED_TOKEN_PROGRAM_ID\n              )[0];\n              const vaultAta = PublicKey.findProgramAddressSync(\n                [\n                  vaultPda.toBuffer(),\n                  TOKEN_PROGRAM_ID.toBuffer(),\n                  mintPk.toBuffer(),\n                ],\n                ASSOCIATED_TOKEN_PROGRAM_ID\n              )[0];\n\n              const ueaAddress = this.computeUEAOffchain();\n              if (execute.to === ueaAddress) {\n                // vitalik\n                txSignature = await svmClient.writeContract({\n                  abi: SVM_GATEWAY_IDL,\n                  address: programId.toBase58(),\n                  functionName: 'sendFunds',\n                  args: [recipientEvm20, mintPk, bridgeAmount, revertSvm],\n                  signer: this.universalSigner,\n                  accounts: {\n                    config: configPda,\n                    vault: vaultPda,\n                    tokenWhitelist: whitelistPda,\n                    userTokenAccount: userAta,\n                    gatewayTokenAccount: vaultAta,\n                    user: userPk,\n                    bridgeToken: mintPk,\n                    tokenProgram: TOKEN_PROGRAM_ID,\n                    systemProgram: SystemProgram.programId,\n                  },\n                });\n              } else {\n                const { nonce } = await this.getUeaStatusAndNonce();\n                const { payload: universalPayload } =\n                  await this.buildGatewayPayloadAndGas(\n                    execute,\n                    nonce,\n                    'sendFunds',\n                    execute.funds.amount\n                  );\n                const ueaBalanceForGas = await this.pushClient.getBalance(\n                  ueaAddress\n                );\n                txSignature = await this._sendSVMTxWithFunds({\n                  execute,\n                  mechanism: execute.funds.token.mechanism,\n                  universalPayload,\n                  bridgeAmount,\n                  nativeAmount: await this.calculateNativeAmountForDeposit(\n                    chain,\n                    BigInt(0),\n                    ueaBalanceForGas\n                  ),\n                });\n              }\n            } else {\n              throw new Error('Unsupported token mechanism on Solana');\n            }\n\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_03);\n            this.executeProgressHook(\n              PROGRESS_HOOK.SEND_TX_06_02,\n              txSignature,\n              bridgeAmount,\n              execute.funds.token.decimals,\n              symbol\n            );\n\n            await svmClient.waitForConfirmations({\n              txSignature,\n              confirmations: 25,\n              timeoutMs: 300000,\n            });\n            // After origin confirmations, query Push Chain for UniversalTx status (SVM)\n            const pushChainUniversalTx =\n              await this.queryUniversalTxStatusFromGatewayTx(\n                undefined,\n                undefined,\n                txSignature,\n                'sendFunds'\n              );\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06_06);\n\n            const lastPcTransaction = pushChainUniversalTx?.pcTx.at(-1);\n            const tx = await this.pushClient.getTransaction(\n              lastPcTransaction?.txHash as `0x${string}`\n            );\n            const response = await this.transformToUniversalTxResponse(tx);\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, [response]);\n            return response;\n          }\n        } else {\n          // Bridge funds + execute payload. Support:\n          // - EVM (Sepolia): ERC-20 approve path + native gas via msg.value\n          // - SVM (Solana Devnet): SPL or native SOL with gas_amount\n          const { chain, evmClient, gatewayAddress } =\n            this.getOriginGatewayContext();\n\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_01, chain);\n\n          // Default token to native ETH if none provided\n          if (!execute.funds.token) {\n            const available: MoveableToken[] =\n              (MOVEABLE_TOKENS[chain] as MoveableToken[] | undefined) || [];\n            const vm = CHAIN_INFO[chain].vm;\n            const preferredSymbol =\n              vm === VM.EVM ? 'ETH' : vm === VM.SVM ? 'SOL' : undefined;\n            const nativeToken = preferredSymbol\n              ? available.find((t) => t.symbol === preferredSymbol)\n              : undefined;\n            if (!nativeToken) {\n              throw new Error('Native token not configured for this chain');\n            }\n            execute.funds.token = nativeToken;\n          }\n\n          const mechanism = execute.funds.token.mechanism;\n\n          const { deployed, nonce } = await this.getUeaStatusAndNonce();\n          const { payload: universalPayload } =\n            await this.buildGatewayPayloadAndGas(\n              execute,\n              nonce,\n              'sendTxWithFunds',\n              execute.funds.amount\n            );\n\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_02_01);\n\n          // Compute required gas funding on Push Chain and current UEA balance\n          const gasEstimate = execute.gasLimit || BigInt(1e7);\n          const gasPrice = await this.pushClient.getGasPrice();\n          const requiredGasFee = gasEstimate * gasPrice;\n          const payloadValue = execute.value ?? BigInt(0);\n          const requiredFunds = requiredGasFee + payloadValue;\n\n          const ueaAddress = this.computeUEAOffchain();\n          const [ueaBalance] = await Promise.all([\n            this.pushClient.getBalance(ueaAddress),\n          ]);\n\n          // UEA resolved (address, deployment status, balance, nonce)\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_03_02,\n            ueaAddress,\n            deployed\n          );\n\n          // Determine USD to deposit via gateway (8 decimals) with caps: min=$1, max=$10\n          const oneUsd = PushChain.utils.helpers.parseUnits('1', 8);\n          const tenUsd = PushChain.utils.helpers.parseUnits('10', 8);\n          const deficit =\n            requiredFunds > ueaBalance ? requiredFunds - ueaBalance : BigInt(0);\n          let depositUsd =\n            deficit > BigInt(0) ? this.pushClient.pushToUSDC(deficit) : oneUsd;\n\n          if (depositUsd < oneUsd) depositUsd = oneUsd;\n          if (depositUsd > tenUsd)\n            throw new Error(\n              'Deposit value exceeds max $10 worth of native token'\n            );\n\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_02_02, depositUsd);\n\n          // If SVM, clamp depositUsd to on-chain Config caps\n          if (CHAIN_INFO[chain].vm === VM.SVM) {\n            const svmClient = new SvmClient({\n              rpcUrls:\n                this.rpcUrls[CHAIN.SOLANA_DEVNET] ||\n                CHAIN_INFO[CHAIN.SOLANA_DEVNET].defaultRPC,\n            });\n            const programId = new PublicKey(SVM_GATEWAY_IDL.address);\n            const [configPda] = PublicKey.findProgramAddressSync(\n              [stringToBytes('config')],\n              programId\n            );\n            try {\n              const cfg: any = await svmClient.readContract({\n                abi: SVM_GATEWAY_IDL,\n                address: SVM_GATEWAY_IDL.address,\n                functionName: 'config',\n                args: [configPda.toBase58()],\n              });\n              const minField =\n                cfg.minCapUniversalTxUsd ?? cfg.min_cap_universal_tx_usd;\n              const maxField =\n                cfg.maxCapUniversalTxUsd ?? cfg.max_cap_universal_tx_usd;\n              const minCapUsd = BigInt(minField.toString());\n              const maxCapUsd = BigInt(maxField.toString());\n              if (depositUsd < minCapUsd) depositUsd = minCapUsd;\n              // Add 20% safety margin to avoid BelowMinCap due to price drift\n              const withMargin = (minCapUsd * BigInt(12)) / BigInt(10);\n              if (depositUsd < withMargin) depositUsd = withMargin;\n              if (depositUsd > maxCapUsd) depositUsd = maxCapUsd;\n            } catch {\n              // best-effort; fallback to previous bounds if read fails\n            }\n          }\n\n          // Convert USD(8) -> native units using pricing path\n          const nativeTokenUsdPrice = await new PriceFetch(\n            this.rpcUrls\n          ).getPrice(chain); // 8 decimals\n          const nativeDecimals = CHAIN_INFO[chain].vm === VM.SVM ? 9 : 18;\n          const oneNativeUnit = PushChain.utils.helpers.parseUnits(\n            '1',\n            nativeDecimals\n          );\n          // Ceil division to avoid rounding below min USD on-chain\n          let nativeAmount =\n            (depositUsd * oneNativeUnit + (nativeTokenUsdPrice - BigInt(1))) /\n            nativeTokenUsdPrice;\n          // Add 1 unit safety to avoid BelowMinCap from rounding differences\n          nativeAmount = nativeAmount + BigInt(1);\n\n          const revertCFG = {\n            fundRecipient: this.universalSigner.account\n              .address as `0x${string}`,\n            revertMsg: '0x',\n          } as unknown as never;\n\n          const bridgeAmount = execute.funds.amount;\n          const symbol = execute.funds.token.symbol;\n\n          // Funds Flow: Preparing funds transfer\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_06_01,\n            bridgeAmount,\n            execute.funds.token.decimals,\n            symbol\n          );\n\n          if (CHAIN_INFO[this.universalSigner.account.chain].vm === VM.EVM) {\n            const tokenAddr = execute.funds.token.address as `0x${string}`;\n            if (mechanism !== 'approve') {\n              throw new Error(\n                'Only ERC-20 tokens are supported for funds+payload on EVM; native and permit2 are not supported yet'\n              );\n            }\n            const evmClientEvm = evmClient as EvmClient;\n            const gatewayAddressEvm = gatewayAddress as `0x${string}`;\n            await this.ensureErc20Allowance(\n              evmClientEvm,\n              tokenAddr,\n              gatewayAddressEvm,\n              bridgeAmount\n            );\n          }\n\n          let txHash: `0x${string}` | string;\n          try {\n            if (CHAIN_INFO[this.universalSigner.account.chain].vm === VM.EVM) {\n              const tokenAddr = execute.funds.token.address as `0x${string}`;\n              // Compute EIP-712 signature for the universal payload and hash to bytes32\n              this.executeProgressHook(PROGRESS_HOOK.SEND_TX_03_01);\n              const ueaAddress = this.computeUEAOffchain();\n              this.executeProgressHook(\n                PROGRESS_HOOK.SEND_TX_03_02,\n                ueaAddress,\n                deployed\n              );\n\n              this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_01);\n              this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_02);\n              this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_03);\n              const evmClientEvm = evmClient as EvmClient;\n              const gatewayAddressEvm = gatewayAddress as `0x${string}`;\n              // @@@@@@@@@@@@\n              // txHash = await evmClientEvm.writeContract({\n              //   abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n              //   address: gatewayAddressEvm,\n              //   functionName: 'sendTxWithFunds',\n              //   args: [\n              //     tokenAddr,\n              //     bridgeAmount,\n              //     universalPayload,\n              //     revertCFG,\n              //     '0x',\n              //   ],\n              //   signer: this.universalSigner,\n              //   value: nativeAmount,\n              // });\n              // New behavior: if user provided a gasTokenAddress, pay gas in that token via Uniswap quote\n              // Determine pay-with token address, min-out and slippage\n              const payWith = execute.payGasWith;\n              const gasTokenAddress = payWith?.token?.address as\n                | `0x${string}`\n                | undefined;\n\n              if (gasTokenAddress) {\n                if (chain !== CHAIN.ETHEREUM_SEPOLIA) {\n                  throw new Error(\n                    `Only ${PushChain.utils.chains.getChainName(\n                      CHAIN.ETHEREUM_SEPOLIA\n                    )} is supported for paying gas fees with ERC-20 tokens`\n                  );\n                }\n                let amountOutMinETH =\n                  payWith?.minAmountOut !== undefined\n                    ? BigInt(payWith.minAmountOut)\n                    : nativeAmount;\n\n                const slippageBps = payWith?.slippageBps ?? 100;\n                amountOutMinETH = BigInt(\n                  PushChain.utils.conversion.slippageToMinAmount(\n                    amountOutMinETH.toString(),\n                    { slippageBps }\n                  )\n                );\n\n                const { gasAmount } =\n                  await this.calculateGasAmountFromAmountOutMinETH(\n                    gasTokenAddress as `0x${string}`,\n                    amountOutMinETH\n                  );\n                const deadline = BigInt(0);\n\n                // Ensure caller has enough balance of the gas token to cover fees\n                const ownerAddress = this.universalSigner.account\n                  .address as `0x${string}`;\n                const gasTokenBalance = await evmClientEvm.getErc20Balance({\n                  tokenAddress: gasTokenAddress as `0x${string}`,\n                  ownerAddress,\n                });\n                if (gasTokenBalance < gasAmount) {\n                  const sym = payWith?.token?.symbol ?? 'gas token';\n                  const decimals = payWith?.token?.decimals ?? 18;\n                  const needFmt = PushChain.utils.helpers.formatUnits(\n                    gasAmount,\n                    decimals\n                  );\n                  const haveFmt = PushChain.utils.helpers.formatUnits(\n                    gasTokenBalance,\n                    decimals\n                  );\n                  throw new Error(\n                    `Insufficient ${sym} balance to cover gas fees: need ${needFmt}, have ${haveFmt}`\n                  );\n                }\n\n                // Approve gas token to gateway\n                await this.ensureErc20Allowance(\n                  evmClientEvm,\n                  gasTokenAddress,\n                  gatewayAddressEvm,\n                  gasAmount\n                );\n\n                // Approve bridge token already done above; now call new gateway signature (nonpayable)\n                txHash = await evmClientEvm.writeContract({\n                  abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n                  address: gatewayAddressEvm,\n                  functionName: 'sendTxWithFunds_new',\n                  args: [\n                    tokenAddr,\n                    bridgeAmount,\n                    gasTokenAddress,\n                    gasAmount,\n                    amountOutMinETH,\n                    deadline,\n                    universalPayload,\n                    revertCFG,\n                    '0x',\n                  ],\n                  signer: this.universalSigner,\n                });\n              } else {\n                // Existing native-ETH value path\n                txHash = await evmClientEvm.writeContract({\n                  abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n                  address: gatewayAddressEvm,\n                  functionName: 'sendTxWithFunds_new',\n                  args: [\n                    tokenAddr,\n                    bridgeAmount,\n                    universalPayload,\n                    revertCFG,\n                    '0x',\n                  ],\n                  signer: this.universalSigner,\n                  value: nativeAmount,\n                });\n              }\n            } else {\n              txHash = await this._sendSVMTxWithFunds({\n                execute,\n                mechanism,\n                universalPayload,\n                bridgeAmount,\n                nativeAmount,\n              });\n            }\n          } catch (err) {\n            this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_04);\n            throw err;\n          }\n\n          // Payload Flow: Verification Success\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_03);\n\n          // Funds Flow: Funds lock submitted\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_06_02,\n            txHash,\n            bridgeAmount,\n            execute.funds.token.decimals,\n            symbol\n          );\n\n          // Awaiting confirmations\n          if (CHAIN_INFO[this.universalSigner.account.chain].vm === VM.EVM) {\n            const evmClientEvm = evmClient as EvmClient;\n            await this.waitForEvmConfirmationsWithCountdown(\n              evmClientEvm,\n              txHash as `0x${string}`,\n              4,\n              300000\n            );\n          } else {\n            const svmClient = new SvmClient({\n              rpcUrls:\n                this.rpcUrls[CHAIN.SOLANA_DEVNET] ||\n                CHAIN_INFO[CHAIN.SOLANA_DEVNET].defaultRPC,\n            });\n            await svmClient.waitForConfirmations({\n              txSignature: txHash as string,\n              confirmations: 25,\n              timeoutMs: 300000,\n            });\n          }\n\n          // Funds Flow: Confirmed on origin\n          let feeLockTxHash = txHash;\n          if (CHAIN_INFO[this.universalSigner.account.chain].vm === VM.SVM) {\n            if (feeLockTxHash && !feeLockTxHash.startsWith('0x')) {\n              // decode svm base58\n              const decoded = utils.bytes.bs58.decode(feeLockTxHash);\n              feeLockTxHash = bytesToHex(new Uint8Array(decoded));\n            }\n          }\n\n          if (\n            chain === CHAIN.SOLANA_DEVNET ||\n            chain === CHAIN.SOLANA_TESTNET ||\n            chain === CHAIN.SOLANA_MAINNET\n          ) {\n            await this.sendUniversalTx(deployed, feeLockTxHash);\n          }\n\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06_06);\n\n          // After sending Cosmos tx to Push Chain, query UniversalTx status\n          let pushChainUniversalTx: UniversalTx | undefined;\n          if (CHAIN_INFO[this.universalSigner.account.chain].vm === VM.EVM) {\n            const evmClientEvm = evmClient as EvmClient;\n            const gatewayAddressEvm = gatewayAddress as `0x${string}`;\n            pushChainUniversalTx =\n              await this.queryUniversalTxStatusFromGatewayTx(\n                evmClientEvm,\n                gatewayAddressEvm,\n                txHash as `0x${string}`,\n                'sendTxWithFunds'\n              );\n          } else {\n            pushChainUniversalTx =\n              await this.queryUniversalTxStatusFromGatewayTx(\n                undefined,\n                undefined,\n                txHash as string,\n                'sendTxWithFunds'\n              );\n          }\n\n          const lastPcTransaction = pushChainUniversalTx?.pcTx.at(-1);\n          const tx = await this.pushClient.getTransaction(\n            lastPcTransaction?.txHash as `0x${string}`\n          );\n          const response = await this.transformToUniversalTxResponse(tx);\n          this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, [response]);\n          return response;\n        }\n      }\n\n      // Set default value for value if undefined\n      if (execute.value === undefined) {\n        execute.value = BigInt(0);\n      }\n\n      const chain = this.universalSigner.account.chain;\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_01, chain);\n      this.validateMainnetConnection(chain);\n      /**\n       * Push to Push Tx\n       */\n      if (this.isPushChain(chain)) {\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06);\n        const tx = await this.sendPushTx(execute);\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, [tx]);\n        return tx;\n      }\n      /**\n       * Fetch Gas details and estimate cost of execution\n       */\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_02_01);\n      const gasEstimate = execute.gasLimit || BigInt(1e7);\n      const gasPrice = await this.pushClient.getGasPrice();\n      const requiredGasFee = gasEstimate * gasPrice;\n      const requiredFunds = requiredGasFee + execute.value;\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_02_02, requiredFunds);\n      /**\n       * Fetch UEA Details\n       */\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_03_01);\n      const UEA = this.computeUEAOffchain();\n      const [code, funds] = await Promise.all([\n        this.pushClient.publicClient.getCode({ address: UEA }),\n        this.pushClient.getBalance(UEA),\n      ]);\n      const isUEADeployed = code !== undefined;\n      const nonce = isUEADeployed ? await this.getUEANonce(UEA) : BigInt(0);\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_03_02, UEA, isUEADeployed);\n      /**\n       * Compute Universal Payload Hash\n       */\n      let feeLockTxHash: string | undefined = execute.feeLockTxHash;\n      if (feeLockTxHash && !feeLockTxHash.startsWith('0x')) {\n        // decode svm base58\n        const decoded = utils.bytes.bs58.decode(feeLockTxHash);\n        feeLockTxHash = bytesToHex(new Uint8Array(decoded));\n      }\n      // Fee locking is required if UEA is not deployed OR insufficient funds\n      const feeLockingRequired =\n        (!isUEADeployed || funds < requiredFunds) && !feeLockTxHash;\n      // const feeLockingRequired = true;\n\n      // Support multicall payload encoding when execute.data is an array\n      let payloadData: `0x${string}`;\n      let payloadTo: `0x${string}`;\n      if (Array.isArray(execute.data)) {\n        // payloadData = this._buildMulticallPayloadData(execute.to, execute.data);\n        // Normal multicall. We replace the `to` to zeroAddress. Then console.warn to let user know that it should be\n        // passed as zeroAddress in the future.\n        // execute.to = zeroAddress;\n        payloadTo = zeroAddress;\n        console.warn(`Multicalls should have execute.to as ${zeroAddress}`);\n        payloadData = this._buildMulticallPayloadData(\n          execute.to,\n          buildExecuteMulticall({ execute, ueaAddress: UEA })\n        );\n      } else {\n        // payloadData = (execute.data || '0x') as `0x${string}`;\n        if (execute.to.toLowerCase() !== UEA.toLowerCase()) {\n          payloadTo = zeroAddress;\n          payloadData = this._buildMulticallPayloadData(\n            execute.to,\n            buildExecuteMulticall({ execute, ueaAddress: UEA })\n          );\n        } else {\n          // For value only we don't check below. Only if there is payload to be executed\n          if (execute.data && execute.to.toLowerCase() === UEA.toLowerCase()) {\n            throw new Error(`You can't execute data on the UEA address`);\n          }\n          payloadTo = execute.to;\n          payloadData = execute.data || '0x';\n        }\n      }\n\n      const universalPayload = JSON.parse(\n        JSON.stringify(\n          {\n            to: payloadTo,\n            value: execute.value,\n            data: payloadData,\n            gasLimit: execute.gasLimit || BigInt(5e7),\n            maxFeePerGas: execute.maxFeePerGas || BigInt(1e10),\n            maxPriorityFeePerGas: execute.maxPriorityFeePerGas || BigInt(0),\n            nonce,\n            deadline: execute.deadline || BigInt(9999999999),\n            vType: feeLockingRequired\n              ? VerificationType.universalTxVerification\n              : VerificationType.signedVerification,\n          },\n          this.bigintReplacer\n        )\n      ) as UniversalPayload;\n      const ueaVersion = await this.fetchUEAVersion();\n      const executionHash = this.computeExecutionHash({\n        verifyingContract: UEA,\n        payload: universalPayload,\n        version: ueaVersion,\n      });\n      /**\n       * Prepare verification data by either signature or fund locking\n       */\n      let verificationData: `0x${string}`;\n      /**\n       * 1. UEA deployed + sufficient funds: No fee locking needed\n       * 2. UEA deployed + insufficient funds: Lock requiredFunds\n       * 3. UEA not deployed + sufficient funds: Lock 0.001 PC (for deployment)\n       * 4. UEA not deployed + insufficient funds: Lock requiredFunds\n       */\n      if (!feeLockingRequired) {\n        /**\n         * Sign Universal Payload\n         */\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_01, executionHash);\n        const signature = await this.signUniversalPayload(\n          universalPayload,\n          UEA,\n          ueaVersion\n        );\n        verificationData = bytesToHex(signature);\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_04_02, verificationData);\n      } else {\n        /**\n         * Fee Locking - For all chains, EVM and Solana\n         */\n        const fundDifference = requiredFunds - funds;\n        const fixedPushAmount = PushChain.utils.helpers.parseUnits('0.001', 18); // Minimum lock 0.001 Push tokens\n        const lockAmount =\n          funds < requiredFunds ? fundDifference : fixedPushAmount;\n        const lockAmountInUSD = this.pushClient.pushToUSDC(lockAmount);\n\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_05_01, lockAmount);\n        const feeLockTxHashBytes = await this.lockFee(\n          lockAmountInUSD,\n          universalPayload\n        );\n        feeLockTxHash = bytesToHex(feeLockTxHashBytes);\n        verificationData = bytesToHex(feeLockTxHashBytes);\n\n        const { vm } = CHAIN_INFO[chain];\n        this.executeProgressHook(\n          PROGRESS_HOOK.SEND_TX_05_02,\n          vm === VM.SVM\n            ? utils.bytes.bs58.encode(feeLockTxHashBytes)\n            : feeLockTxHash,\n          CHAIN_INFO[chain].confirmations\n        );\n\n        // Waiting for blocks confirmations\n        await this.waitForLockerFeeConfirmation(feeLockTxHashBytes);\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_05_03);\n\n        // Query nodes via gRPC for Push Chain transaction\n        const { defaultRPC, lockerContract } = CHAIN_INFO[chain];\n        const pushChainUniversalTx =\n          await this.queryUniversalTxStatusFromGatewayTx(\n            new EvmClient({ rpcUrls: this.rpcUrls[chain] || defaultRPC }),\n            lockerContract as `0x${string}`,\n            feeLockTxHash,\n            'sendTxWithGas'\n          );\n\n        /**\n         * Return response directly (skip sendUniversalTx for sendTxWithGas flow)\n         * Note: queryTx may be undefined since validators don't recognize new UniversalTx event yet\n         */\n\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06);\n\n        // Transform to UniversalTxResponse (follow sendFunds pattern)\n        const lastPcTransaction = pushChainUniversalTx?.pcTx.at(-1);\n        const tx = await this.pushClient.getTransaction(\n          lastPcTransaction?.txHash as `0x${string}`\n        );\n        const response = await this.transformToUniversalTxResponse(tx);\n        this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, [response]);\n        return response;\n      }\n      /**\n       * Non-fee-locking path: Broadcasting Tx to PC via sendUniversalTx\n       */\n\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06);\n      // We don't need to query via gRPC the PC transaction since it's getting returned it here already.\n      const transactions = await this.sendUniversalTx(\n        isUEADeployed,\n        feeLockTxHash,\n        universalPayload,\n        verificationData\n      );\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_01, transactions);\n      return transactions[transactions.length - 1];\n    } catch (err) {\n      const errMessage =\n        err instanceof Error\n          ? err.message\n          : typeof err === 'string'\n          ? err\n          : (() => {\n              try {\n                return JSON.stringify(err);\n              } catch {\n                return 'Unknown error';\n              }\n            })();\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_99_02, errMessage);\n      throw err;\n    }\n  }\n\n  /**\n   * Locks a fee on the origin chain by interacting with the chain's fee-locker contract.\n   *\n   * @param amount - Fee amount in USDC (8 Decimals)\n   * @param executionHash - Optional execution payload hash (default: zeroHash)\n   * @returns Transaction hash bytes\n   */\n  private async lockFee(\n    amount: bigint, // USD with 8 decimals\n    universalPayload: UniversalPayload\n  ): Promise<Uint8Array> {\n    const chain = this.universalSigner.account.chain;\n    const { lockerContract, vm, defaultRPC } = CHAIN_INFO[chain];\n\n    if (!lockerContract) {\n      throw new Error(`Locker contract not configured for chain: ${chain}`);\n    }\n\n    const rpcUrls: string[] = this.rpcUrls[chain] || defaultRPC;\n\n    switch (vm) {\n      case VM.EVM: {\n        // Run price fetching and client creation in parallel\n        const [nativeTokenUsdPrice, evmClient] = await Promise.all([\n          new PriceFetch(this.rpcUrls).getPrice(chain), // 8 decimals\n          Promise.resolve(new EvmClient({ rpcUrls })),\n        ]);\n\n        const nativeDecimals = 18; // ETH, MATIC, etc.\n        // Ensure deposit respects gateway USD caps (min $1, max $10) and avoid rounding below min\n        const oneUsd = PushChain.utils.helpers.parseUnits('1', 8);\n        const tenUsd = PushChain.utils.helpers.parseUnits('10', 8);\n        let depositUsd = amount < oneUsd ? oneUsd : amount;\n        if (depositUsd > tenUsd) depositUsd = tenUsd;\n        // Ceil division to avoid falling below on-chain min due to rounding, then add 1 wei safety\n        let nativeAmount =\n          (depositUsd * BigInt(10 ** nativeDecimals) +\n            (nativeTokenUsdPrice - BigInt(1))) /\n          nativeTokenUsdPrice;\n        nativeAmount = nativeAmount + BigInt(1);\n\n        // Deposit-only funding via UniversalGatewayV0 (no payload execution)\n        const revertCFG = {\n          fundRecipient: this.universalSigner.account.address as `0x${string}`,\n          revertMsg: '0x',\n        } as unknown as never;\n\n        // Sign the universal payload\n        const ueaAddress = this.computeUEAOffchain();\n        const ueaVersion = await this.fetchUEAVersion();\n        const eip712Signature = await this.signUniversalPayload(\n          universalPayload,\n          ueaAddress,\n          ueaVersion\n        );\n        const eip712SignatureHex =\n          typeof eip712Signature === 'string'\n            ? (eip712Signature as `0x${string}`)\n            : (bytesToHex(eip712Signature) as `0x${string}`);\n\n        const txHash: `0x${string}` = await evmClient.writeContract({\n          abi: UNIVERSAL_GATEWAY_V0 as unknown as Abi,\n          address: lockerContract,\n          functionName: 'sendTxWithGas',\n          args: [universalPayload as unknown as never, revertCFG, '0x'],\n          signer: this.universalSigner,\n          value: nativeAmount,\n        });\n        return hexToBytes(txHash);\n      }\n\n      case VM.SVM: {\n        // Run price fetching and client creation in parallel\n        const [nativeTokenUsdPrice, svmClient] = await Promise.all([\n          new PriceFetch(this.rpcUrls).getPrice(chain), // 8 decimals\n          Promise.resolve(new SvmClient({ rpcUrls })),\n        ]);\n        // Ensure deposit respects gateway USD caps (min $1, max $10) and avoid rounding below min\n        const nativeDecimals = 9; // SOL lamports\n        const oneUsd = PushChain.utils.helpers.parseUnits('1', 8);\n        const tenUsd = PushChain.utils.helpers.parseUnits('10', 8);\n        let depositUsd = amount < oneUsd ? oneUsd : amount;\n        if (depositUsd > tenUsd) depositUsd = tenUsd;\n        // Ceil division to avoid falling below on-chain min due to rounding, then add 1 lamport safety\n        let nativeAmount =\n          (depositUsd * BigInt(10 ** nativeDecimals) +\n            (nativeTokenUsdPrice - BigInt(1))) /\n          nativeTokenUsdPrice;\n        nativeAmount = nativeAmount + BigInt(1);\n\n        // Program & PDAs\n        const programId = new PublicKey(SVM_GATEWAY_IDL.address);\n        const [configPda] = PublicKey.findProgramAddressSync(\n          [stringToBytes('config')],\n          programId\n        );\n        const [vaultPda] = PublicKey.findProgramAddressSync(\n          [stringToBytes('vault')],\n          programId\n        );\n\n        const userPk = new PublicKey(this.universalSigner.account.address);\n        const revertSvm = {\n          fundRecipient: userPk,\n          revertMsg: Buffer.from([]),\n        } as unknown as never;\n\n        // const ueaAddressSvm = this.computeUEAOffchain();\n        // const ueaVersion = await this.fetchUEAVersion();\n        // const svmSignature = await this.signUniversalPayload(\n        //   universalPayload,\n        //   ueaAddressSvm,\n        //   ueaVersion\n        // );\n\n        const txHash = await svmClient.writeContract({\n          abi: SVM_GATEWAY_IDL,\n          address: programId.toBase58(),\n          functionName: 'sendTxWithGas',\n          args: [\n            universalPayload,\n            revertSvm,\n            new anchor.BN(nativeAmount.toString()),\n            '0x',\n          ],\n          signer: this.universalSigner,\n          accounts: {\n            config: configPda,\n            vault: vaultPda,\n            user: userPk,\n            priceUpdate: new PublicKey(\n              '7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE'\n            ),\n            systemProgram: SystemProgram.programId,\n          },\n        });\n        return new Uint8Array(utils.bytes.bs58.decode(txHash));\n      }\n\n      default:\n        throw new Error(`Unsupported VM type: ${vm}`);\n    }\n  }\n\n  private async signUniversalPayload(\n    universalPayload: UniversalPayload,\n    verifyingContract: `0x${string}`,\n    version?: string\n  ) {\n    const chain = this.universalSigner.account.chain;\n    const { vm, chainId } = CHAIN_INFO[chain];\n\n    switch (vm) {\n      case VM.EVM: {\n        if (!this.universalSigner.signTypedData) {\n          throw new Error('signTypedData is not defined');\n        }\n        return this.universalSigner.signTypedData({\n          domain: {\n            version: version || '0.1.0',\n            chainId: Number(chainId),\n            verifyingContract,\n          },\n          types: {\n            UniversalPayload: [\n              { name: 'to', type: 'address' },\n              { name: 'value', type: 'uint256' },\n              { name: 'data', type: 'bytes' },\n              { name: 'gasLimit', type: 'uint256' },\n              { name: 'maxFeePerGas', type: 'uint256' },\n              { name: 'maxPriorityFeePerGas', type: 'uint256' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'deadline', type: 'uint256' },\n              { name: 'vType', type: 'uint8' },\n            ],\n          },\n          primaryType: 'UniversalPayload',\n          message: universalPayload,\n        });\n      }\n\n      case VM.SVM: {\n        const digest = this.computeExecutionHash({\n          verifyingContract,\n          payload: universalPayload,\n          version: version || '0.1.0',\n        });\n        return this.universalSigner.signMessage(stringToBytes(digest));\n      }\n\n      default: {\n        throw new Error(`Unsupported VM type: ${vm}`);\n      }\n    }\n  }\n\n  /**\n   * Sends a custom Cosmos tx to Push Chain (gasless) to execute user intent.\n   */\n  private async sendUniversalTx(\n    isUEADeployed: boolean,\n    feeLockTxHash?: string,\n    universalPayload?: UniversalPayload,\n    verificationData?: `0x${string}`\n  ): Promise<UniversalTxResponse[]> {\n    const { chain, address } = this.universalSigner.account;\n    const { vm, chainId } = CHAIN_INFO[chain];\n\n    const universalAccountId: UniversalAccountId = {\n      chainNamespace: VM_NAMESPACE[vm],\n      chainId: chainId,\n      owner:\n        vm === VM.EVM\n          ? address\n          : vm === VM.SVM\n          ? bytesToHex(new Uint8Array(utils.bytes.bs58.decode(address)))\n          : address,\n    };\n\n    const { cosmosAddress: signer } = this.pushClient.getSignerAddress();\n    const msgs: Any[] = [];\n\n    if (!isUEADeployed) {\n      /**\n       * @dev - fee should be locked for UEA deployment to avoid spamming\n       */\n      if (!feeLockTxHash) {\n        throw new Error('UEA cannot be deployed without fee locking');\n      }\n      msgs.push(\n        this.pushClient.createMsgDeployUEA({\n          signer,\n          universalAccountId,\n          txHash: feeLockTxHash,\n        })\n      );\n\n      // TODO: pchaind q uexecutor all-universal-tx  --node https://rpc-testnet-donut-node1.push.org/\n    }\n\n    if (feeLockTxHash) {\n      msgs.push(\n        this.pushClient.createMsgMintPC({\n          signer,\n          universalAccountId,\n          txHash: feeLockTxHash,\n        })\n      );\n    }\n\n    if (universalPayload && verificationData) {\n      msgs.push(\n        this.pushClient.createMsgExecutePayload({\n          signer,\n          universalAccountId,\n          universalPayload,\n          verificationData,\n        })\n      );\n    }\n\n    const txBody = await this.pushClient.createCosmosTxBody(msgs);\n    const txRaw = await this.pushClient.signCosmosTx(txBody);\n    const tx = await this.pushClient.broadcastCosmosTx(txRaw);\n    if (tx.code !== 0) {\n      throw new Error(tx.rawLog);\n    }\n\n    const ethTxHashes: `0x${string}`[] =\n      tx.events\n        ?.filter((e: any) => e.type === 'ethereum_tx')\n        .flatMap((e: any) =>\n          e.attributes\n            ?.filter((attr: any) => attr.key === 'ethereumTxHash')\n            .map((attr: any) => attr.value as `0x${string}`)\n        ) ?? [];\n\n    if (ethTxHashes.length === 0) {\n      throw new Error('No ethereumTxHash found in transaction events');\n    }\n\n    //  Fetch all corresponding EVM transactions in parallel\n    const evmTxs = await Promise.all(\n      ethTxHashes.map(async (hash) => {\n        return await this.pushClient.getTransaction(hash);\n      })\n    );\n\n    return await Promise.all(\n      evmTxs.map((tx) => this.transformToUniversalTxResponse(tx))\n    );\n  }\n\n  /**\n   * Sends a EVM trx on Push Chain\n   * @dev - Only to be used from universal signer is on Push chain\n   * @param execute\n   * @returns Cosmos Tx Response for a given Evm Tx\n   */\n  private async sendPushTx(\n    execute: ExecuteParams\n  ): Promise<UniversalTxResponse> {\n    // For PushChain, multicall is not supported. Ensure data is hex string.\n    if (Array.isArray(execute.data)) {\n      throw new Error('Multicall is not supported on PushChain');\n    }\n\n    const txHash = await this.pushClient.sendTransaction({\n      to: execute.to,\n      data: (execute.data || '0x') as `0x${string}`,\n      value: execute.value,\n      signer: this.universalSigner,\n    });\n    const txResponse = await this.pushClient.getTransaction(txHash);\n    return await this.transformToUniversalTxResponse(txResponse);\n  }\n\n  /**\n   * Computes the EIP-712 digest hash for the UniversalPayload structure.\n   * This is the message that should be signed by the user's wallet (e.g., Solana signer).\n   *\n   * The resulting hash is equivalent to:\n   * keccak256(\"\\x19\\x01\" || domainSeparator || structHash)\n   *\n   * @param chainId - EVM chain ID of the destination chain (Push Chain)\n   * @param verifyingContract - Address of the verifying contract (i.e., the user's UEA smart wallet)\n   * @param version - Optional EIP-712 domain version (default: '0.1.0')\n   * @param payload - Execution details encoded into the UniversalPayload struct\n   * @returns keccak256 digest to be signed by the user\n   */\n  private computeExecutionHash({\n    verifyingContract,\n    payload,\n    version = '0.1.0',\n  }: {\n    verifyingContract: `0x${string}`;\n    version?: string;\n    payload: UniversalPayload;\n  }): `0x${string}` {\n    const chain = this.universalSigner.account.chain;\n    const { vm, chainId } = CHAIN_INFO[chain];\n\n    // 1. Type hash\n    const typeHash = keccak256(\n      toBytes(\n        'UniversalPayload(address to,uint256 value,bytes data,uint256 gasLimit,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,uint256 nonce,uint256 deadline,uint8 vType)'\n      )\n    );\n\n    // 2. Domain separator\n    const domainTypeHash = keccak256(\n      toBytes(\n        vm === VM.EVM\n          ? 'EIP712Domain(string version,uint256 chainId,address verifyingContract)'\n          : 'EIP712Domain_SVM(string version,string chainId,address verifyingContract)'\n      )\n    );\n\n    const domainSeparator = keccak256(\n      encodeAbiParameters(\n        [\n          { name: 'typeHash', type: 'bytes32' },\n          { name: 'version', type: 'bytes32' },\n          { name: 'chainId', type: vm === VM.EVM ? 'uint256' : 'string' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        [\n          domainTypeHash,\n          keccak256(toBytes(version)),\n          vm === VM.EVM ? BigInt(chainId) : chainId,\n          verifyingContract,\n        ]\n      )\n    );\n\n    // 3. Struct hash\n    const structHash = keccak256(\n      encodeAbiParameters(\n        [\n          { name: 'typeHash', type: 'bytes32' },\n          { name: 'to', type: 'address' },\n          { name: 'value', type: 'uint256' },\n          { name: 'data', type: 'bytes32' },\n          { name: 'gasLimit', type: 'uint256' },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          { name: 'maxPriorityFeePerGas', type: 'uint256' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'deadline', type: 'uint256' },\n          { name: 'vType', type: 'uint8' },\n        ],\n        [\n          typeHash,\n          payload.to as `0x${string}`,\n          BigInt(payload.value),\n          keccak256(payload.data as `0x${string}`),\n          BigInt(payload.gasLimit),\n          BigInt(payload.maxFeePerGas),\n          BigInt(payload.maxPriorityFeePerGas),\n          BigInt(payload.nonce),\n          BigInt(payload.deadline),\n          payload.vType,\n        ]\n      )\n    );\n\n    // 4. Final digest\n    return keccak256(\n      encodePacked(\n        ['string', 'bytes32', 'bytes32'],\n        ['\\x19\\x01', domainSeparator, structHash]\n      )\n    );\n  }\n\n  /**\n   * Computes UEA for given UniversalAccount\n   * @dev - This fn calls a view fn of Factory Contract\n   * @dev - Don't use this fn in production - only used for testing\n   * @returns UEA Address with Deployment Status\n   */\n  async computeUEA(): Promise<{\n    address: `0x${string}`;\n    deployed: boolean;\n  }> {\n    const { chain, address } = this.universalSigner.account;\n    const { vm, chainId } = CHAIN_INFO[chain];\n\n    if (this.isPushChain(chain)) {\n      throw new Error('UEA cannot be computed for a Push Chain Address');\n    }\n\n    const computedAddress: `0x{string}` = await this.pushClient.readContract({\n      address: this.pushClient.pushChainInfo.factoryAddress,\n      abi: FACTORY_V1 as Abi,\n      functionName: 'computeUEA',\n      args: [\n        {\n          chainNamespace: VM_NAMESPACE[vm],\n          chainId: chainId,\n          /**\n           * @dev - Owner should be in bytes\n           * for eth - convert hex to bytes\n           * for sol - convert base64 to bytes\n           * for others - not defined yet\n           */\n          owner:\n            vm === VM.EVM\n              ? address\n              : vm === VM.SVM\n              ? bytesToHex(new Uint8Array(utils.bytes.bs58.decode(address)))\n              : address,\n        },\n      ],\n    });\n\n    const byteCode = await this.pushClient.publicClient.getCode({\n      address: computedAddress,\n    });\n    return { address: computedAddress, deployed: byteCode !== undefined };\n  }\n\n  private _buildMulticallPayloadData(\n    to: `0x${string}`,\n    data: MultiCall[]\n  ): `0x${string}` {\n    const allowedChains = [\n      CHAIN.ETHEREUM_SEPOLIA,\n      CHAIN.ARBITRUM_SEPOLIA,\n      CHAIN.BASE_SEPOLIA,\n      CHAIN.SOLANA_DEVNET,\n      CHAIN.BNB_TESTNET,\n    ];\n    if (!allowedChains.includes(this.universalSigner.account.chain)) {\n      throw new Error(\n        'Multicall is only enabled for Ethereum Sepolia, Arbitrum Sepolia, Base Sepolia, Binance Smart Chain and Solana Devnet'\n      );\n    }\n\n    // For multicall, `to` must be the executor account (UEA) of the sender\n    // i.e., PushChain.universal.account\n    const expectedUea = this.computeUEAOffchain();\n    const toAddr = getAddress(to as `0x${string}`);\n    // if (toAddr !== getAddress(expectedUea)) {\n    //   throw new Error(\n    //     'Multicall requires `to` to be the executor account (UEA) of the sender.'\n    //   );\n    // }\n\n    // Normalize and validate calls\n    const normalizedCalls = data.map((c: MultiCall) => ({\n      to: getAddress(c.to),\n      value: c.value,\n      data: c.data,\n    }));\n\n    // bytes4(keccak256(\"UEA_MULTICALL\")) selector, e.g., 0x4e2d2ff6-like prefix\n    const selector = keccak256(toBytes('UEA_MULTICALL')).slice(\n      0,\n      10\n    ) as `0x${string}`;\n\n    // abi.encode(Call[]), where Call = { address to; uint256 value; bytes data; }\n    const encodedCalls = encodeAbiParameters(\n      [\n        {\n          type: 'tuple[]',\n          components: [\n            { name: 'to', type: 'address' },\n            { name: 'value', type: 'uint256' },\n            { name: 'data', type: 'bytes' },\n          ],\n        },\n      ],\n      [normalizedCalls]\n    );\n\n    // Concatenate prefix selector with encodedCalls without 0x\n    return (selector + encodedCalls.slice(2)) as `0x${string}`;\n  }\n\n  private async _sendSVMTxWithFunds({\n    execute,\n    mechanism,\n    universalPayload,\n    bridgeAmount,\n    nativeAmount,\n  }: {\n    execute: ExecuteParams;\n    mechanism: 'native' | 'approve' | 'permit2' | string;\n    universalPayload: UniversalPayload;\n    bridgeAmount: bigint;\n    nativeAmount: bigint;\n  }): Promise<string> {\n    // SVM funds+payload path\n    const svmClient = new SvmClient({\n      rpcUrls:\n        this.rpcUrls[CHAIN.SOLANA_DEVNET] ||\n        CHAIN_INFO[CHAIN.SOLANA_DEVNET].defaultRPC,\n    });\n    const programId = new PublicKey(SVM_GATEWAY_IDL.address);\n    const [configPda] = PublicKey.findProgramAddressSync(\n      [stringToBytes('config')],\n      programId\n    );\n    const [vaultPda] = PublicKey.findProgramAddressSync(\n      [stringToBytes('vault')],\n      programId\n    );\n    // whitelistPda already computed above\n    const userPk = new PublicKey(this.universalSigner.account.address);\n    const priceUpdatePk = new PublicKey(\n      '7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE'\n    );\n\n    // pay-with-token gas abstraction is not supported on Solana\n    if (execute.payGasWith !== undefined) {\n      throw new Error('Pay-with token is not supported on Solana');\n    }\n\n    if (!execute.funds?.token?.address) {\n      throw new Error('Token address is required for bridge path');\n    }\n\n    const isNative =\n      mechanism === 'native' || execute.funds.token.symbol === 'SOL';\n    const revertSvm2 = {\n      fundRecipient: userPk,\n      revertMsg: Buffer.from([]),\n    } as unknown as never;\n    // Compute signature for universal payload on SVM\n    const ueaAddressSvm = this.computeUEAOffchain();\n    const ueaVersion = await this.fetchUEAVersion();\n    const svmSignature = await this.signUniversalPayload(\n      universalPayload,\n      ueaAddressSvm,\n      ueaVersion\n    );\n    if (isNative) {\n      // Native SOL as bridge + gas\n      const [whitelistPdaLocal] = PublicKey.findProgramAddressSync(\n        [stringToBytes('whitelist')],\n        programId\n      );\n      return await svmClient.writeContract({\n        abi: SVM_GATEWAY_IDL,\n        address: programId.toBase58(),\n        functionName: 'sendTxWithFunds',\n        args: [\n          PublicKey.default, // bridge_token = default for native SOL\n          bridgeAmount,\n          universalPayload,\n          revertSvm2,\n          nativeAmount,\n          Buffer.from(svmSignature),\n        ],\n        signer: this.universalSigner,\n        accounts: {\n          config: configPda,\n          vault: vaultPda,\n          tokenWhitelist: whitelistPdaLocal,\n          userTokenAccount: userPk, // for native SOL, can be any valid account\n          gatewayTokenAccount: vaultPda, // for native SOL, can be any valid account\n          user: userPk,\n          priceUpdate: priceUpdatePk,\n          bridgeToken: PublicKey.default,\n          tokenProgram: new PublicKey(\n            'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n          ),\n          systemProgram: SystemProgram.programId,\n        },\n      });\n    } else {\n      // SPL token as bridge + native SOL lamports as gas_amount\n      if (!execute.funds?.token?.address) {\n        throw new Error('Token address is required for SPL bridge path');\n      }\n      const mintPk = new PublicKey(execute.funds.token.address);\n      const TOKEN_PROGRAM_ID = new PublicKey(\n        'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n      );\n      const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\n        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\n      );\n      const userAta = PublicKey.findProgramAddressSync(\n        [userPk.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPk.toBuffer()],\n        ASSOCIATED_TOKEN_PROGRAM_ID\n      )[0];\n      const vaultAta = PublicKey.findProgramAddressSync(\n        [vaultPda.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPk.toBuffer()],\n        ASSOCIATED_TOKEN_PROGRAM_ID\n      )[0];\n\n      const [whitelistPdaLocal] = PublicKey.findProgramAddressSync(\n        [stringToBytes('whitelist')],\n        programId\n      );\n      return await svmClient.writeContract({\n        abi: SVM_GATEWAY_IDL,\n        address: programId.toBase58(),\n        functionName: 'sendTxWithFunds',\n        args: [\n          mintPk,\n          bridgeAmount,\n          universalPayload,\n          revertSvm2,\n          nativeAmount,\n          Buffer.from(svmSignature),\n        ],\n        signer: this.universalSigner,\n        accounts: {\n          config: configPda,\n          vault: vaultPda,\n          tokenWhitelist: whitelistPdaLocal,\n          userTokenAccount: userAta,\n          gatewayTokenAccount: vaultAta,\n          user: userPk,\n          priceUpdate: priceUpdatePk,\n          bridgeToken: mintPk,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: SystemProgram.programId,\n        },\n      });\n    }\n  }\n\n  computeUEAOffchain(): `0x${string}` {\n    const { chain, address } = this.universalSigner.account;\n    const { vm, chainId } = CHAIN_INFO[chain];\n\n    // If already an on-chain Push EOA, just return it\n    if (this.isPushChain(chain)) {\n      return address as `0x${string}`;\n    }\n\n    // 1) Figure out the externalchain ownerKey bytes\n    let ownerKey: `0x${string}`;\n    if (CHAIN_INFO[chain].vm === VM.EVM) {\n      ownerKey = address as `0x${string}`;\n    } else if (CHAIN_INFO[chain].vm === VM.SVM) {\n      ownerKey = bytesToHex(new Uint8Array(utils.bytes.bs58.decode(address)));\n    } else {\n      throw new Error(`Unsupported VM type: ${CHAIN_INFO[chain].vm}`);\n    }\n\n    // Step 1: Recreate the salt: keccak256(abi.encode(UniversalAccount))\n    const encodedAccountId = encodeAbiParameters(\n      [\n        {\n          type: 'tuple',\n          components: [\n            { name: 'chainNamespace', type: 'string' },\n            { name: 'chainId', type: 'string' },\n            { name: 'owner', type: 'bytes' },\n          ],\n        },\n      ],\n      [{ chainNamespace: VM_NAMESPACE[vm], chainId, owner: ownerKey }]\n    );\n\n    const salt = keccak256(encodedAccountId);\n\n    // Step 2: Clone Minimal Proxy bytecode\n    const minimalProxyRuntimeCode = ('0x3d602d80600a3d3981f3' +\n      '363d3d373d3d3d363d73' +\n      UEA_PROXY[this.pushNetwork].toLowerCase().replace(/^0x/, '') +\n      '5af43d82803e903d91602b57fd5bf3') as `0x${string}`;\n\n    // Step 3: Get init code hash (used by CREATE2)\n    const initCodeHash = keccak256(minimalProxyRuntimeCode);\n\n    // Step 4: Predict the address using standard CREATE2 formula\n    const ueaAddress = getCreate2Address({\n      from: this.pushClient.pushChainInfo.factoryAddress,\n      salt,\n      bytecodeHash: initCodeHash,\n    });\n\n    return ueaAddress;\n  }\n\n  /**\n   * @dev - Although as of now nonce var is same in evm & svm so switch conditions does not matter\n   * @param address UEA address\n   * @returns UEA current nonce\n   */\n  private async getUEANonce(address: `0x${string}`): Promise<bigint> {\n    const chain = this.universalSigner.account.chain;\n    const { vm } = CHAIN_INFO[chain];\n\n    switch (vm) {\n      case VM.EVM: {\n        return this.pushClient.readContract({\n          address,\n          abi: UEA_EVM as Abi,\n          functionName: 'nonce',\n        });\n      }\n\n      case VM.SVM: {\n        return this.pushClient.readContract({\n          address,\n          abi: UEA_SVM as Abi,\n          functionName: 'nonce',\n        });\n      }\n\n      default: {\n        throw new Error(`Unsupported VM type: ${vm}`);\n      }\n    }\n  }\n\n  // TODO: Fix this fn - It needs to get UOA for a given UEA\n  getUOA(): UniversalAccount {\n    return {\n      chain: this.universalSigner.account.chain,\n      address: this.universalSigner.account.address,\n    };\n  }\n\n  private async waitForLockerFeeConfirmation(\n    txHashBytes: Uint8Array\n  ): Promise<void> {\n    const chain = this.universalSigner.account.chain;\n    const { vm, defaultRPC, confirmations, timeout } = CHAIN_INFO[chain];\n    const rpcUrls = this.rpcUrls[chain] || defaultRPC;\n\n    switch (vm) {\n      case VM.EVM: {\n        const evmClient = new EvmClient({ rpcUrls });\n        await this.waitForEvmConfirmationsWithCountdown(\n          evmClient,\n          bytesToHex(txHashBytes),\n          confirmations,\n          timeout\n        );\n        return;\n      }\n\n      case VM.SVM: {\n        const svmClient = new SvmClient({ rpcUrls });\n        await this.waitForSvmConfirmationsWithCountdown(\n          svmClient,\n          utils.bytes.bs58.encode(txHashBytes),\n          confirmations,\n          timeout\n        );\n        return;\n      }\n\n      default:\n        throw new Error(`Unsupported VM for tx confirmation: ${vm}`);\n    }\n  }\n\n  /**\n   * Quotes exact-output on Uniswap V3 for EVM origin chains using QuoterV2.\n   * Returns the minimum required input (amountIn) to receive the target amountOut.\n   */\n  public async _quoteExactOutput(\n    amountOut: bigint,\n    {\n      from,\n      to,\n    }: {\n      from: PayableToken | undefined;\n      to: MoveableToken | undefined;\n    }\n  ): Promise<ConversionQuote> {\n    const originChain = this.universalSigner.account.chain;\n    if (\n      originChain !== CHAIN.ETHEREUM_MAINNET &&\n      originChain !== CHAIN.ETHEREUM_SEPOLIA\n    ) {\n      throw new Error(\n        'Exact-output quoting is only supported on Ethereum Mainnet and Sepolia for now'\n      );\n    }\n\n    if (!from) {\n      throw new Error('from token is required');\n    }\n    if (!to) {\n      throw new Error('to token is required');\n    }\n\n    const rpcUrls =\n      this.getRpcUrls()[originChain] || CHAIN_INFO[originChain].defaultRPC;\n    const evm = new EvmClient({ rpcUrls });\n\n    const factoryFromConfig = CHAIN_INFO[originChain].dex?.uniV3Factory;\n    const quoterFromConfig = CHAIN_INFO[originChain].dex?.uniV3QuoterV2;\n    if (!factoryFromConfig || !quoterFromConfig) {\n      throw new Error('Uniswap V3 addresses not configured for this chain');\n    }\n    const UNISWAP_V3_FACTORY = factoryFromConfig as `0x${string}`;\n    const UNISWAP_V3_QUOTER_V2 = quoterFromConfig as `0x${string}`;\n\n    const factoryAbi: Abi = parseAbi([\n      'function getPool(address tokenA, address tokenB, uint24 fee) view returns (address)',\n    ]);\n    const quoterAbi: Abi = parseAbi([\n      'function quoteExactOutputSingle((address tokenIn, address tokenOut, uint256 amount, uint24 fee, uint160 sqrtPriceLimitX96) params) returns (uint256 amountIn, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)',\n    ]);\n    const poolAbi: Abi = parseAbi([\n      'function liquidity() view returns (uint128)',\n    ]);\n\n    const feeTiers: number[] = [100, 500, 3000, 10000];\n\n    let bestAmountIn: bigint | null = null;\n    let bestFee: number | null = null;\n\n    for (const fee of feeTiers) {\n      // Find pool address for this fee tier\n      const poolAddress = await evm.readContract<string>({\n        abi: factoryAbi,\n        address: UNISWAP_V3_FACTORY,\n        functionName: 'getPool',\n        args: [from.address as `0x${string}`, to.address as `0x${string}`, fee],\n      });\n\n      const isZero =\n        !poolAddress ||\n        poolAddress.toLowerCase() ===\n          '0x0000000000000000000000000000000000000000';\n      if (isZero) continue;\n\n      // Skip uninitialized/empty pools to avoid Quoter reverts\n      try {\n        const liquidity = await evm.readContract<bigint>({\n          abi: poolAbi,\n          address: poolAddress as `0x${string}`,\n          functionName: 'liquidity',\n          args: [],\n        });\n        if (!liquidity || liquidity === BigInt(0)) continue;\n      } catch {\n        continue;\n      }\n\n      // Quote exact output single for this fee tier\n      try {\n        const result = await evm.readContract<[bigint, bigint, number, bigint]>(\n          {\n            abi: quoterAbi,\n            address: UNISWAP_V3_QUOTER_V2,\n            functionName: 'quoteExactOutputSingle',\n            args: [\n              {\n                tokenIn: from.address as `0x${string}`,\n                tokenOut: to.address as `0x${string}`,\n                amount: amountOut,\n                fee,\n                sqrtPriceLimitX96: BigInt(0),\n              },\n            ],\n          }\n        );\n        const amountIn = result?.[0] ?? BigInt(0);\n        if (amountIn === BigInt(0)) continue;\n        if (bestAmountIn === null || amountIn < bestAmountIn) {\n          bestAmountIn = amountIn;\n          bestFee = fee;\n        }\n      } catch {\n        // try next fee\n      }\n    }\n\n    if (bestAmountIn === null || bestFee === null) {\n      throw new Error(\n        'No direct Uniswap V3 pool found for the given token pair on common fee tiers'\n      );\n    }\n\n    const amountInBig = BigInt(bestAmountIn);\n    const amountInHuman = parseFloat(\n      PushChain.utils.helpers.formatUnits(amountInBig, {\n        decimals: from.decimals,\n      })\n    );\n    const amountOutHuman = parseFloat(\n      PushChain.utils.helpers.formatUnits(amountOut, { decimals: to.decimals })\n    );\n    const rate = amountInHuman > 0 ? amountOutHuman / amountInHuman : 0;\n\n    return {\n      amountIn: bestAmountIn.toString(),\n      amountOut: amountOut.toString(),\n      rate,\n      route: [from.symbol, to.symbol],\n      timestamp: Date.now(),\n    };\n  }\n\n  private async ensureErc20Allowance(\n    evmClient: EvmClient,\n    tokenAddress: `0x${string}`,\n    spender: `0x${string}`,\n    requiredAmount: bigint\n  ): Promise<void> {\n    const chain = this.universalSigner.account.chain;\n    const owner = this.universalSigner.account.address as `0x${string}`;\n\n    const currentAllowance = await evmClient.readContract<bigint>({\n      abi: ERC20_EVM as Abi,\n      address: tokenAddress,\n      functionName: 'allowance',\n      args: [owner, spender],\n    });\n\n    if (currentAllowance >= requiredAmount) return;\n\n    // Some ERC-20s like USDT require setting allowance to 0 before changing\n    // an existing non-zero allowance to a different non-zero value.\n    if (currentAllowance > BigInt(0)) {\n      this.printLog(\n        `Resetting existing allowance from ${currentAllowance.toString()} to 0 for spender ${spender}`\n      );\n      const resetTxHash = await evmClient.writeContract({\n        abi: ERC20_EVM as Abi,\n        address: tokenAddress,\n        functionName: 'approve',\n        args: [spender, BigInt(0)],\n        signer: this.universalSigner,\n      });\n      await evmClient.waitForConfirmations({\n        txHash: resetTxHash,\n        confirmations: 1,\n        timeoutMs: CHAIN_INFO[chain].timeout,\n      });\n    }\n\n    const setTxHash = await evmClient.writeContract({\n      abi: ERC20_EVM as Abi,\n      address: tokenAddress,\n      functionName: 'approve',\n      args: [spender, requiredAmount],\n      signer: this.universalSigner,\n    });\n\n    await evmClient.waitForConfirmations({\n      txHash: setTxHash,\n      confirmations: 1,\n      timeoutMs: CHAIN_INFO[chain].timeout,\n    });\n\n    try {\n      const updated = await evmClient.readContract<bigint>({\n        abi: ERC20_EVM as Abi,\n        address: tokenAddress,\n        functionName: 'allowance',\n        args: [owner, spender],\n      });\n      if (updated < requiredAmount) {\n        this.printLog('Warning: allowance not updated yet; proceeding');\n      }\n    } catch {\n      // ignore\n    }\n  }\n\n  /**\n   * Ensures we're on Sepolia, returns EVM client and gateway address.\n   */\n  private getOriginGatewayContext(): {\n    chain: CHAIN;\n    evmClient?: EvmClient;\n    gatewayAddress?: `0x${string}`;\n  } {\n    const chain = this.universalSigner.account.chain;\n    if (\n      chain !== CHAIN.ETHEREUM_SEPOLIA &&\n      chain !== CHAIN.ARBITRUM_SEPOLIA &&\n      chain !== CHAIN.BASE_SEPOLIA &&\n      chain !== CHAIN.BNB_TESTNET &&\n      chain !== CHAIN.SOLANA_DEVNET\n    ) {\n      throw new Error(\n        'Funds + payload bridging is only supported on Ethereum Sepolia, Arbitrum Sepolia, Base Sepolia, BNB Testnet, and Solana Devnet for now'\n      );\n    }\n\n    // For EVM (Sepolia), return client and gateway address. For SVM (Solana Devnet), only chain is needed here.\n    if (CHAIN_INFO[chain].vm === VM.EVM) {\n      const { defaultRPC, lockerContract } = CHAIN_INFO[chain];\n      const rpcUrls: string[] = this.rpcUrls[chain] || defaultRPC;\n      const evmClient = new EvmClient({ rpcUrls });\n      const gatewayAddress = lockerContract as `0x${string}`;\n      if (!gatewayAddress) {\n        throw new Error('Universal Gateway address not configured');\n      }\n      return { chain, evmClient, gatewayAddress };\n    }\n\n    // SVM path (Solana Devnet) does not require evmClient/gatewayAddress\n    return { chain };\n  }\n\n  /**\n   * Computes UEA and fetches its nonce if deployed; returns 0 otherwise.\n   */\n  private async getUeaNonceForExecution(): Promise<bigint> {\n    const UEA = this.computeUEAOffchain();\n    const [code] = await Promise.all([\n      this.pushClient.publicClient.getCode({ address: UEA }),\n    ]);\n    return code !== undefined ? await this.getUEANonce(UEA) : BigInt(0);\n  }\n\n  /**\n   * Returns UEA deployment status and nonce (0 if not deployed).\n   */\n  private async getUeaStatusAndNonce(): Promise<{\n    deployed: boolean;\n    nonce: bigint;\n  }> {\n    const UEA = this.computeUEAOffchain();\n    const [code] = await Promise.all([\n      this.pushClient.publicClient.getCode({ address: UEA }),\n    ]);\n    const deployed = code !== undefined;\n    const nonce = deployed ? await this.getUEANonce(UEA) : BigInt(0);\n    return { deployed, nonce };\n  }\n\n  /**\n   * For sendFunds, we will call internally the sendTxWithFunds.\n   */\n  private async buildGatewayPayloadAndGas(\n    execute: ExecuteParams,\n    nonce: bigint,\n    type: 'sendFunds' | 'sendTxWithFunds',\n    fundsValue?: bigint\n  ): Promise<{ payload: never; gasAmount: bigint }> {\n    const gasEstimate = execute.gasLimit || BigInt(1e7);\n    const gasAmount = execute.value ?? BigInt(0);\n\n    if (type === 'sendTxWithFunds') {\n      if (!execute.funds?.token)\n        throw new Error(`Invalid ${execute.funds?.token}`);\n\n      const multicallData: MultiCall[] = buildExecuteMulticall({\n        execute,\n        ueaAddress: this.computeUEAOffchain(),\n      });\n      // THIS ABOVE WILL CHANGE WHEN FUNDS ARE PASSED\n      const universalPayload = {\n        to: zeroAddress,\n        value: execute.value ?? BigInt(0),\n        // data: execute.data || '0x',\n        data: this._buildMulticallPayloadData(execute.to, multicallData),\n        gasLimit: gasEstimate,\n        maxFeePerGas: execute.maxFeePerGas || BigInt(1e10),\n        maxPriorityFeePerGas: execute.maxPriorityFeePerGas || BigInt(0),\n        nonce,\n        deadline: execute.deadline || BigInt(9999999999),\n        vType: VerificationType.universalTxVerification,\n      } as unknown as never;\n\n      return { payload: universalPayload, gasAmount };\n    } else {\n      if (!fundsValue) throw new Error('fundsValue property must not be empty');\n      const multicallData: MultiCall[] = buildExecuteMulticall({\n        execute,\n        ueaAddress: this.computeUEAOffchain(),\n      });\n\n      // // The data will be the abi-encoded transfer function from erc-20 function. The recipient will be `execute.to`, the value\n      // // will be the fundsValue property.\n      // const data = encodeFunctionData({\n      //   abi: ERC20_EVM,\n      //   functionName: 'transfer',\n      //   args: [execute.to, fundsValue],\n      // });\n      // const pushChainTo = PushChain.utils.tokens.getPRC20Mapping(\n      //   execute.funds!.token as MoveableToken\n      // );\n      const universalPayload = {\n        to: zeroAddress, // We can't simply do `0x` because we will get an error when eip712 signing the transaction.\n        value: execute.value ?? BigInt(0),\n        data: this._buildMulticallPayloadData(execute.to, multicallData),\n        // data: this._buildMulticallPayloadData(execute.to, [\n        //   { to: pushChainTo, value: execute.value ?? BigInt(0), data },\n        // ]),\n        gasLimit: gasEstimate,\n        maxFeePerGas: execute.maxFeePerGas || BigInt(1e10),\n        maxPriorityFeePerGas: execute.maxPriorityFeePerGas || BigInt(0),\n        nonce,\n        deadline: execute.deadline || BigInt(9999999999),\n        vType: VerificationType.universalTxVerification,\n      } as unknown as never;\n\n      return { payload: universalPayload, gasAmount };\n    }\n  }\n\n  /********************************** HELPER FUNCTIONS **************************************************/\n\n  /**\n   * Transforms a TransactionReceipt to UniversalTxReceipt format\n   */\n  private transformToUniversalTxReceipt(\n    receipt: TransactionReceipt, // TransactionReceipt from viem\n    originalTxResponse: UniversalTxResponse\n  ): UniversalTxReceipt {\n    return {\n      // 1. Identity\n      hash: receipt.transactionHash,\n\n      // 2. Block Info\n      blockNumber: receipt.blockNumber,\n      blockHash: receipt.blockHash,\n      transactionIndex: receipt.transactionIndex,\n\n      // 3. Execution Context\n      from: originalTxResponse.from,\n      to: originalTxResponse.to,\n      contractAddress: receipt.contractAddress || null,\n\n      // 4. Gas & Usage\n      gasPrice: originalTxResponse.gasPrice || BigInt(0),\n      gasUsed: receipt.gasUsed,\n      cumulativeGasUsed: receipt.cumulativeGasUsed,\n\n      // 5. Logs\n      logs: receipt.logs || [],\n      logsBloom: receipt.logsBloom || '0x',\n\n      // 6. Outcome\n      status: receipt.status === 'success' ? 1 : 0,\n\n      // 7. Raw\n      raw: originalTxResponse.raw || {\n        from: originalTxResponse.from,\n        to: originalTxResponse.to,\n      },\n    };\n  }\n\n  /**\n   * Transforms a TxResponse to the new UniversalTxResponse format\n   */\n  private async transformToUniversalTxResponse(\n    tx: TxResponse\n  ): Promise<UniversalTxResponse> {\n    const chain = this.universalSigner.account.chain;\n    const { vm, chainId } = CHAIN_INFO[chain];\n    let from: `0x${string}`;\n    let to: `0x${string}`;\n    let value: bigint;\n    let data: string;\n    let rawTransactionData: {\n      from: string;\n      to: string;\n      nonce: number;\n      data: string;\n      value: bigint;\n    };\n\n    const ueaOrigin =\n      await PushChain.utils.account.convertExecutorToOriginAccount(\n        tx.to as `0x${string}`\n      );\n    let originAddress: string;\n\n    if (ueaOrigin.exists) {\n      if (!ueaOrigin.account) {\n        throw new Error('UEA origin account is null');\n      }\n      originAddress = ueaOrigin.account.address;\n      from = getAddress(tx.to as `0x${string}`);\n\n      let decoded;\n\n      if (tx.input !== '0x') {\n        decoded = decodeFunctionData({\n          abi: UEA_EVM,\n          data: tx.input,\n        });\n        if (!decoded?.args) {\n          throw new Error('Failed to decode function data');\n        }\n        const universalPayload = decoded?.args[0] as {\n          to: string;\n          value: bigint;\n          data: string;\n          gasLimit: bigint;\n          maxFeePerGas: bigint;\n          maxPriorityFeePerGas: bigint;\n          nonce: bigint;\n          deadline: bigint;\n          vType: number;\n        };\n\n        to = universalPayload.to as `0x${string}`;\n        value = BigInt(universalPayload.value);\n        data = universalPayload.data;\n        rawTransactionData = {\n          from: getAddress(tx.from),\n          to: getAddress(tx.to as `0x${string}`),\n          nonce: tx.nonce,\n          data: tx.input,\n          value: tx.value,\n        };\n      } else {\n        to = getAddress(tx.to as `0x${string}`);\n        value = tx.value;\n        data = tx.input;\n        rawTransactionData = {\n          from: getAddress(tx.from),\n          to: getAddress(tx.to as `0x${string}`),\n          nonce: tx.nonce,\n          data: tx.input,\n          value: tx.value,\n        };\n      }\n    } else {\n      originAddress = getAddress(tx.from);\n      from = getAddress(tx.from);\n      to = getAddress(tx.to as `0x${string}`);\n      value = tx.value;\n      data = tx.input;\n      rawTransactionData = {\n        from: getAddress(tx.from),\n        to: getAddress(tx.to as `0x${string}`),\n        nonce: tx.nonce,\n        data: tx.input,\n        value: tx.value,\n      };\n    }\n\n    const origin = `${VM_NAMESPACE[vm]}:${chainId}:${originAddress}`;\n\n    // Create signature from transaction r, s, v values\n    let signature: Signature;\n    try {\n      signature = {\n        r: tx.r || '0x0',\n        s: tx.s || '0x0',\n        v: typeof tx.v === 'bigint' ? Number(tx.v) : tx.v || 0,\n        yParity: tx.yParity,\n      };\n    } catch {\n      // Fallback signature if parsing fails\n      signature = {\n        r: '0x0000000000000000000000000000000000000000000000000000000000000000',\n        s: '0x0000000000000000000000000000000000000000000000000000000000000000',\n        v: 0,\n        yParity: 0,\n      };\n    }\n\n    // Determine transaction type and typeVerbose\n    let type = '99'; // universal\n    let typeVerbose = 'universal';\n\n    if (tx.type !== undefined) {\n      const txType = tx.type;\n      if (txType === 'eip1559') {\n        type = '2';\n        typeVerbose = 'eip1559';\n      } else if (txType === 'eip2930') {\n        type = '1';\n        typeVerbose = 'eip2930';\n      } else if (txType === 'legacy') {\n        type = '0';\n        typeVerbose = 'legacy';\n      } else if (txType == 'eip4844') {\n        type = '3';\n        typeVerbose = 'eip4844';\n      }\n    }\n\n    const universalTxResponse: UniversalTxResponse = {\n      // 1. Identity\n      hash: tx.hash,\n      origin,\n\n      // 2. Block Info\n      blockNumber: tx.blockNumber || BigInt(0),\n      blockHash: tx.blockHash || '',\n      transactionIndex: tx.transactionIndex || 0,\n      chainId,\n\n      // 3. Execution Context\n      from: from, // UEA (executor) address, checksummed for EVM\n      to: to || '',\n      nonce: tx.nonce,\n\n      // 4. Payload\n      data, // perceived calldata (was input)\n      value,\n\n      // 5. Gas\n      gasLimit: tx.gas || BigInt(0), // (was gas)\n      gasPrice: tx.gasPrice,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      accessList: Array.isArray(tx.accessList) ? [...tx.accessList] : [],\n\n      // 6. Utilities\n      wait: async (): Promise<UniversalTxReceipt> => {\n        const receipt = await tx.wait();\n        return this.transformToUniversalTxReceipt(receipt, universalTxResponse);\n      },\n\n      // 7. Metadata\n      type,\n      typeVerbose,\n      signature,\n\n      // 8. Raw Universal Fields\n      raw: rawTransactionData,\n    };\n\n    return universalTxResponse;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private bigintReplacer(_key: string, value: any) {\n    return typeof value === 'bigint'\n      ? value.toString() // convert BigInt to string\n      : value;\n  }\n\n  /**\n   * Checks if the given chain belongs to the Push Chain ecosystem.\n   * Used to differentiate logic for Push-native interactions vs external chains.\n   *\n   * @param chain - The chain identifier (e.g., PUSH_MAINNET, PUSH_TESTNET_DONUT)\n   * @returns True if the chain is a Push chain, false otherwise.\n   */\n  private isPushChain(chain: CHAIN): boolean {\n    return (\n      chain === CHAIN.PUSH_MAINNET ||\n      chain === CHAIN.PUSH_TESTNET_DONUT ||\n      chain === CHAIN.PUSH_LOCALNET\n    );\n  }\n\n  private validateMainnetConnection(chain: CHAIN) {\n    const isMainnet = [CHAIN.ETHEREUM_MAINNET, CHAIN.SOLANA_MAINNET].includes(\n      chain\n    );\n    if (\n      isMainnet &&\n      this.pushClient.pushChainInfo.chainId !==\n        CHAIN_INFO[CHAIN.PUSH_MAINNET].chainId\n    ) {\n      throw new Error('Mainnet chains can only interact with Push Mainnet');\n    }\n  }\n\n  private printLog(log: string): void {\n    if (this.printTraces) {\n      console.log(`[${this.constructor.name}] ${log}`);\n    }\n  }\n\n  private executeProgressHook(hookId: string, ...args: any[]): void {\n    const hookEntry = PROGRESS_HOOKS[hookId];\n    const hookPayload: ProgressEvent = hookEntry(...args);\n    this.printLog(hookPayload.message);\n    if (!this.progressHook) return;\n    // invoke the user-provided callback\n    this.progressHook(hookPayload);\n  }\n\n  // Derive the SVM gateway log index from a Solana transaction's log messages\n  private getSvmGatewayLogIndexFromTx(txResp: any): number {\n    const logs: string[] = (txResp?.meta?.logMessages || []) as string[];\n    if (!Array.isArray(logs) || logs.length === 0) return 0;\n\n    const prefix = 'Program data: ';\n    for (let i = 0; i < logs.length; i++) {\n      const log = logs[i] || '';\n      if (!log.startsWith(prefix)) continue;\n\n      const base64Data = log.slice(prefix.length).trim();\n      let decoded: Uint8Array | null = null;\n      try {\n        decoded = new Uint8Array(Buffer.from(base64Data, 'base64'));\n      } catch {\n        continue;\n      }\n\n      if (!decoded || decoded.length < 8) continue;\n      const discriminatorHex = bytesToHex(decoded.slice(0, 8)).slice(2);\n\n      // Skip add_funds discriminator; return the first other Program data event\n      // if (discriminatorHex === '7f1f6cffbb134644') continue;\n      if (discriminatorHex === '6c9ad829b5ea1d7c') return i;\n      // return i;\n    }\n\n    // Fallback to first log\n    return 0;\n  }\n\n  // Query Push Chain for UniversalTx status given an origin gateway tx (EVM or SVM)\n  private async queryUniversalTxStatusFromGatewayTx(\n    evmClient: EvmClient | undefined,\n    gatewayAddress: `0x${string}` | undefined,\n    txHash: string,\n    evmGatewayMethod: 'sendFunds' | 'sendTxWithFunds' | 'sendTxWithGas'\n  ): Promise<UniversalTx | undefined> {\n    try {\n      const chain = this.universalSigner.account.chain;\n      const { vm } = CHAIN_INFO[chain];\n\n      let logIndexStr = '0';\n      let txHashHex: `0x${string}` | string = txHash;\n\n      if (vm === VM.EVM) {\n        if (!evmClient || !gatewayAddress)\n          throw new Error('Missing EVM context');\n        let receipt;\n        try {\n          receipt = await evmClient.publicClient.getTransactionReceipt({\n            hash: txHash as `0x${string}`,\n          });\n        } catch {\n          // Receipt might not be indexed yet on this RPC; wait briefly for it\n          receipt = await evmClient.publicClient.waitForTransactionReceipt({\n            hash: txHash as `0x${string}`,\n            confirmations: 0,\n            timeout: CHAIN_INFO[chain].timeout,\n          });\n        }\n        const gatewayLogs = (receipt.logs || []).filter(\n          (l: any) =>\n            (l.address || '').toLowerCase() === gatewayAddress.toLowerCase()\n        );\n        const logIndexToUse = evmGatewayMethod === 'sendTxWithFunds' ? 1 : 0;\n        const firstLog = (gatewayLogs[logIndexToUse] ||\n          receipt.logs?.[logIndexToUse]) as any;\n        const logIndexVal = firstLog?.logIndex ?? 0;\n        logIndexStr =\n          typeof logIndexVal === 'bigint'\n            ? logIndexVal.toString()\n            : String(logIndexVal);\n      } else if (vm === VM.SVM) {\n        // Normalize Solana signature to 0x-hex for ID composition\n        let txSignature = txHash;\n        if (!txHash.startsWith('0x')) {\n          const decoded = utils.bytes.bs58.decode(txHash);\n          txHashHex = bytesToHex(new Uint8Array(decoded));\n        } else {\n          // When provided as hex, convert to base58 for RPC\n          const hex = txHash.slice(2);\n          const bytes = Uint8Array.from(Buffer.from(hex, 'hex'));\n          txSignature = utils.bytes.bs58.encode(bytes);\n        }\n\n        // Fetch transaction by initializing a Connection and calling Solana RPC\n        const rpcUrls: string[] =\n          this.rpcUrls[chain] || CHAIN_INFO[chain].defaultRPC;\n        const connection = new Connection(rpcUrls[0], 'confirmed');\n        const txResp = await connection.getTransaction(txSignature, {\n          maxSupportedTransactionVersion: 0,\n          commitment: 'confirmed',\n        } as any);\n        // Derive proper log index using discriminator matching\n        const svmLogIndex = this.getSvmGatewayLogIndexFromTx(txResp);\n        logIndexStr = String(svmLogIndex);\n      }\n\n      const sourceChain = `${VM_NAMESPACE[vm]}:${CHAIN_INFO[chain].chainId}`;\n\n      // ID = sha256(\"${sourceChain}:${txHash}:${logIndex}\") as hex string (no 0x)\n      const idInput = `${sourceChain}:${txHashHex}:${logIndexStr}`;\n      const idHex = sha256(stringToBytes(idInput)).slice(2);\n\n      // Fetch UniversalTx via gRPC with a brief retry window\n      let universalTxObj: any | undefined;\n      for (let attempt = 0; attempt < 15; attempt++) {\n        try {\n          const universalTxResp = await this.pushClient.getUniversalTxById(\n            idHex\n          );\n          universalTxObj = universalTxResp?.universalTx;\n          if (universalTxObj) break;\n        } catch (error) {\n          // ignore and retry\n          // console.log(error);\n        }\n        await new Promise((r) => setTimeout(r, 1500));\n      }\n\n      this.executeProgressHook(\n        PROGRESS_HOOK.SEND_TX_06_06,\n        universalTxObj?.universalStatus || universalTxObj?.universal_status\n      );\n      // this.printLog(\n      //   `UniversalTx fetched via gRPC: ${JSON.stringify(\n      //     {\n      //       gatewayTx: txHashHex,\n      //       id: idHex,\n      //       status:\n      //         universalTxObj?.universalStatus ||\n      //         universalTxObj?.universal_status,\n      //     },\n      //     this.bigintReplacer,\n      //     2\n      //   )}`\n      // );\n      return universalTxObj;\n    } catch {\n      // Best-effort; do not fail flow if PC query is unavailable\n      this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06_06);\n      return undefined;\n    }\n  }\n\n  // Emit countdown updates while waiting for EVM confirmations\n  private async waitForEvmConfirmationsWithCountdown(\n    evmClient: EvmClient,\n    txHash: `0x${string}`,\n    confirmations: number,\n    timeoutMs: number\n  ): Promise<void> {\n    // initial emit\n    this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06_03, confirmations);\n    const start = Date.now();\n\n    // Wait for receipt to get included block\n    const receipt = await evmClient.publicClient.waitForTransactionReceipt({\n      hash: txHash,\n    });\n    const targetBlock = receipt.blockNumber + BigInt(confirmations);\n\n    // Track last emitted confirmation to avoid duplicates\n    let lastEmitted = 0;\n\n    // Poll blocks and emit remaining confirmations\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBlock = await evmClient.publicClient.getBlockNumber();\n\n      // If already confirmed, emit progress for final confirmation\n      if (currentBlock >= targetBlock) {\n        // Only emit if we haven't already shown this confirmation\n        if (lastEmitted < confirmations) {\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_06_04,\n            confirmations,\n            confirmations\n          );\n        }\n        return;\n      }\n\n      const remaining = Number(targetBlock - currentBlock);\n      const completed = Math.max(1, confirmations - remaining + 1);\n\n      // Only emit if this is a new confirmation count\n      if (completed > lastEmitted) {\n        this.executeProgressHook(\n          PROGRESS_HOOK.SEND_TX_06_04,\n          completed,\n          confirmations\n        );\n        lastEmitted = completed;\n\n        // If we've reached required confirmations, we're done\n        if (completed >= confirmations) {\n          return;\n        }\n      }\n\n      if (Date.now() - start > timeoutMs) {\n        throw new Error(\n          `Timeout: transaction ${txHash} not confirmed with ${confirmations} confirmations within ${timeoutMs} ms`\n        );\n      }\n\n      await new Promise((r) => setTimeout(r, 12000));\n    }\n  }\n\n  // Emit countdown updates while waiting for SVM confirmations\n  private async waitForSvmConfirmationsWithCountdown(\n    svmClient: SvmClient,\n    txSignature: string,\n    confirmations: number,\n    timeoutMs: number\n  ): Promise<void> {\n    // initial emit\n    this.executeProgressHook(PROGRESS_HOOK.SEND_TX_06_03, confirmations);\n    const start = Date.now();\n\n    // Poll for confirmations and emit progress\n    let lastConfirmed = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const connection = (svmClient as any).connections[\n        (svmClient as any).currentConnectionIndex\n      ];\n      const { value } = await connection.getSignatureStatuses([txSignature]);\n      const status = value[0];\n\n      if (status) {\n        const currentConfirms = status.confirmations ?? 0;\n        const hasEnoughConfirmations = currentConfirms >= confirmations;\n        const isSuccessfullyFinalized =\n          status.err === null && status.confirmationStatus !== null;\n\n        // Emit progress if we have more confirmations than before OR if finalized\n        if (\n          currentConfirms > lastConfirmed ||\n          (isSuccessfullyFinalized && lastConfirmed === 0)\n        ) {\n          const confirmCount =\n            isSuccessfullyFinalized && currentConfirms === 0\n              ? confirmations\n              : currentConfirms;\n          this.executeProgressHook(\n            PROGRESS_HOOK.SEND_TX_06_04,\n            Math.max(1, confirmCount),\n            confirmations\n          );\n          lastConfirmed = currentConfirms;\n        }\n\n        if (hasEnoughConfirmations || isSuccessfullyFinalized) {\n          return;\n        }\n      }\n\n      if (Date.now() - start > timeoutMs) {\n        throw new Error(\n          `Timeout: transaction ${txSignature} not confirmed with ${confirmations} confirmations within ${timeoutMs} ms`\n        );\n      }\n\n      await new Promise((r) => setTimeout(r, 500));\n    }\n  }\n\n  // Fetch and cache UEA version from the contract on Push Chain\n  private async fetchUEAVersion(): Promise<string> {\n    if (this.ueaVersionCache) return this.ueaVersionCache;\n    const chain = this.universalSigner.account.chain;\n    const { vm } = CHAIN_INFO[chain];\n    const abi: Abi =\n      vm === VM.EVM ? (UEA_EVM as unknown as Abi) : (UEA_SVM as unknown as Abi);\n    const predictedUEA = this.computeUEAOffchain();\n    // Only attempt to read VERSION if UEA is deployed; otherwise default to 0.1.0\n    const code = await this.pushClient.publicClient.getCode({\n      address: predictedUEA,\n    });\n    if (code === undefined) {\n      this.ueaVersionCache = '0.1.0';\n      return '0.1.0';\n    }\n    const version = await this.pushClient.readContract<string>({\n      address: predictedUEA,\n      abi,\n      functionName: 'VERSION',\n    });\n    this.ueaVersionCache = version;\n    return version;\n  }\n\n  // Build EVM gas payment parameters when paying gas with an ERC-20 token\n  private async calculateGasAmountFromAmountOutMinETH(\n    gasTokenAddress: `0x${string}`,\n    amountOutMinETH: bigint | string\n  ): Promise<{\n    gasAmount: bigint;\n  }> {\n    const originChain = this.universalSigner.account.chain;\n    if (\n      originChain !== CHAIN.ETHEREUM_SEPOLIA &&\n      originChain !== CHAIN.ARBITRUM_SEPOLIA &&\n      originChain !== CHAIN.BASE_SEPOLIA\n    ) {\n      throw new Error(\n        'Gas payment in ERC-20 is supported only on Ethereum Sepolia, Arbitrum Sepolia, and Base Sepolia for now'\n      );\n    }\n\n    // Resolve WETH: prefer chain config, fallback to registry\n    const WETH = CHAIN_INFO[originChain].dex?.weth;\n    if (!WETH) throw new Error('WETH address not configured for this chain');\n\n    let gasAmount: bigint;\n    if (gasTokenAddress.toLowerCase() === WETH.toLowerCase()) {\n      gasAmount = BigInt(amountOutMinETH);\n    } else {\n      // Resolve token objects from registries\n      const fromList = PAYABLE_TOKENS[originChain] ?? [];\n      const fromToken: PayableToken | undefined = fromList.find(\n        (t) => (t.address || '').toLowerCase() === gasTokenAddress.toLowerCase()\n      );\n      const toList = (MOVEABLE_TOKENS[originChain] ?? []) as MoveableToken[];\n      const toToken: MoveableToken | undefined = toList.find(\n        (t) =>\n          t.symbol === 'WETH' ||\n          (t.address || '').toLowerCase() === (WETH || '').toLowerCase()\n      );\n\n      if (!fromToken || !toToken) {\n        throw new Error('Token not supported for quoting');\n      }\n\n      const targetOut = BigInt(amountOutMinETH);\n      const exactOutQuote = await this._quoteExactOutput(targetOut, {\n        from: fromToken,\n        to: toToken,\n      });\n      const requiredIn = BigInt(exactOutQuote.amountIn);\n      gasAmount = (requiredIn * BigInt(101)) / BigInt(100); // 1% safety margin\n    }\n\n    return { gasAmount };\n  }\n\n  private async calculateNativeAmountForDeposit(\n    chain: CHAIN,\n    requiredFunds: bigint,\n    ueaBalance: bigint\n  ): Promise<bigint> {\n    // Determine USD to deposit via gateway (8 decimals) with caps: min=$1, max=$10\n    const oneUsd = PushChain.utils.helpers.parseUnits('1', 8);\n    const tenUsd = PushChain.utils.helpers.parseUnits('10', 8);\n    const deficit =\n      requiredFunds > ueaBalance ? requiredFunds - ueaBalance : BigInt(0);\n    let depositUsd =\n      deficit > BigInt(0) ? this.pushClient.pushToUSDC(deficit) : oneUsd;\n\n    if (depositUsd < oneUsd) depositUsd = oneUsd;\n    if (depositUsd > tenUsd)\n      throw new Error('Deposit value exceeds max $10 worth of native token');\n\n    this.executeProgressHook(PROGRESS_HOOK.SEND_TX_02_02, depositUsd);\n\n    // If SVM, clamp depositUsd to on-chain Config caps\n    if (CHAIN_INFO[chain].vm === VM.SVM) {\n      const svmClient = new SvmClient({\n        rpcUrls:\n          this.rpcUrls[CHAIN.SOLANA_DEVNET] ||\n          CHAIN_INFO[CHAIN.SOLANA_DEVNET].defaultRPC,\n      });\n      const programId = new PublicKey(SVM_GATEWAY_IDL.address);\n      const [configPda] = PublicKey.findProgramAddressSync(\n        [stringToBytes('config')],\n        programId\n      );\n      try {\n        const cfg: any = await svmClient.readContract({\n          abi: SVM_GATEWAY_IDL,\n          address: SVM_GATEWAY_IDL.address,\n          functionName: 'config',\n          args: [configPda.toBase58()],\n        });\n        const minField =\n          cfg.minCapUniversalTxUsd ?? cfg.min_cap_universal_tx_usd;\n        const maxField =\n          cfg.maxCapUniversalTxUsd ?? cfg.max_cap_universal_tx_usd;\n        const minCapUsd = BigInt(minField.toString());\n        const maxCapUsd = BigInt(maxField.toString());\n        if (depositUsd < minCapUsd) depositUsd = minCapUsd;\n        // Add 20% safety margin to avoid BelowMinCap due to price drift\n        const withMargin = (minCapUsd * BigInt(12)) / BigInt(10);\n        if (depositUsd < withMargin) depositUsd = withMargin;\n        if (depositUsd > maxCapUsd) depositUsd = maxCapUsd;\n      } catch {\n        // best-effort; fallback to previous bounds if read fails\n      }\n    }\n\n    // Convert USD(8) -> native units using pricing path\n    const nativeTokenUsdPrice = await new PriceFetch(this.rpcUrls).getPrice(\n      chain\n    ); // 8 decimals\n    const nativeDecimals = CHAIN_INFO[chain].vm === VM.SVM ? 9 : 18;\n    const oneNativeUnit = PushChain.utils.helpers.parseUnits(\n      '1',\n      nativeDecimals\n    );\n    // Ceil division to avoid rounding below min USD on-chain\n    let nativeAmount =\n      (depositUsd * oneNativeUnit + (nativeTokenUsdPrice - BigInt(1))) /\n      nativeTokenUsdPrice;\n    // Add 1 unit safety to avoid BelowMinCap from rounding differences\n    nativeAmount = nativeAmount + BigInt(1);\n\n    return nativeAmount;\n  }\n}\n",
  "packages/core/src/lib/orchestrator/orchestrator.types.ts": "export type ExecuteParams = {\n  /**\n   * The target contract or account on Push Chain.\n   */\n  to: `0x${string}`;\n\n  /**\n   * Amount of native token (in wei) to send alongside the call.\n   */\n  value?: bigint;\n\n  /**\n   * Hex-encoded calldata or transfer payload.\n   * @reason Encodes the function selector + arguments (or plain transfer).\n   */\n  data?: `0x${string}` | MultiCall[];\n\n  /**\n   * Optional hard cap on gas to use for this transaction.\n   * @reason Prevents runaway gas consumption and lets users enforce limits.\n   */\n  gasLimit?: bigint;\n\n  /**\n   * Optional override for the EIP-1559 max fee per gas (in wei).\n   * @reason Gives callers direct control over total gas price to speed up or save cost.\n   */\n  maxFeePerGas?: bigint;\n\n  /**\n   * Optional override for the EIP-1559 max priority fee per gas (in wei).\n   * TODO: This will be removed\n   * @reason Allows customizing the miner tip separately from the base fee.\n   */\n  maxPriorityFeePerGas?: bigint;\n\n  /**\n   * Optional to bypass fee locking in case funds are already locked by user\n   */\n  feeLockTxHash?: string;\n\n  /**\n   * Optional explicit nonce for the transaction.\n   * @reason Ensures correct ordering and avoids replacement underpriced when sending in parallel.\n   */\n  nonce?: bigint;\n\n  /**\n   * Optional for signature expiry\n   */\n  deadline?: bigint;\n\n  /**\n   * Optional: pay gas in a specific token. If not provided, use `token` (bridge token) when present; otherwise, native token.\n   */\n  payGasWith?: {\n    token?: import('../constants').PayableToken; // e.g., client.payable.token.USDT\n    slippageBps?: number; // e.g., 100 = 1%\n    minAmountOut?: bigint | string; // optional min ETH out (wei)\n  };\n\n  /**\n   * Optional funds movement from origin chain to Push Chain (FUNDS_TX).\n   * When present and no calldata is provided, the SDK will bridge the specified\n   * ERC20 token amount to Push Chain using the Universal Gateway.\n   *\n   * Notes:\n   * - Currently supported only on Ethereum Sepolia\n   * - pay-with-token gas abstraction is NOT supported yet\n   */\n  funds?: {\n    amount: bigint; // smallest units of the token\n    token?: import('../constants').MoveableToken; // if omitted, defaults to native token for origin chain\n  };\n};\n\n/**\n * New Universal Transaction Receipt interface with prioritized field ordering\n */\nexport interface UniversalTxResponse {\n  // 1. Identity\n  hash: string; // tx hash\n  origin: string; // origin, e.g. \"eip155:1:0xabc\"\n\n  // 2. Block Info\n  blockNumber: bigint; // 803963n\n  blockHash: string; // block hash\n  transactionIndex: number; // index in block\n  chainId: string; // 42101 or solana\n\n  // 3. Execution Context\n  from: string; // UEA (executor) address\n  to: string; // the \"to\" the UEA executed\n  nonce: number; // derived (UEA) nonce\n\n  // 4. Payload\n  data: string; // perceived calldata (was input)\n  value: bigint; // perceived value\n\n  // 5. Gas\n  gasLimit: bigint; // 21000n (was gas)\n  gasPrice?: bigint; // for legacy txs\n  maxFeePerGas?: bigint; // for EIP-1559\n  maxPriorityFeePerGas?: bigint;\n  accessList: any[]; // AccessList type\n\n  // 6. Utilities\n  wait: () => Promise<UniversalTxReceipt>;\n\n  // 7. Metadata\n  type: string; // \"99\" (was typeHex), now string\n  typeVerbose: string; // \"universal\" (was type), human readable\n  signature: Signature; // ethers Signature instance\n\n  // 8. Raw Universal Fields (if you ever need them)\n  raw?: {\n    from: string; // what went on chain\n    to: string; // what went on chain\n    nonce: number; // the actual raw nonce\n    data: string; // the actual raw data (was input)\n    value: bigint; // the actual derived value\n  };\n}\n\n/**\n * New Universal Transaction Receipt interface for transaction receipts\n */\nexport interface UniversalTxReceipt {\n  // 1. Identity\n  hash: string; // changed from transactionHash\n\n  // 2. Block Info\n  blockNumber: bigint;\n  blockHash: string;\n  transactionIndex: number;\n\n  // 3. Execution Context\n  from: string; // should be the executor account of push chain\n  to: string; // should be the actual intended address of the tx\n  contractAddress: string | null;\n\n  // 4. Gas & Usage\n  gasPrice: bigint; // gasPrice should be gasPrice\n  gasUsed: bigint; // was cumulativeGasUsed\n  cumulativeGasUsed: bigint; // was gasUsed\n\n  // 5. Logs\n  logs: any[]; // Log[] type\n  logsBloom: string;\n\n  // 6. Outcome\n  status: 0 | 1; // 1 is success, 0 is failure - modeled after ethers\n\n  // 7. Raw\n  raw: {\n    from: string; // what happened on chain\n    to: string; // what happened on chain\n  };\n}\n\n/**\n * Signature interface modeled after ethers.js v6 Signature interface\n */\nexport interface Signature {\n  r: string;\n  s: string;\n  v: number;\n  yParity?: number;\n}\n\n/**\n * Call shape for multicall payloads\n */\nexport type MultiCall = {\n  to: `0x${string}`;\n  value: bigint;\n  data: `0x${string}`;\n};\n",
  "packages/core/src/lib/orchestrator/payload-builders.ts": "import { encodeFunctionData, isAddress } from 'viem';\nimport { PushChain } from '../push-chain/push-chain';\nimport { ERC20_EVM } from '../constants/abi';\nimport { MoveableToken } from '../constants/tokens';\nimport { ExecuteParams, MultiCall } from './orchestrator.types';\n\nexport function buildExecuteMulticall({\n  execute,\n  ueaAddress,\n}: {\n  execute: ExecuteParams;\n  ueaAddress: `0x${string}`;\n}): MultiCall[] {\n  const multicallData: MultiCall[] = [];\n  if (execute.value) {\n    multicallData.push({\n      to: execute.to,\n      value: execute.value,\n      data: '0x',\n    });\n  }\n  if (execute.funds?.amount) {\n    const erc20Transfer = encodeFunctionData({\n      abi: ERC20_EVM,\n      functionName: 'transfer',\n      args: [execute.to, execute.funds?.amount],\n    });\n    const token = (execute.funds as { token: MoveableToken }).token;\n    const pushChainTo = PushChain.utils.tokens.getPRC20Mapping(token);\n    multicallData.push({\n      to: pushChainTo,\n      value: BigInt(0),\n      data: erc20Transfer,\n    });\n  }\n  if (execute.data) {\n    // *************************\n    // Check for `execute.to`\n    // *************************\n\n    // For multicall, there is no validation for execute.to. Only if that's a valid EVM address\n    if (Array.isArray(execute.data)) {\n      if (!isAddress(execute.to))\n        throw new Error(`Invalid EVM address at execute.to ${execute.to}`);\n    } else {\n      // We can't execute payload against our UEA.\n      if (execute.to === ueaAddress)\n        throw new Error(`You can't execute data on the UEA address`);\n    }\n\n    if (Array.isArray(execute.data)) {\n      multicallData.push(...(execute.data as MultiCall[]));\n    } else {\n      multicallData.push({\n        to: execute.to,\n        value: BigInt(0),\n        data: execute.data as `0x${string}`,\n      });\n    }\n  }\n  return multicallData;\n}\n",
  "packages/core/src/lib/price-fetch/price-fetch.spec.ts": "import { PriceFetch } from './price-fetch';\nimport { CHAIN } from '../constants/enums';\n\ndescribe('PriceFetch', () => {\n  const priceFetcher = new PriceFetch();\n\n  it('fetches ETH/USDC price on Ethereum Sepolia', async () => {\n    const price = await priceFetcher.getPrice(CHAIN.ETHEREUM_SEPOLIA);\n    expect(typeof price).toBe('bigint');\n    console.log(price);\n    expect(price > BigInt(0)).toBe(true);\n  });\n\n  it('fetches SOL/USD price on Solana Devnet', async () => {\n    const price = await priceFetcher.getPrice(CHAIN.SOLANA_DEVNET);\n    expect(typeof price).toBe('bigint');\n    console.log(price);\n    expect(price > BigInt(0)).toBe(true);\n  });\n\n  it('throws for unsupported chains', async () => {\n    await expect(priceFetcher.getPrice(CHAIN.SOLANA_TESTNET)).rejects.toThrow(\n      `Locker contract not configured for chain: ${CHAIN.SOLANA_TESTNET}`\n    );\n  });\n});\n",
  "packages/core/src/lib/price-fetch/price-fetch.ts": "import { CHAIN, VM } from '../constants/enums';\nimport { CHAIN_INFO } from '../constants/chain';\nimport { EvmClient } from '../vm-client/evm-client';\nimport { FEE_LOCKER_EVM, FEE_LOCKER_SVM } from '../constants/abi';\nimport { Program } from '@coral-xyz/anchor';\nimport { Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { AnchorProvider } from '@coral-xyz/anchor';\nimport { BN } from '@coral-xyz/anchor';\n\nexport class PriceFetch {\n  constructor(\n    private readonly rpcUrls: Partial<Record<CHAIN, string[]>> = {}\n  ) {}\n\n  async getPrice(chain: CHAIN): Promise<bigint> {\n    const rpcUrls: string[] =\n      this.rpcUrls[chain] || CHAIN_INFO[chain].defaultRPC;\n\n    const vm = CHAIN_INFO[chain].vm;\n    const { lockerContract } = CHAIN_INFO[chain];\n    if (!lockerContract) {\n      throw new Error(`Locker contract not configured for chain: ${chain}`);\n    }\n\n    switch (vm) {\n      case VM.EVM: {\n        const evmClient = new EvmClient({ rpcUrls });\n\n        const result = await evmClient.readContract<[bigint, number]>({\n          abi: FEE_LOCKER_EVM,\n          address: lockerContract as `0x${string}`,\n          functionName: 'getEthUsdPrice_old',\n        });\n\n        const [price] = result;\n        return price;\n      }\n      case VM.SVM: {\n        const PRICE_ACCOUNT = new PublicKey(\n          '7UVimffxr9ow1uXYxsr4LHAcV58mLzhmwaeKvJ1pjLiE'\n        );\n\n        const connection = new Connection(rpcUrls[0], 'confirmed');\n        const provider = new AnchorProvider(\n          connection,\n          {\n            publicKey: new PublicKey(\n              'EfQYRThwBu4MsU7Lf3D2e68tCtdwfYj6f66ot1e2HNrq'\n            ),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } as any,\n          { commitment: 'confirmed' }\n        );\n\n        const program = new Program(FEE_LOCKER_SVM, provider);\n\n        const result = await program.methods['getSolPrice']()\n          .accounts({\n            priceUpdate: PRICE_ACCOUNT,\n          })\n          .view();\n\n        if (!result || !result.price) {\n          throw new Error('Invalid price data returned');\n        }\n\n        // Exponent on this function is always NEGATIVE\n        const price = (result.price as BN).toNumber();\n        return BigInt(price);\n      }\n      default: {\n        throw new Error(`Unsupported VM ${vm}`);\n      }\n    }\n  }\n}\n",
  "packages/core/src/lib/progress-hook/progress-hook.ts": "import { UniversalTxResponse } from '../orchestrator/orchestrator.types';\nimport { Utils } from '../utils';\nimport {\n  PROGRESS_HOOK,\n  ProgressEventFunction,\n  ProgressEventFunctionWithoutTimestamp,\n} from './progress-hook.types';\n\n// Helper to wrap a hook function with timestamp\nconst withTimestamp = (\n  fn: ProgressEventFunctionWithoutTimestamp\n): ProgressEventFunction => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (...args: any[]) => ({\n    ...fn(...args),\n    timestamp: new Date().toISOString(),\n  });\n};\n\nconst RAW_HOOKS: {\n  [K in PROGRESS_HOOK]: ProgressEventFunctionWithoutTimestamp;\n} = {\n  [PROGRESS_HOOK.SEND_TX_01]: (originChain: string) => ({\n    id: PROGRESS_HOOK.SEND_TX_01,\n    title: 'Origin Chain Detected',\n    message: `Origin chain: ${originChain}`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_02_01]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_02_01,\n    title: 'Estimating Gas',\n    message: 'Estimating and fetching gas limit, gas price for Tx',\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_02_02]: (executionCost: bigint) => ({\n    id: PROGRESS_HOOK.SEND_TX_02_02,\n    title: 'Gas Estimated',\n    message: `Total execution cost (Gas cost + value): ${executionCost} UPC`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_03_01]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_03_01,\n    title: 'Resolving UAE',\n    message:\n      'Resolving Execution Account (UEA) - Compunting address, checking deployment status, nonce and balance',\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_03_02]: (\n    ueaAddress: `0x${string}`,\n    deployed: boolean\n  ) => ({\n    id: PROGRESS_HOOK.SEND_TX_03_02,\n    title: 'UEA Resolved',\n    message: `UEA: ${ueaAddress}, Deployed: ${deployed}`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_04_01]: (hash: string) => ({\n    id: PROGRESS_HOOK.SEND_TX_04_01,\n    title: 'Awaiting Signature for Tx Execution',\n    message: `Universal Payload Hash: ${hash}`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_04_02]: (signature: string) => ({\n    id: PROGRESS_HOOK.SEND_TX_04_02,\n    title: 'Signature Completed',\n    message: `Signature: ${signature}`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  // V2 Payload flow\n  [PROGRESS_HOOK.SEND_TX_04_03]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_04_03,\n    title: 'Verification Success',\n    message: 'Verification completed via Transaction or Signature',\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_04_04]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_04_04,\n    title: 'Verification Declined',\n    message: 'Verification declined by user',\n    response: null,\n    level: 'ERROR',\n  }),\n  [PROGRESS_HOOK.SEND_TX_05_01]: (feeAmount: bigint) => ({\n    id: PROGRESS_HOOK.SEND_TX_05_01,\n    title: 'Locking Origin Chain Fee',\n    message: `Locking fee: ${feeAmount.toString()} UPC on origin chain`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_05_02]: (txHash: string, confirmations: number) => ({\n    id: PROGRESS_HOOK.SEND_TX_05_02,\n    title: 'Awaiting Origin Chain Confirmations',\n    message: `Tx sent: ${txHash}, waiting for ${confirmations} confirmations.`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_05_03]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_05_03,\n    title: 'Confirmations Received',\n    message: 'Required confirmations received.',\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_06,\n    title: 'Broadcasting to Push Chain',\n    message: 'Sending Tx to Push Chain',\n    response: null,\n    level: 'INFO',\n  }),\n  // V2 Funds flow\n  [PROGRESS_HOOK.SEND_TX_06_01]: (\n    amount: bigint,\n    decimals: number,\n    symbol: string\n  ) => ({\n    id: PROGRESS_HOOK.SEND_TX_06_01,\n    title: 'Preparing Funds Transfer',\n    message: `Preparing to move ${Utils.helpers.formatUnits(\n      amount,\n      decimals\n    )} ${symbol} from origin chain`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06_02]: (\n    txHash: string,\n    amount: bigint,\n    decimals: number,\n    symbol: string\n  ) => ({\n    id: PROGRESS_HOOK.SEND_TX_06_02,\n    title: 'Funds Lock Submitted',\n    message: `Locking ${Utils.helpers.formatUnits(\n      amount,\n      decimals\n    )} ${symbol} for transfer (Tx hash: ${txHash})`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06_03]: (required: number) => ({\n    id: PROGRESS_HOOK.SEND_TX_06_03,\n    title: 'Awaiting Confirmations',\n    message: `Waiting for ${required} confirmations`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06_04]: (current: number, required: number) => ({\n    id: PROGRESS_HOOK.SEND_TX_06_04,\n    title: `Confirmation ${current}/${required} Received`,\n    message: `${current}/${required} confirmations received`,\n    response: null,\n    level: 'INFO',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06_06]: () => ({\n    id: PROGRESS_HOOK.SEND_TX_06_06,\n    title: 'Funds Confirmed',\n    message: `Origin chain lock confirmed`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_06_07]: (\n    amount: bigint,\n    decimals: number,\n    symbol: string\n  ) => ({\n    id: PROGRESS_HOOK.SEND_TX_06_07,\n    title: 'Funds Credited on Push Chain',\n    message: `Funds credited: ${Utils.helpers.formatUnits(\n      amount,\n      decimals\n    )} ${symbol} (minus fees)`,\n    response: null,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_99_01]: (txResponse: UniversalTxResponse[]) => ({\n    id: PROGRESS_HOOK.SEND_TX_99_01,\n    title: 'Push Chain Tx Success',\n    message: `Final Tx Hash: ${txResponse[txResponse.length - 1].hash}`,\n    response: txResponse,\n    level: 'SUCCESS',\n  }),\n  [PROGRESS_HOOK.SEND_TX_99_02]: (errMessage: string) => ({\n    id: PROGRESS_HOOK.SEND_TX_99_02,\n    title: 'Push Chain Tx Failed',\n    message: errMessage,\n    response: null,\n    level: 'ERROR',\n  }),\n};\n\n// Build final hooks with timestamp injection\nconst PROGRESS_HOOKS: Record<string, ProgressEventFunction> =\n  Object.fromEntries(\n    Object.entries(RAW_HOOKS).map(([key, value]) => [key, withTimestamp(value)])\n  );\n\nexport default PROGRESS_HOOKS;\n",
  "packages/core/src/lib/progress-hook/progress-hook.types.ts": "export type ProgressEvent = {\n  id: string;\n  title: string;\n  message: string;\n  level: 'INFO' | 'SUCCESS' | 'WARNING' | 'ERROR';\n  response: null | object;\n  timestamp: string; // ISO-8601, e.g. \"2025-06-26T15:04:05.000Z\"\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ProgressEventFunction = (...args: any[]) => ProgressEvent;\n\nexport type ProgressEventFunctionWithoutTimestamp = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: any[]\n) => Omit<ProgressEvent, 'timestamp'>;\n\nexport enum PROGRESS_HOOK {\n  SEND_TX_01 = 'SEND-TX-01',\n  SEND_TX_02_01 = 'SEND-TX-02-01',\n  SEND_TX_02_02 = 'SEND-TX-02-02',\n  SEND_TX_03_01 = 'SEND-TX-03-01',\n  SEND_TX_03_02 = 'SEND-TX-03-02',\n  SEND_TX_04_01 = 'SEND-TX-04-01',\n  SEND_TX_04_02 = 'SEND-TX-04-02',\n  // V2 funds flow additions\n  SEND_TX_04_03 = 'SEND-TX-04-03',\n  SEND_TX_04_04 = 'SEND-TX-04-04',\n  SEND_TX_05_01 = 'SEND-TX-05-01',\n  SEND_TX_05_02 = 'SEND-TX-05-02',\n  SEND_TX_05_03 = 'SEND-TX-05-03',\n  // Broadcasting to Push Chain (existing)\n  SEND_TX_06 = 'SEND-TX-06',\n  // Funds flow granularity (origin chain)\n  SEND_TX_06_01 = 'SEND-TX-06-01',\n  SEND_TX_06_02 = 'SEND-TX-06-02',\n  SEND_TX_06_03 = 'SEND-TX-06-03',\n  SEND_TX_06_04 = 'SEND-TX-06-04',\n  SEND_TX_06_06 = 'SEND-TX-06-06',\n  SEND_TX_06_07 = 'SEND-TX-06-07',\n  SEND_TX_99_01 = 'SEND-TX-99-01',\n  SEND_TX_99_02 = 'SEND-TX-99-02',\n}\n",
  "packages/core/src/lib/push-chain/helpers/abis.ts": "export const COUNTER_ABI_PAYABLE = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'uint256',\n        name: 'countPC',\n        type: 'uint256',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'caller',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'value',\n        type: 'uint256',\n      },\n    ],\n    name: 'CountIncremented',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'increment',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'reset',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    stateMutability: 'payable',\n    type: 'receive',\n  },\n  {\n    inputs: [],\n    name: 'countPC',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getBalance',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n];\n",
  "packages/core/src/lib/push-chain/helpers/addresses.ts": "export const COUNTER_ADDRESS_PAYABLE =\n  '0x70d8f7a0fF8e493fb9cbEE19Eb780E40Aa872aaf' as `0x${string}`;\n",
  "packages/core/src/lib/push-chain/push-chain.spec.ts": "import { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';\nimport { COUNTER_ABI_PAYABLE } from './helpers/abis';\nimport { COUNTER_ADDRESS_PAYABLE } from './helpers/addresses';\nimport bs58 from 'bs58';\nimport {\n  UniversalSigner,\n  UniversalAccount,\n} from '../universal/universal.types';\nimport { PushChain } from './push-chain';\nimport {\n  createWalletClient,\n  createPublicClient,\n  defineChain,\n  http,\n  isAddress,\n  verifyMessage,\n  parseAbi,\n  PrivateKeyAccount,\n} from 'viem';\nimport { sepolia, arbitrumSepolia, baseSepolia, bscTestnet } from 'viem/chains';\nimport { keccak256, toBytes } from 'viem';\nimport { ExecuteParams, MultiCall } from '../orchestrator/orchestrator.types';\nimport { CHAIN_INFO, SYNTHETIC_PUSH_ERC20 } from '../constants/chain';\nimport { CHAIN } from '../constants/enums';\nimport {\n  Keypair,\n  PublicKey,\n  Connection,\n  Transaction,\n  SystemProgram,\n  SendTransactionError,\n} from '@solana/web3.js';\nimport { utils as anchorUtils } from '@coral-xyz/anchor';\nimport { EvmClient } from '../vm-client/evm-client';\nimport dotenv from 'dotenv';\nimport path from 'path';\n\n// Load environment variables from packages/core/.env\n// Try multiple possible paths to handle different execution contexts\ndotenv.config({ path: path.resolve(process.cwd(), 'packages/core/.env') }) ||\n  dotenv.config({ path: path.resolve(__dirname, '../../.env') });\nconst EVM_RPC =\n  process.env['EVM_RPC'] || CHAIN_INFO[CHAIN.ETHEREUM_SEPOLIA].defaultRPC[0];\nconst ARBITRUM_SEPOLIA_RPC =\n  process.env['ARBITRUM_SEPOLIA_RPC'] ||\n  CHAIN_INFO[CHAIN.ARBITRUM_SEPOLIA].defaultRPC[0];\nconst BASE_SEPOLIA_RPC =\n  process.env['BASE_SEPOLIA_RPC'] ||\n  CHAIN_INFO[CHAIN.BASE_SEPOLIA].defaultRPC[0];\nconst BNB_TESTNET_RPC =\n  process.env['BNB_TESTNET_RPC'] || CHAIN_INFO[CHAIN.BNB_TESTNET].defaultRPC[0];\nconst SOLANA_RPC =\n  process.env['SOLANA_RPC_URL'] ||\n  CHAIN_INFO[CHAIN.SOLANA_DEVNET].defaultRPC[0];\n\n// EVM Chain Test Configuration\ninterface EVMChainTestConfig {\n  name: string;\n  chain: CHAIN;\n  viemChain:\n    | typeof sepolia\n    | typeof arbitrumSepolia\n    | typeof baseSepolia\n    | typeof bscTestnet;\n  rpcUrl: string;\n  gatewayAddress: string;\n  tokens: {\n    usdt: {\n      address: string;\n      decimals: number;\n    };\n    eth: {\n      decimals: number;\n    };\n  };\n}\n\nconst EVM_CHAIN_CONFIGS: EVMChainTestConfig[] = [\n  {\n    name: 'Ethereum Sepolia',\n    chain: CHAIN.ETHEREUM_SEPOLIA,\n    viemChain: sepolia,\n    rpcUrl: EVM_RPC,\n    gatewayAddress: '0x05bD7a3D18324c1F7e216f7fBF2b15985aE5281A',\n    tokens: {\n      usdt: {\n        address: '0x7169D38820dfd117C3FA1f22a697dBA58d90BA06',\n        decimals: 6,\n      },\n      eth: {\n        decimals: 18,\n      },\n    },\n  },\n  {\n    name: 'Arbitrum Sepolia',\n    chain: CHAIN.ARBITRUM_SEPOLIA,\n    viemChain: arbitrumSepolia,\n    rpcUrl: ARBITRUM_SEPOLIA_RPC,\n    gatewayAddress: '0x2cd870e0166Ba458dEC615168Fd659AacD795f34',\n    tokens: {\n      usdt: {\n        address: '0x1419d7C74D234fA6B73E06A2ce7822C1d37922f0',\n        decimals: 6,\n      },\n      eth: {\n        decimals: 18,\n      },\n    },\n  },\n  {\n    name: 'Base Sepolia',\n    chain: CHAIN.BASE_SEPOLIA,\n    viemChain: baseSepolia,\n    rpcUrl: BASE_SEPOLIA_RPC,\n    gatewayAddress: '0xe91addb5a01b4fb4ac2599b171f56e765fc8903c',\n    tokens: {\n      usdt: {\n        address: '0x9FF5a186f53F6E6964B00320Da1D2024DE11E0cB',\n        decimals: 6,\n      },\n      eth: {\n        decimals: 18,\n      },\n    },\n  },\n  {\n    name: 'BNB Testnet',\n    chain: CHAIN.BNB_TESTNET,\n    viemChain: bscTestnet,\n    rpcUrl: BNB_TESTNET_RPC,\n    gatewayAddress: '0x44aFFC61983F4348DdddB886349eb992C061EaC0',\n    tokens: {\n      usdt: {\n        address: '0xBC14F348BC9667be46b35Edc9B68653d86013DC5',\n        decimals: 6,\n      },\n      eth: {\n        decimals: 18,\n      },\n    },\n  },\n];\n\n// Reusable test helper functions\nasync function setupEVMChainClient(\n  config: EVMChainTestConfig,\n  privateKey: `0x${string}`\n): Promise<{ client: PushChain; account: PrivateKeyAccount }> {\n  const account = privateKeyToAccount(privateKey);\n  const walletClient = createWalletClient({\n    account,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n    walletClient,\n    {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    }\n  );\n\n  const client = await PushChain.initialize(signer, {\n    network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n    progressHook: (progress) =>\n      console.log(`[${config.name}] Progress:`, progress),\n    rpcUrls: {\n      [config.chain]: [config.rpcUrl],\n    },\n  });\n\n  return { client, account };\n}\n\nasync function testSendFundsUSDTNoValue(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig\n): Promise<void> {\n  const erc20Abi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const usdt = client.moveable.token.USDT;\n\n  const balance: bigint = await new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  }).readContract<bigint>({\n    abi: erc20Abi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n\n  if (balance <= BigInt(0)) {\n    console.warn(`Skipping ${config.name} USDT test: no USDT balance`);\n    return;\n  }\n\n  const amount = BigInt(1);\n  // const recipient = '0x0000000000000000000000000000000000042101';\n  const recipient = client.universal.account;\n\n  // pUSDT (USDT.eth) balance on Push chain should increase for the recipient\n  const pushChainClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceBefore = await pushChainClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: recipient as `0x${string}`,\n  });\n\n  const resUSDT = await client.universal.sendTransaction({\n    to: recipient,\n    funds: { amount, token: usdt },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  const receipt = await resUSDT.wait();\n  expect(receipt.status).toBe(1);\n\n  const balanceAfter = await pushChainClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: recipient as `0x${string}`,\n  });\n  expect(balanceAfter > balanceBefore).toBe(true);\n}\n\nasync function testSendFundsUSDTWithValue(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n  const erc20Abi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const usdt = client.moveable.token.USDT;\n\n  const balance: bigint = await new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  }).readContract<bigint>({\n    abi: erc20Abi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n\n  if (balance <= BigInt(0)) {\n    console.warn(`Skipping ${config.name} USDT test: no USDT balance`);\n    return;\n  }\n\n  const amount = BigInt(1);\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self') recipient = client.universal.account;\n  else recipient = '0x0000000000000000000000000000000000042101';\n\n  // pUSDT (USDT.eth) balance on Push chain should increase for the recipient\n  const pushChainClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceUSDTBefore = await pushChainClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: recipient,\n  });\n  const balancePCBefore = await pushChainClient.getBalance(recipient);\n\n  // What to expect from this:\n  // *************************\n  // recipient PC balance ++\n  // recipient USDT balance ++\n  // *************************\n  const resUSDT = await client.universal.sendTransaction({\n    to: recipient,\n    value: BigInt(3),\n    funds: { amount, token: usdt },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  const receipt = await resUSDT.wait();\n  expect(receipt.status).toBe(1);\n\n  const balanceUSDTAfter = await pushChainClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: recipient as `0x${string}`,\n  });\n  const balancePCAfter = await pushChainClient.getBalance(recipient);\n  expect(balancePCAfter > balancePCBefore).toBe(true);\n  expect(balanceUSDTAfter > balanceUSDTBefore).toBe(true);\n}\n\nasync function testSendFundsETH(\n  client: PushChain,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  const amount = BigInt(1);\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self') recipient = client.universal.account;\n  else recipient = '0x0000000000000000000000000000000000042101';\n\n  // pETH balance on Push chain should increase for the recipient after bridging\n  const pushChainClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const pETH_ADDRESS =\n    SYNTHETIC_PUSH_ERC20[PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT].pETH;\n\n  const balanceBefore = await pushChainClient.getErc20Balance({\n    tokenAddress: pETH_ADDRESS,\n    ownerAddress: recipient,\n  });\n\n  // THIS WILL FAIL IF RECIPIENT IS ANY OTHER CONTRACT OTHER THAN UEA!. CURRENTLY WE DON'T SUPPORT FUNDS.ETHER\n  const resNative = await client.universal.sendTransaction({\n    to: recipient,\n    funds: { amount },\n  });\n  console.log('txHash', resNative.hash);\n\n  const receipt = await resNative.wait();\n  expect(receipt.status).toBe(1);\n\n  const balanceAfter = await pushChainClient.getErc20Balance({\n    tokenAddress: pETH_ADDRESS,\n    ownerAddress: recipient,\n  });\n  expect(balanceAfter > balanceBefore).toBe(true);\n}\n\nasync function testFundsUSDTNoValueNewWalletDeployUEA(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n\n  // Set up funded wallet client from the provided account (origin: Sepolia)\n  const walletClientFunded = createWalletClient({\n    account,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Create a brand-new account and wallet client (origin: Sepolia)\n  const newAccount = privateKeyToAccount(generatePrivateKey());\n  const walletClientNew = createWalletClient({\n    account: newAccount,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const publicClient = createPublicClient({\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Fund new account with native Ether on Sepolia\n  const nativeTxHash = await walletClientFunded.sendTransaction({\n    to: newAccount.address,\n    chain: config.viemChain,\n    value: PushChain.utils.helpers.parseUnits('0.00031', 18),\n  });\n  await publicClient.waitForTransactionReceipt({ hash: nativeTxHash });\n\n  // Ensure the funding account has USDT, otherwise skip\n  const erc20ReadAbi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const ERC20_TRANSFER_ABI = [\n    {\n      inputs: [\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n      ],\n      name: 'transfer',\n      outputs: [{ type: 'bool' }],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n  ];\n  const usdt = client.moveable.token.USDT;\n  const evm = new EvmClient({ rpcUrls: CHAIN_INFO[config.chain].defaultRPC });\n  const funderUsdtBal: bigint = await evm.readContract<bigint>({\n    abi: erc20ReadAbi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n  if (funderUsdtBal === BigInt(0)) {\n    console.warn(\n      `Skipping ${config.name} USDT sendTxWithFunds: no USDT balance`\n    );\n    return;\n  }\n\n  // Transfer 1 USDT to the new account on Sepolia\n  const transferData = PushChain.utils.helpers.encodeTxData({\n    abi: ERC20_TRANSFER_ABI,\n    functionName: 'transfer',\n    args: [\n      newAccount.address,\n      PushChain.utils.helpers.parseUnits('1', usdt.decimals),\n    ],\n  });\n  const usdtTxHash = await walletClientFunded.sendTransaction({\n    to: usdt.address as `0x${string}`,\n    chain: config.viemChain,\n    value: BigInt(0),\n    data: transferData,\n  });\n  await publicClient.waitForTransactionReceipt({ hash: usdtTxHash });\n\n  // Initialize PushChain client from the NEW wallet\n  const universalSignerNew =\n    await PushChain.utils.signer.toUniversalFromKeypair(walletClientNew, {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    });\n  const pushClientNew = await PushChain.initialize(universalSignerNew, {\n    network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n    rpcUrls: { [config.chain]: [config.rpcUrl] },\n    progressHook: (progress) => console.log(progress),\n  });\n\n  // Prepare target contract call on Push Chain\n  const bridgeAmount = BigInt(1);\n  const COUNTER_ADDRESS =\n    '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  // Push EVM client and executor info for NEW account\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const executorInfo = await PushChain.utils.account.convertOriginToExecutor(\n    universalSignerNew.account,\n    { onlyCompute: true }\n  );\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceBefore_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceBefore_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  // Log origin chain balances (ETH and USDT) before executing universal.sendTransaction\n  const etherBalanceBefore = await publicClient.getBalance({\n    address: newAccount.address,\n  });\n  const usdtBalanceBefore = await evm.readContract<bigint>({\n    abi: erc20ReadAbi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [newAccount.address],\n  });\n  console.log(\n    `Origin balances before universal.sendTransaction  ETH: ${PushChain.utils.helpers.formatUnits(\n      etherBalanceBefore,\n      18\n    )}, USDT: ${PushChain.utils.helpers.formatUnits(\n      usdtBalanceBefore,\n      usdt.decimals\n    )}`\n  );\n\n  if (transactionRecipient === 'self') {\n    await expect(\n      pushClientNew.universal.sendTransaction({\n        to: pushClientNew.universal.account,\n        value: BigInt(0),\n        funds: {\n          amount: bridgeAmount,\n          token: pushClientNew.moveable.token.USDT,\n        },\n      })\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n\n  const resUSDT = await pushClientNew.universal.sendTransaction({\n    to: COUNTER_ADDRESS,\n    value: BigInt(0),\n    funds: { amount: bridgeAmount, token: pushClientNew.moveable.token.USDT },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  expect(typeof resUSDT.hash).toBe('string');\n  expect(resUSDT.hash.startsWith('0x')).toBe(true);\n  await resUSDT.wait();\n\n  // Wait briefly for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const balanceAfter_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceAfter_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  // UEA USDT balance unchanged, Counter balance increased, counter incremented\n  expect(balanceAfter_pUSDT_UEA === balanceBefore_pUSDT_UEA).toBe(true);\n  expect(balanceAfter_pUSDT_COUNTER > balanceBefore_pUSDT_COUNTER).toBe(true);\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\nasync function testSendFundsWithPayloadUSDTWithValueNewWalletDeployUEA(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n\n  // Set up funded wallet client from the provided account (origin: Sepolia)\n  const walletClientFunded = createWalletClient({\n    account,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Create a brand-new account and wallet client (origin: Sepolia)\n  const newAccount = privateKeyToAccount(generatePrivateKey());\n  const walletClientNew = createWalletClient({\n    account: newAccount,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const publicClient = createPublicClient({\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Fund new account with native Ether on Sepolia\n  const nativeTxHash = await walletClientFunded.sendTransaction({\n    to: newAccount.address,\n    chain: config.viemChain,\n    value: PushChain.utils.helpers.parseUnits('0.00031', 18),\n  });\n  await publicClient.waitForTransactionReceipt({ hash: nativeTxHash });\n\n  // Ensure the funding account has USDT, otherwise skip\n  const erc20ReadAbi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const ERC20_TRANSFER_ABI = [\n    {\n      inputs: [\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n      ],\n      name: 'transfer',\n      outputs: [{ type: 'bool' }],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n  ];\n  const usdt = client.moveable.token.USDT;\n  const evm = new EvmClient({ rpcUrls: CHAIN_INFO[config.chain].defaultRPC });\n  const funderUsdtBal: bigint = await evm.readContract<bigint>({\n    abi: erc20ReadAbi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n  if (funderUsdtBal === BigInt(0)) {\n    console.warn(\n      `Skipping ${config.name} USDT sendTxWithFunds: no USDT balance`\n    );\n    return;\n  }\n\n  // Transfer 1 USDT to the new account on Sepolia\n  const transferData = PushChain.utils.helpers.encodeTxData({\n    abi: ERC20_TRANSFER_ABI,\n    functionName: 'transfer',\n    args: [\n      newAccount.address,\n      PushChain.utils.helpers.parseUnits('1', usdt.decimals),\n    ],\n  });\n  const usdtTxHash = await walletClientFunded.sendTransaction({\n    to: usdt.address as `0x${string}`,\n    chain: config.viemChain,\n    value: BigInt(0),\n    data: transferData,\n  });\n  await publicClient.waitForTransactionReceipt({ hash: usdtTxHash });\n\n  // Initialize PushChain client from the NEW wallet\n  const universalSignerNew =\n    await PushChain.utils.signer.toUniversalFromKeypair(walletClientNew, {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    });\n  const pushClientNew = await PushChain.initialize(universalSignerNew, {\n    network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n    rpcUrls: { [config.chain]: [config.rpcUrl] },\n    progressHook: (progress) => console.log(progress),\n  });\n\n  // Prepare target contract call on Push Chain\n  const bridgeAmount = BigInt(1);\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n  const bytecode = await pushPublicClient.getBytecode({\n    address: COUNTER_ADDRESS_PAYABLE,\n  });\n  if (!bytecode || bytecode === '0x') {\n    console.warn(\n      `Skipping ${config.name}: no contract at ${COUNTER_ADDRESS_PAYABLE}`\n    );\n    return;\n  }\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  // Push EVM client and executor info for NEW account\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const executorInfo = await PushChain.utils.account.convertOriginToExecutor(\n    universalSignerNew.account,\n    { onlyCompute: true }\n  );\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceBefore_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceBefore_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS_PAYABLE,\n  });\n\n  // Get native Push Chain balance before transaction\n  const balanceBeforePC_COUNTER = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  // Log origin chain balances (ETH and USDT) before executing universal.sendTransaction\n  const etherBalanceBefore = await publicClient.getBalance({\n    address: newAccount.address,\n  });\n  const usdtBalanceBefore = await evm.readContract<bigint>({\n    abi: erc20ReadAbi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [newAccount.address],\n  });\n  console.log(\n    `Origin balances before universal.sendTransaction  ETH: ${PushChain.utils.helpers.formatUnits(\n      etherBalanceBefore,\n      18\n    )}, USDT: ${PushChain.utils.helpers.formatUnits(\n      usdtBalanceBefore,\n      usdt.decimals\n    )}`\n  );\n\n  if (transactionRecipient === 'self') {\n    await expect(\n      pushClientNew.universal.sendTransaction({\n        to: pushClientNew.universal.account,\n        value: BigInt(0),\n        data,\n        funds: {\n          amount: bridgeAmount,\n          token: pushClientNew.moveable.token.USDT,\n        },\n      })\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n\n  const resUSDT = await pushClientNew.universal.sendTransaction({\n    to: COUNTER_ADDRESS_PAYABLE,\n    value: BigInt(10),\n    data,\n    funds: { amount: bridgeAmount, token: pushClientNew.moveable.token.USDT },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  expect(typeof resUSDT.hash).toBe('string');\n  expect(resUSDT.hash.startsWith('0x')).toBe(true);\n  await resUSDT.wait();\n\n  // Wait briefly for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const balanceAfter_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceAfter_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS_PAYABLE,\n  });\n\n  // Get native Push Chain balance after transaction\n  const balanceAfterPC_COUNTER = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  // UEA USDT balance unchanged, Counter balance increased, counter incremented\n  expect(balanceAfter_pUSDT_UEA === balanceBefore_pUSDT_UEA).toBe(true);\n  expect(balanceAfter_pUSDT_COUNTER > balanceBefore_pUSDT_COUNTER).toBe(true);\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  // Native Push Chain balance on COUNTER_ADDRESS_PAYABLE increased by the value amount (10)\n  expect(balanceAfterPC_COUNTER).toBe(balanceBeforePC_COUNTER + BigInt(10));\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\n// SVM: Similar to the above, but using a brand-new Solana wallet and bridging SOL\nasync function testFundsSOLNoValueNewWalletDeployUEA_SVM(\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n\n  // 1) Create and fund a new Solana wallet\n  const newSolanaKeypair = Keypair.generate();\n  const connection = new Connection(SOLANA_RPC, 'confirmed');\n\n  const SOL_FUNDING_KEY =\n    (process.env['SOLANA_PRIVATE_KEY'] as string | undefined) ||\n    (process.env['SVM_PRIVATE_KEY'] as string | undefined);\n  if (!SOL_FUNDING_KEY) {\n    throw new Error('SOLANA_PRIVATE_KEY (or SVM_PRIVATE_KEY) is not set');\n  }\n\n  let funderKeypair: Keypair;\n  try {\n    if (SOL_FUNDING_KEY.trim().startsWith('[')) {\n      const arr = JSON.parse(SOL_FUNDING_KEY) as number[];\n      funderKeypair = Keypair.fromSecretKey(Uint8Array.from(arr));\n    } else {\n      const decoded = anchorUtils.bytes.bs58.decode(SOL_FUNDING_KEY.trim());\n      funderKeypair = Keypair.fromSecretKey(Uint8Array.from(decoded));\n    }\n  } catch (_) {\n    throw new Error('Invalid SOLANA_PRIVATE_KEY format');\n  }\n\n  const minRent = await connection.getMinimumBalanceForRentExemption(\n    0,\n    'confirmed'\n  );\n  const transferIx = SystemProgram.transfer({\n    fromPubkey: funderKeypair.publicKey,\n    toPubkey: newSolanaKeypair.publicKey,\n    lamports: Math.max(minRent, 50_000_000),\n  });\n  const { blockhash, lastValidBlockHeight } =\n    await connection.getLatestBlockhash('confirmed');\n  const tx = new Transaction({\n    feePayer: funderKeypair.publicKey,\n    recentBlockhash: blockhash,\n  }).add(transferIx);\n  tx.sign(funderKeypair);\n  const sig = await connection.sendRawTransaction(tx.serialize(), {\n    skipPreflight: false,\n    preflightCommitment: 'confirmed',\n  });\n  await connection.confirmTransaction(\n    { signature: sig, blockhash, lastValidBlockHeight },\n    'confirmed'\n  );\n\n  // 2) Initialize PushChain client from the NEW Solana wallet\n  const universalSignerNewSolana =\n    await PushChain.utils.signer.toUniversalFromKeypair(newSolanaKeypair, {\n      chain: PushChain.CONSTANTS.CHAIN.SOLANA_DEVNET,\n      library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n    });\n  const pushClientNewSolana = await PushChain.initialize(\n    universalSignerNewSolana,\n    {\n      network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      rpcUrls: { [CHAIN.SOLANA_DEVNET]: [SOLANA_RPC] },\n      progressHook: (progress) =>\n        console.log('Progress (SVM new wallet)', progress),\n    }\n  );\n\n  // 3) Prepare target contract call on Push Chain\n  const bridgeAmount = BigInt(1);\n  const COUNTER_ABI = [\n    {\n      inputs: [],\n      name: 'increment',\n      outputs: [],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n    {\n      inputs: [],\n      name: 'countPC',\n      outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function',\n    },\n  ];\n  const COUNTER_ADDRESS =\n    '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n  const bytecode = await pushPublicClient.getBytecode({\n    address: COUNTER_ADDRESS,\n  });\n  if (!bytecode || bytecode === '0x') {\n    console.warn(`Skipping SVM test: no contract at ${COUNTER_ADDRESS}`);\n    return;\n  }\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n\n  // 4) Pre-check pSOL balances on Push chain\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const executorInfo = await PushChain.utils.account.convertOriginToExecutor(\n    universalSignerNewSolana.account,\n    { onlyCompute: true }\n  );\n  const pSOL_ADDRESS =\n    SYNTHETIC_PUSH_ERC20[PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT].pSOL;\n  const balanceBefore_pSOL_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pSOL_ADDRESS,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceBefore_pSOL_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pSOL_ADDRESS,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  // 5) Execute\n  if (transactionRecipient === 'self') {\n    await expect(\n      pushClientNewSolana.universal.sendTransaction({\n        to: pushClientNewSolana.universal.account,\n        value: BigInt(0),\n        data,\n        funds: {\n          amount: bridgeAmount,\n          token: pushClientNewSolana.moveable.token.SOL,\n        },\n      })\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n\n  const res = await pushClientNewSolana.universal.sendTransaction({\n    to: COUNTER_ADDRESS,\n    value: BigInt(0),\n    data,\n    funds: {\n      amount: bridgeAmount,\n      token: pushClientNewSolana.moveable.token.SOL,\n    },\n  });\n  console.log('SVM new wallet sendTxWithFunds SOL hash', res.hash);\n  await res.wait();\n\n  // 6) Post-checks\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n  const balanceAfter_pSOL_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pSOL_ADDRESS,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceAfter_pSOL_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pSOL_ADDRESS,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  expect(balanceAfter_pSOL_UEA === balanceBefore_pSOL_UEA).toBe(true);\n  expect(balanceAfter_pSOL_COUNTER > balanceBefore_pSOL_COUNTER).toBe(true);\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n}\nasync function testSendTxWithFundsUSDTNoValue(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n\n  const erc20Abi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const usdt = client.moveable.token.USDT;\n\n  const evm = new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  });\n  const usdtBal: bigint = await evm.readContract<bigint>({\n    abi: erc20Abi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n\n  if (usdtBal === BigInt(0)) {\n    console.warn(\n      `Skipping ${config.name} USDT sendTxWithFunds: no USDT balance`\n    );\n    return;\n  }\n\n  const bridgeAmount = BigInt(1);\n  const COUNTER_ABI = [\n    {\n      inputs: [],\n      name: 'increment',\n      outputs: [],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n    {\n      inputs: [],\n      name: 'countPC',\n      outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function',\n    },\n  ];\n  const COUNTER_ADDRESS =\n    '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  const bytecode = await pushPublicClient.getBytecode({\n    address: COUNTER_ADDRESS,\n  });\n  if (!bytecode || bytecode === '0x') {\n    console.warn(`Skipping ${config.name}: no contract at ${COUNTER_ADDRESS}`);\n    return;\n  }\n\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const executorInfo = await PushChain.utils.account.convertOriginToExecutor(\n    {\n      chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n      address: account.address,\n    },\n    { onlyCompute: true }\n  );\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceBefore_pUSDT_ETH_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n  const balanceBefore_pUSDT_ETH_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  if (transactionRecipient === 'self') {\n    await expect(\n      client.universal.sendTransaction({\n        to: client.universal.account,\n        value: BigInt(0),\n        data,\n        funds: { amount: bridgeAmount, token: usdt },\n      })\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n\n  const resUSDT = await client.universal.sendTransaction({\n    to: COUNTER_ADDRESS,\n    value: BigInt(0),\n    data,\n    funds: { amount: bridgeAmount, token: usdt },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  expect(typeof resUSDT.hash).toBe('string');\n  expect(resUSDT.hash.startsWith('0x')).toBe(true);\n  await resUSDT.wait();\n\n  // Wait for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const balanceAfter_pUSDT_ETH_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: executorInfo.address,\n  });\n\n  const balanceAfter_pUSDT_ETH_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS,\n  });\n\n  // UEA USDT balance ++\n  expect(balanceAfter_pUSDT_ETH_UEA === balanceBefore_pUSDT_ETH_UEA).toBe(true);\n  expect(balanceAfter_pUSDT_ETH_COUNTER > balanceBefore_pUSDT_ETH_COUNTER).toBe(\n    true\n  );\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\nasync function testSendTxValueAndPayload(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig\n): Promise<void> {\n  const erc20Abi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const usdt = client.moveable.token.USDT;\n\n  const evm = new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  });\n  const usdtBal: bigint = await evm.readContract<bigint>({\n    abi: erc20Abi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n\n  if (usdtBal === BigInt(0)) {\n    console.warn(\n      `Skipping ${config.name} USDT sendTxWithFunds: no USDT balance`\n    );\n    return;\n  }\n\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const beforeCounterPCBalance = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  const resUSDT = await client.universal.sendTransaction({\n    to: COUNTER_ADDRESS_PAYABLE,\n    value: BigInt(5),\n    data,\n  });\n  console.log('txHash', resUSDT.hash);\n\n  expect(typeof resUSDT.hash).toBe('string');\n  expect(resUSDT.hash.startsWith('0x')).toBe(true);\n  await resUSDT.wait();\n\n  // Wait for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const afterCounterPCBalance = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  expect(afterCounterPCBalance - beforeCounterPCBalance).toBe(BigInt(5));\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\nasync function testSendTxPayloadOnly(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig\n): Promise<void> {\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const beforeCounterPCBalance = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  const res = await client.universal.sendTransaction({\n    to: COUNTER_ADDRESS_PAYABLE,\n    data,\n  });\n  console.log('txHash', res.hash);\n\n  expect(typeof res.hash).toBe('string');\n  expect(res.hash.startsWith('0x')).toBe(true);\n  await res.wait();\n\n  // Wait for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const afterCounterPCBalance = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\nasync function testSendTxWithFundsUSDTWithValue(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient)\n    throw new Error('Please select the recipient for this testcase');\n\n  const erc20Abi = parseAbi([\n    'function balanceOf(address) view returns (uint256)',\n  ]);\n  const usdt = client.moveable.token.USDT;\n\n  const evm = new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  });\n  const usdtBal: bigint = await evm.readContract<bigint>({\n    abi: erc20Abi,\n    address: usdt.address,\n    functionName: 'balanceOf',\n    args: [account.address],\n  });\n\n  if (usdtBal === BigInt(0)) {\n    console.warn(\n      `Skipping ${config.name} USDT sendTxWithFunds: no USDT balance`\n    );\n    return;\n  }\n\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self') recipient = client.universal.account;\n  else recipient = COUNTER_ADDRESS_PAYABLE;\n\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  });\n\n  if (transactionRecipient === 'self') {\n    await expect(\n      client.universal.sendTransaction({\n        to: recipient,\n        value: BigInt(5),\n        data,\n        funds: { amount: BigInt(1), token: usdt },\n      })\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  const bytecode = await pushPublicClient.getBytecode({\n    address: COUNTER_ADDRESS_PAYABLE,\n  });\n  if (!bytecode || bytecode === '0x') {\n    console.warn(\n      `Skipping ${config.name}: no contract at ${COUNTER_ADDRESS_PAYABLE}`\n    );\n    return;\n  }\n\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n\n  const pusdt = PushChain.utils.tokens.getPRC20Mapping(usdt);\n  const balanceBefore_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: client.universal.account,\n  });\n  const balanceBefore_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS_PAYABLE,\n  });\n  const balanceBeforePC_COUNTER = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n  const balanceBeforePC_UEA = await pushEvmClient.getBalance(\n    client.universal.account\n  );\n\n  const resUSDT = await client.universal.sendTransaction({\n    to: recipient,\n    value: BigInt(5),\n    data,\n    funds: { amount: BigInt(1), token: usdt },\n  });\n  console.log('txHash', resUSDT.hash);\n\n  expect(typeof resUSDT.hash).toBe('string');\n  expect(resUSDT.hash.startsWith('0x')).toBe(true);\n  await resUSDT.wait();\n\n  // Wait for Push Chain state to finalize\n  await new Promise((resolve) => setTimeout(resolve, 3000));\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const balanceAfter_pUSDT_UEA = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: client.universal.account,\n  });\n  const balanceAfter_pUSDT_COUNTER = await pushEvmClient.getErc20Balance({\n    tokenAddress: pusdt,\n    ownerAddress: COUNTER_ADDRESS_PAYABLE,\n  });\n  const balanceAfterPC_COUNTER = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n  const balanceAfterPC_UEA = await pushEvmClient.getBalance(\n    client.universal.account\n  );\n\n  expect(balanceAfter_pUSDT_UEA === balanceBefore_pUSDT_UEA).toBe(true);\n  expect(balanceAfter_pUSDT_COUNTER > balanceBefore_pUSDT_COUNTER).toBe(true);\n  expect(balanceAfterPC_COUNTER > balanceBeforePC_COUNTER).toBe(true);\n  // expect(balanceAfterPC_UEA > balanceBeforePC_UEA).toBe(true); // check\n\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  console.log(`[${config.name}] Counter incremented successfully`);\n}\n\n// New: funds+payload paying gas with USDT (gasTokenAddress)\nasync function testSendTxWithFundsPayGasUSDT(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig\n): Promise<void> {\n  const usdt = client.moveable.token.USDT;\n\n  const evm = new EvmClient({\n    rpcUrls: CHAIN_INFO[config.chain].defaultRPC,\n  });\n  const usdtBal: bigint = await evm.getErc20Balance({\n    tokenAddress: usdt.address as `0x${string}`,\n    ownerAddress: account.address as `0x${string}`,\n  });\n\n  if (usdtBal === BigInt(0)) {\n    console.warn(`Skipping ${config.name} pay-gas-in-USDT: no USDT balance`);\n    return;\n  }\n\n  const bridgeAmount = BigInt(1);\n  const COUNTER_ABI = [\n    {\n      inputs: [],\n      name: 'increment',\n      outputs: [],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n    {\n      inputs: [],\n      name: 'countPC',\n      outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function',\n    },\n  ];\n  const COUNTER_ADDRESS =\n    '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI,\n    functionName: 'increment',\n  });\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n  const bytecode = await pushPublicClient.getBytecode({\n    address: COUNTER_ADDRESS,\n  });\n  if (!bytecode || bytecode === '0x') {\n    console.warn(`Skipping ${config.name}: no contract at ${COUNTER_ADDRESS}`);\n    return;\n  }\n\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n\n  // const amount = PushChain.utils.helpers.parseUnits('1.05', {\n  //   decimals: client.payable.token.USDT.decimals,\n  // });\n  // const toToken = client.moveable.token.WETH;\n  // const quote = await client.funds.getConversionQuote(amount, {\n  //   from: client.payable.token.USDT,\n  //   to: toToken,\n  // });\n  // const minAmountOut = PushChain.utils.conversion.slippageToMinAmount(\n  //   quote.amountOut,\n  //   { slippageBps: 300 }\n  // );\n\n  // const amountOutEth = PushChain.utils.helpers.formatUnits(\n  //   quote.amountOut,\n  //   toToken.decimals\n  // );\n  // console.log('amountOut (USDT -> WETH)', amountOutEth);\n\n  // const exactOut = await client.funds.getConversionQuoteExactOutput(\n  //   BigInt(minAmountOut),\n  //   {\n  //     from: client.payable.token.USDT,\n  //     to: client.moveable.token.WETH,\n  //   }\n  // );\n  // const requiredUsdt = PushChain.utils.helpers.formatUnits(\n  //   exactOut.amountIn,\n  //   client.payable.token.USDT.decimals\n  // );\n  // console.log('requiredUSDT for minOut WETH (exact-output)', requiredUsdt);\n\n  const res = await client.universal.sendTransaction({\n    to: COUNTER_ADDRESS,\n    value: BigInt(0),\n    data,\n    funds: {\n      amount: bridgeAmount,\n      token: usdt,\n    },\n    payGasWith: {\n      token: client.payable.token.USDT,\n    },\n  });\n  console.log('txHash', res.hash);\n\n  expect(typeof res.hash).toBe('string');\n  expect(res.hash.startsWith('0x')).toBe(true);\n  await res.wait();\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI,\n    address: COUNTER_ADDRESS,\n    functionName: 'countPC',\n  })) as bigint;\n\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  console.log(`[${config.name}] Pay-gas-with-USDT executed successfully`);\n}\n\nasync function testMulticall(\n  client: PushChain,\n  config: EVMChainTestConfig\n): Promise<void> {\n  const CounterABI = [\n    {\n      inputs: [],\n      name: 'increment',\n      outputs: [],\n      stateMutability: 'nonpayable',\n      type: 'function',\n    },\n    {\n      inputs: [],\n      name: 'countPC',\n      outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n      stateMutability: 'view',\n      type: 'function',\n    },\n  ];\n  const COUNTER_ADDRESS =\n    '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n\n  const incrementData = PushChain.utils.helpers.encodeTxData({\n    abi: CounterABI as unknown as any[],\n    functionName: 'increment',\n  }) as `0x${string}`;\n\n  const calls: MultiCall[] = [\n    { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n    { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n  ];\n\n  const publicClientPush = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  const before = (await publicClientPush.readContract({\n    address: COUNTER_ADDRESS,\n    abi: CounterABI as unknown as any[],\n    functionName: 'countPC',\n    args: [],\n  })) as unknown as bigint;\n\n  const tx = await client.universal.sendTransaction({\n    to: client.universal.account,\n    value: BigInt(0),\n    data: calls,\n  });\n  console.log('txHash', tx.hash);\n\n  await tx.wait();\n\n  const after = (await publicClientPush.readContract({\n    address: COUNTER_ADDRESS,\n    abi: CounterABI as unknown as any[],\n    functionName: 'countPC',\n    args: [],\n  })) as unknown as bigint;\n\n  expect(after).toBe(before + BigInt(2));\n\n  expect(tx.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n\n  console.log(`[${config.name}] Multicall executed successfully`);\n}\n\nasync function testFeeAbstractionValueOnly(\n  config: EVMChainTestConfig,\n  privateKey: `0x${string}`,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  if (!transactionRecipient) throw new Error('Missing transaction recipient');\n  const account = privateKeyToAccount(privateKey);\n  const walletClient = createWalletClient({\n    account,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const universalSignerEVM =\n    await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    });\n  const pushClientEVM = await PushChain.initialize(universalSignerEVM, {\n    network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n    rpcUrls: {\n      [config.chain]: [config.rpcUrl],\n    },\n  });\n\n  const newAccount = privateKeyToAccount(generatePrivateKey());\n\n  const walletClientNew = createWalletClient({\n    account: newAccount,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const publicClient = createPublicClient({\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const balanceBefore = await publicClient.getBalance({\n    address: newAccount.address,\n  });\n  console.log(\n    `[${config.name}] New account balance before (wei):`,\n    balanceBefore.toString()\n  );\n\n  // Send native token to new account\n  const txHash = await walletClient.sendTransaction({\n    to: newAccount.address,\n    chain: config.viemChain,\n    value: PushChain.utils.helpers.parseUnits('0.00031', 18),\n  });\n\n  // Wait for transaction to be mined\n  await new Promise((resolve) => setTimeout(resolve, 15000));\n  await publicClient.waitForTransactionReceipt({\n    hash: txHash,\n  });\n\n  const balanceAfter = await publicClient.getBalance({\n    address: newAccount.address,\n  });\n  console.log(\n    `[${config.name}] New account balance after (wei):`,\n    balanceAfter.toString()\n  );\n\n  const universalSignerNewAccount =\n    await PushChain.utils.signer.toUniversalFromKeypair(walletClientNew, {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    });\n\n  const pushClientNewAccount = await PushChain.initialize(\n    universalSignerNewAccount,\n    {\n      network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      progressHook: (progress) => {\n        console.log(`[${config.name}] Progress:`, progress);\n      },\n      rpcUrls: {\n        [config.chain]: [config.rpcUrl],\n      },\n    }\n  );\n\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self')\n    recipient = pushClientNewAccount.universal.account;\n  else recipient = '0x0000000000000000000000000000000000042101';\n  // Prepare Push EVM client and compute executor (UEA) address on Push Chain\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const executorInfo = await PushChain.utils.account.convertOriginToExecutor(\n    universalSignerNewAccount.account,\n    { onlyCompute: true }\n  );\n  const pcBeforeUEA = await pushEvmClient.getBalance(executorInfo.address);\n  const pcBeforeRecipient = await pushEvmClient.getBalance(recipient);\n  console.log(\n    `[${config.name}] Executor PC balance before (wei):`,\n    pcBeforeUEA.toString()\n  );\n  console.log(\n    `[${config.name}] Executor PC balance before (wei):`,\n    pcBeforeRecipient.toString()\n  );\n\n  // Execute transaction from new account\n  const resultTx = await pushClientNewAccount.universal.sendTransaction({\n    to: recipient,\n    value: BigInt(1),\n  });\n\n  expect(resultTx).toBeDefined();\n  console.log('txHash', resultTx.hash);\n  await resultTx.wait();\n\n  const pcAfterUEA = await pushEvmClient.getBalance(executorInfo.address);\n  const pcAfterRecipient = await pushEvmClient.getBalance(recipient);\n  console.log(\n    `[${config.name}] Executor PC balance after (wei):`,\n    pcAfterUEA.toString()\n  );\n  console.log(\n    `[${config.name}] Executor PC balance after (wei):`,\n    pcAfterRecipient.toString()\n  );\n\n  expect(pcAfterUEA > pcBeforeUEA).toBe(true);\n  expect(pcAfterRecipient > pcBeforeRecipient).toBe(true);\n  console.log(`[${config.name}] Fee abstraction test completed successfully`);\n}\n\nasync function testFeeAbstractionPayloadAndValue(\n  client: PushChain,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  // Prepare Push EVM client and compute executor (UEA) address on Push Chain\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const pcBeforeUEA = await pushEvmClient.getBalance(client.universal.account);\n  const balanceBeforeCounter = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  }) as `0x${string}`;\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self') recipient = client.universal.account;\n  else recipient = COUNTER_ADDRESS_PAYABLE;\n\n  const executePayload = {\n    to: recipient,\n    value: BigInt(7), // << -- go to smart contract\n    data,\n  } as ExecuteParams;\n\n  // Execute transaction from new account\n  if (transactionRecipient === 'self') {\n    await expect(\n      client.universal.sendTransaction(executePayload)\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n  const resultTx = await client.universal.sendTransaction(executePayload);\n\n  expect(resultTx).toBeDefined();\n  console.log('txHash', resultTx.hash);\n  await resultTx.wait();\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pcAfterUEA = await pushEvmClient.getBalance(client.universal.account);\n  const balanceAfterCounter = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  expect(balanceAfterCounter - balanceBeforeCounter).toBe(BigInt(7));\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  // We should have less PC AFTER execution\n  expect(pcAfterUEA < pcBeforeUEA).toBe(true);\n  console.log(`[${config.name}] Fee abstraction test completed successfully`);\n}\n\nasync function testFeeAbstractionPayloadAndValueNewWalletDeployUEA(\n  client: PushChain,\n  account: PrivateKeyAccount,\n  config: EVMChainTestConfig,\n  transactionRecipient: 'self' | 'other'\n): Promise<void> {\n  // Set up funded wallet client from the provided account (origin: Sepolia)\n  const walletClientFunded = createWalletClient({\n    account,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Create a brand-new account and wallet client (origin: Sepolia)\n  const newAccount = privateKeyToAccount(generatePrivateKey());\n  const walletClientNew = createWalletClient({\n    account: newAccount,\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  const publicClient = createPublicClient({\n    chain: config.viemChain,\n    transport: http(config.rpcUrl),\n  });\n\n  // Fund new account with native Ether on Sepolia\n  const nativeTxHash = await walletClientFunded.sendTransaction({\n    to: newAccount.address,\n    chain: config.viemChain,\n    value: PushChain.utils.helpers.parseUnits('0.00031', 18),\n  });\n  await publicClient.waitForTransactionReceipt({ hash: nativeTxHash });\n\n  // 2) Initialize PushChain client from the NEW wallet\n  const universalSignerNew =\n    await PushChain.utils.signer.toUniversalFromKeypair(walletClientNew, {\n      chain: config.chain,\n      library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n    });\n  const pushClientNew = await PushChain.initialize(universalSignerNew, {\n    network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n    rpcUrls: { [config.chain]: [config.rpcUrl] },\n    progressHook: (progress) => console.log(progress),\n  });\n\n  // 3) Prepare Push EVM client and baseline Push balances\n  const pushEvmClient = new EvmClient({\n    rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n  });\n  const pcBeforeUEA = await pushEvmClient.getBalance(\n    pushClientNew.universal.account\n  );\n  const balanceBeforeCounter = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  const data = PushChain.utils.helpers.encodeTxData({\n    abi: COUNTER_ABI_PAYABLE,\n    functionName: 'increment',\n  }) as `0x${string}`;\n\n  const pushPublicClient = createPublicClient({\n    transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n  });\n\n  const beforeCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  let recipient: `0x${string}`;\n  if (transactionRecipient === 'self')\n    recipient = pushClientNew.universal.account;\n  else recipient = COUNTER_ADDRESS_PAYABLE;\n\n  const executePayload = {\n    to: recipient,\n    value: BigInt(7), // << -- go to smart contract\n    data,\n  } as ExecuteParams;\n\n  // Execute transaction from new account\n  if (transactionRecipient === 'self') {\n    await expect(\n      pushClientNew.universal.sendTransaction(executePayload)\n    ).rejects.toThrow(`You can't execute data on the UEA address`);\n    return;\n  }\n  const resultTx = await pushClientNew.universal.sendTransaction(\n    executePayload\n  );\n\n  expect(resultTx).toBeDefined();\n  console.log('txHash', resultTx.hash);\n  await resultTx.wait();\n\n  const afterCount = (await pushPublicClient.readContract({\n    abi: COUNTER_ABI_PAYABLE,\n    address: COUNTER_ADDRESS_PAYABLE,\n    functionName: 'countPC',\n  })) as bigint;\n\n  const pcAfterUEA = await pushEvmClient.getBalance(\n    pushClientNew.universal.account\n  );\n  const balanceAfterCounter = await pushEvmClient.getBalance(\n    COUNTER_ADDRESS_PAYABLE\n  );\n\n  expect(balanceAfterCounter - balanceBeforeCounter).toBe(BigInt(7));\n  expect(afterCount).toBe(beforeCount + BigInt(1));\n  // We create a new wallet, so we will have at first 0 PC. Then later more.\n  expect(pcAfterUEA > pcBeforeUEA).toBe(true);\n  console.log(`[${config.name}] Fee abstraction test completed successfully`);\n}\n\ndescribe('PushChain', () => {\n  describe('Universal Namesapce', () => {\n    let pushClientEVM: PushChain;\n    let pushChainPush: PushChain;\n    let pushChainSVM: PushChain;\n    let universalSignerEVM: UniversalSigner;\n    let universalSignerPush: UniversalSigner;\n    let universalSignerSVM: UniversalSigner;\n\n    beforeAll(async () => {\n      const evmPrivateKey = process.env['EVM_PRIVATE_KEY'];\n      if (!evmPrivateKey)\n        throw new Error('EVM_PRIVATE_KEY not set in core/.env');\n      const account = privateKeyToAccount(evmPrivateKey as `0x${string}`);\n      const walletClient = createWalletClient({\n        account,\n        chain: sepolia,\n        transport: http(EVM_RPC),\n      });\n      universalSignerEVM = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      pushClientEVM = await PushChain.initialize(universalSignerEVM, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        rpcUrls: { [CHAIN.ETHEREUM_SEPOLIA]: [EVM_RPC] },\n        progressHook: (progress) => console.log(progress),\n      });\n\n      const pushTestnet = defineChain({\n        id: parseInt(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].chainId),\n        name: 'Push Testnet',\n        nativeCurrency: {\n          decimals: 18,\n          name: 'PC',\n          symbol: '$PC',\n        },\n        rpcUrls: {\n          default: {\n            http: [CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]],\n          },\n        },\n        blockExplorers: {\n          default: {\n            name: 'Push Testnet Explorer',\n            url: 'https://explorer.testnet.push.org/',\n          },\n        },\n      });\n      const accountPush = privateKeyToAccount(evmPrivateKey as `0x${string}`);\n      const walletClientPush = createWalletClient({\n        account: accountPush,\n        chain: pushTestnet,\n        transport: http(),\n      });\n      universalSignerPush = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClientPush,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      pushChainPush = await PushChain.initialize(universalSignerPush, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        rpcUrls: { [CHAIN.ETHEREUM_SEPOLIA]: [EVM_RPC] },\n        progressHook: (progress) => console.log(progress),\n      });\n\n      const privateKeyHex = process.env['SOLANA_PRIVATE_KEY'];\n      if (!privateKeyHex) throw new Error('SOLANA_PRIVATE_KEY not set');\n\n      const privateKey = bs58.decode(privateKeyHex);\n\n      const accountSVM = Keypair.fromSecretKey(privateKey);\n\n      universalSignerSVM = await PushChain.utils.signer.toUniversalFromKeypair(\n        accountSVM,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.SOLANA_DEVNET,\n          library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n        }\n      );\n      pushChainSVM = await PushChain.initialize(universalSignerSVM, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        rpcUrls: { [CHAIN.ETHEREUM_SEPOLIA]: [EVM_RPC] },\n        progressHook: (progress) => console.log(progress),\n      });\n    });\n\n    describe('signMessage', () => {\n      it('should signMessage - EVM format', async () => {\n        const testMessage = new TextEncoder().encode('Hello, Push Chain!');\n        const signatureEVM = await pushClientEVM.universal.signMessage(\n          testMessage\n        );\n        const signaturePush = await pushChainPush.universal.signMessage(\n          testMessage\n        );\n\n        // Verify signature format (should be hex for EVM)\n        expect(signatureEVM).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(signatureEVM.length).toBeGreaterThan(2); // At least 0x + some hex chars\n\n        expect(signaturePush).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(signaturePush.length).toBeGreaterThan(2); // At least 0x + some hex chars\n\n        // Verify the signature is valid\n        const isValidEVM = await verifyMessage({\n          address: universalSignerEVM.account.address as `0x${string}`,\n          message: { raw: testMessage },\n          signature: signatureEVM as `0x${string}`,\n        });\n\n        expect(isValidEVM).toBe(true);\n\n        const isValidPush = await verifyMessage({\n          address: universalSignerPush.account.address as `0x${string}`,\n          message: { raw: testMessage },\n          signature: signaturePush as `0x${string}`,\n        });\n\n        expect(isValidPush).toBe(true);\n      });\n\n      it('should signMessage - binary data', async () => {\n        const binaryData = new Uint8Array([1, 2, 3, 4, 5, 255, 0, 128]);\n        const signatureEVM = await pushClientEVM.universal.signMessage(\n          binaryData\n        );\n        const signaturePush = await pushChainPush.universal.signMessage(\n          binaryData\n        );\n\n        expect(signatureEVM).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(signatureEVM.length).toBeGreaterThan(2); // At least 0x + some hex chars\n\n        // Verify the signature is valid\n        const isValidEVM = await verifyMessage({\n          address: universalSignerEVM.account.address as `0x${string}`,\n          message: { raw: binaryData },\n          signature: signatureEVM as `0x${string}`,\n        });\n\n        expect(isValidEVM).toBe(true);\n\n        const isValidPush = await verifyMessage({\n          address: universalSignerPush.account.address as `0x${string}`,\n          message: { raw: binaryData },\n          signature: signaturePush as `0x${string}`,\n        });\n\n        expect(isValidPush).toBe(true);\n      });\n    });\n\n    describe('Multicall', () => {\n      const COUNTER_ADDRESS =\n        '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n\n      const CounterABI = [\n        {\n          inputs: [],\n          name: 'increment',\n          outputs: [],\n          stateMutability: 'nonpayable',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'countPC',\n          outputs: [\n            {\n              internalType: 'uint256',\n              name: '',\n              type: 'uint256',\n            },\n          ],\n          stateMutability: 'view',\n          type: 'function',\n        },\n      ] as const;\n\n      it('should build and send multicall payload from Sepolia', async () => {\n        const incrementData = PushChain.utils.helpers.encodeTxData({\n          abi: CounterABI as unknown as any[],\n          functionName: 'increment',\n        }) as `0x${string}`;\n\n        const calls: MultiCall[] = [\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n        ];\n\n        const publicClientPush = createPublicClient({\n          transport: http('https://evm.donut.rpc.push.org'),\n        });\n\n        const before = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        // Check if valid address -> If invalid evm address, throw error\n        const tx = await pushClientEVM.universal.sendTransaction({\n          to: pushClientEVM.universal.account,\n          value: BigInt(0),\n          data: calls,\n        });\n        console.log('txHash', tx.hash);\n\n        expect(tx.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n\n        await tx.wait();\n\n        const after = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        expect(after).toBe(before + BigInt(4));\n      }, 300000);\n\n      it('should throw if multicall used with invalid execute.to (SVM)', async () => {\n        const incrementData = PushChain.utils.helpers.encodeTxData({\n          abi: CounterABI as unknown as any[],\n          functionName: 'increment',\n        });\n\n        const calls: MultiCall[] = [\n          {\n            to: COUNTER_ADDRESS,\n            value: BigInt(0),\n            data: incrementData as `0x${string}`,\n          },\n        ];\n\n        await expect(\n          pushChainSVM.universal.sendTransaction({\n            to: '0xabc',\n            value: BigInt(0),\n            data: calls,\n          })\n        ).rejects.toThrow(`Invalid EVM address at execute.to 0xabc`);\n      });\n\n      it('should build and send multicall payload from Solana Devnet', async () => {\n        const incrementData = PushChain.utils.helpers.encodeTxData({\n          abi: CounterABI as unknown as any[],\n          functionName: 'increment',\n        }) as `0x${string}`;\n\n        const calls: MultiCall[] = [\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n          { to: COUNTER_ADDRESS, value: BigInt(0), data: incrementData },\n        ];\n\n        const publicClientPush = createPublicClient({\n          transport: http('https://evm.donut.rpc.push.org'),\n        });\n\n        const before = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        const tx = await pushChainSVM.universal.sendTransaction({\n          to: pushChainSVM.universal.account,\n          value: BigInt(0),\n          data: calls,\n        });\n        console.log('txHash', tx.hash);\n\n        expect(tx.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n\n        // const selector = keccak256(toBytes('UEA_MULTICALL')).slice(0, 10);\n        // expect(tx.data.slice(0, 10)).toBe(selector);\n\n        await tx.wait();\n\n        const after = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        expect(after).toBe(before + BigInt(2));\n      }, 300000);\n\n      it('should perform normal single-call from Sepolia, Solana Devnet, and Push Testnet', async () => {\n        const incrementData = PushChain.utils.helpers.encodeTxData({\n          abi: CounterABI as unknown as any[],\n          functionName: 'increment',\n        }) as `0x${string}`;\n\n        const publicClientPush = createPublicClient({\n          transport: http('https://evm.donut.rpc.push.org'),\n        });\n\n        const before = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        // 1) From Ethereum Sepolia origin\n        const txEvm = await pushClientEVM.universal.sendTransaction({\n          to: COUNTER_ADDRESS,\n          value: BigInt(0),\n          data: incrementData,\n        });\n        console.log('txHash', txEvm.hash);\n        expect(txEvm.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n        await txEvm.wait();\n\n        // 2) From Solana Devnet origin\n        const txSvm = await pushChainSVM.universal.sendTransaction({\n          to: COUNTER_ADDRESS,\n          value: BigInt(0),\n          data: incrementData,\n        });\n        console.log('txHash', txSvm.hash);\n        expect(txSvm.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n        await txSvm.wait();\n\n        // 3) From Push Testnet origin\n        const txPush = await pushChainPush.universal.sendTransaction({\n          to: COUNTER_ADDRESS,\n          value: BigInt(0),\n          data: incrementData,\n        });\n        console.log('txHash', txPush.hash);\n        expect(txPush.hash).toMatch(/^0x[a-fA-F0-9]{64}$/);\n        await txPush.wait();\n\n        const after = (await publicClientPush.readContract({\n          address: COUNTER_ADDRESS,\n          abi: CounterABI as unknown as any[],\n          functionName: 'countPC',\n          args: [],\n        })) as unknown as bigint;\n\n        expect(after).toBe(before + BigInt(3));\n      }, 300000);\n    });\n\n    // Individual multicall tests for each EVM chain (for IDE run button support)\n    describe('Multicall - Ethereum Sepolia', () => {\n      const config = EVM_CHAIN_CONFIGS[0]; // Ethereum Sepolia\n      const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n        | `0x${string}`\n        | undefined;\n      let client: PushChain;\n\n      beforeAll(async () => {\n        if (!PRIVATE_KEY) {\n          throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n        }\n\n        const result = await setupEVMChainClient(config, PRIVATE_KEY);\n        client = result.client;\n      });\n\n      it('integration: should build and send multicall payload', async () => {\n        await testMulticall(client, config);\n      }, 300000);\n    });\n\n    describe('Multicall - Arbitrum Sepolia', () => {\n      const config = EVM_CHAIN_CONFIGS[1]; // Arbitrum Sepolia\n      const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n        | `0x${string}`\n        | undefined;\n      let client: PushChain;\n\n      beforeAll(async () => {\n        if (!PRIVATE_KEY) {\n          throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n        }\n\n        const result = await setupEVMChainClient(config, PRIVATE_KEY);\n        client = result.client;\n      });\n\n      it('integration: should build and send multicall payload', async () => {\n        await testMulticall(client, config);\n      }, 300000);\n    });\n\n    describe('Multicall - Base Sepolia', () => {\n      const config = EVM_CHAIN_CONFIGS[2]; // Base Sepolia\n      const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n        | `0x${string}`\n        | undefined;\n      let client: PushChain;\n\n      beforeAll(async () => {\n        if (!PRIVATE_KEY) {\n          throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n        }\n\n        const result = await setupEVMChainClient(config, PRIVATE_KEY);\n        client = result.client;\n      });\n\n      it('integration: should build and send multicall payload', async () => {\n        await testMulticall(client, config);\n      }, 300000);\n    });\n\n    describe('Multicall - BNB Testnet', () => {\n      const config = EVM_CHAIN_CONFIGS[3]; // BNB Testnet\n      const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n        | `0x${string}`\n        | undefined;\n      let client: PushChain;\n\n      beforeAll(async () => {\n        if (!PRIVATE_KEY) {\n          throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n        }\n\n        const result = await setupEVMChainClient(config, PRIVATE_KEY);\n        client = result.client;\n      });\n\n      it('integration: should build and send multicall payload', async () => {\n        await testMulticall(client, config);\n      }, 300000);\n    });\n\n    describe('signTypedData', () => {\n      it('should signTypedData - EIP-712 format', async () => {\n        const domain = {\n          name: 'Push Chain',\n          version: '1',\n          chainId: 42101, // Push testnet\n          verifyingContract:\n            '0x1234567890123456789012345678901234567890' as `0x${string}`,\n        };\n\n        const types = {\n          Person: [\n            { name: 'name', type: 'string' },\n            { name: 'wallet', type: 'address' },\n          ],\n        };\n\n        const message = {\n          name: 'Alice',\n          wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826' as `0x${string}`,\n        };\n\n        const signatureEVM = await pushClientEVM.universal.signTypedData({\n          domain,\n          types,\n          primaryType: 'Person',\n          message,\n        });\n\n        // Verify signature format (should be hex for EVM)\n        expect(signatureEVM).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(signatureEVM.length).toBeGreaterThan(2);\n\n        expect(typeof signatureEVM).toBe('string');\n\n        const signaturePush = await pushChainPush.universal.signTypedData({\n          domain,\n          types,\n          primaryType: 'Person',\n          message,\n        });\n\n        expect(signaturePush).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(signaturePush.length).toBeGreaterThan(2);\n\n        expect(typeof signaturePush).toBe('string');\n      });\n    });\n    describe('get account', () => {\n      it('EVM', async () => {\n        const address = pushClientEVM.universal.account;\n        expect(isAddress(address)).toBeTruthy();\n        expect(address).not.toBe(universalSignerEVM.account.address);\n      });\n      it('Push', async () => {\n        const address = pushChainPush.universal.account;\n        expect(address).toBeDefined();\n        expect(address).toBe(universalSignerPush.account.address);\n      });\n      it('SVM', async () => {\n        const address = pushChainSVM.universal.account;\n        expect(isAddress(address)).toBeTruthy();\n        expect(address).not.toBe(universalSignerSVM.account.address);\n      });\n    });\n    describe('get origin', () => {\n      it('EVM', async () => {\n        const uoa = pushClientEVM.universal.origin;\n        expect(uoa).toBeDefined();\n        expect(uoa.chain).toBe(universalSignerEVM.account.chain);\n        expect(isAddress(uoa.address)).toBe(true);\n      });\n      it('Push', async () => {\n        const uoa = pushChainPush.universal.origin;\n        expect(uoa).toBeDefined();\n        expect(uoa.chain).toBe(universalSignerPush.account.chain);\n        expect(isAddress(uoa.address)).toBe(true);\n      });\n      it('SVM', async () => {\n        const uoa = pushChainSVM.universal.origin;\n        expect(uoa).toBeDefined();\n        expect(uoa.chain).toBe(universalSignerSVM.account.chain);\n\n        let isValid = true;\n        try {\n          new PublicKey(uoa.address);\n        } catch {\n          isValid = false;\n        }\n\n        expect(isValid).toBe(true);\n      });\n    });\n\n    describe('Read Only Mode', () => {\n      let readOnlyAccountEVM: UniversalAccount;\n      let readOnlyAccountPush: UniversalAccount;\n      let readOnlyAccountSVM: UniversalAccount;\n      let readOnlyPushClientEVM: PushChain;\n      let readOnlyPushClientPush: PushChain;\n      let readOnlyPushClientSVM: PushChain;\n\n      beforeAll(async () => {\n        // Create read-only accounts from existing signers\n        readOnlyAccountEVM = {\n          address: pushClientEVM.universal.origin.address,\n          chain: pushClientEVM.universal.origin.chain,\n        };\n\n        readOnlyAccountPush = {\n          address: pushChainPush.universal.origin.address,\n          chain: pushChainPush.universal.origin.chain,\n        };\n\n        readOnlyAccountSVM = {\n          address: pushChainSVM.universal.origin.address,\n          chain: pushChainSVM.universal.origin.chain,\n        };\n\n        // Initialize read-only clients\n        readOnlyPushClientEVM = await PushChain.initialize(readOnlyAccountEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        });\n\n        readOnlyPushClientPush = await PushChain.initialize(\n          readOnlyAccountPush,\n          {\n            network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          }\n        );\n\n        readOnlyPushClientSVM = await PushChain.initialize(readOnlyAccountSVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        });\n      });\n\n      describe('Initialization', () => {\n        it('should successfully initialize with UniversalAccount (EVM)', async () => {\n          expect(readOnlyPushClientEVM).toBeDefined();\n          expect(readOnlyPushClientEVM.universal).toBeDefined();\n        });\n\n        it('should successfully initialize with UniversalAccount (Push)', async () => {\n          expect(readOnlyPushClientPush).toBeDefined();\n          expect(readOnlyPushClientPush.universal).toBeDefined();\n        });\n\n        it('should successfully initialize with UniversalAccount (SVM)', async () => {\n          expect(readOnlyPushClientSVM).toBeDefined();\n          expect(readOnlyPushClientSVM.universal).toBeDefined();\n        });\n      });\n\n      describe('Read-only restrictions', () => {\n        it('should throw error when calling signMessage on read-only EVM client', async () => {\n          const testMessage = new TextEncoder().encode('Hello, Push Chain!');\n\n          await expect(\n            readOnlyPushClientEVM.universal.signMessage(testMessage)\n          ).rejects.toThrow('Read only mode cannot call signMessage function');\n        });\n\n        it('should throw error when calling signMessage on read-only Push client', async () => {\n          const testMessage = new TextEncoder().encode('Hello, Push Chain!');\n\n          await expect(\n            readOnlyPushClientPush.universal.signMessage(testMessage)\n          ).rejects.toThrow('Read only mode cannot call signMessage function');\n        });\n\n        it('should throw error when calling signMessage on read-only SVM client', async () => {\n          const testMessage = new TextEncoder().encode('Hello, Push Chain!');\n\n          await expect(\n            readOnlyPushClientSVM.universal.signMessage(testMessage)\n          ).rejects.toThrow('Read only mode cannot call signMessage function');\n        });\n\n        it('should throw error when calling sendTransaction on read-only EVM client', () => {\n          const mockTxData = {\n            to: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n            value: BigInt(1000000000000000000), // 1 ETH\n            data: '0x' as `0x${string}`,\n            gas: BigInt(21000),\n          };\n\n          expect(() =>\n            readOnlyPushClientEVM.universal.sendTransaction(mockTxData)\n          ).toThrow('Read only mode cannot call sendTransaction function');\n        });\n\n        it('should throw error when calling sendTransaction on read-only Push client', () => {\n          const mockTxData = {\n            to: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n            value: BigInt(1000000000000000000), // 1 ETH\n            data: '0x' as `0x${string}`,\n            gas: BigInt(21000),\n          };\n\n          expect(() =>\n            readOnlyPushClientPush.universal.sendTransaction(mockTxData)\n          ).toThrow('Read only mode cannot call sendTransaction function');\n        });\n\n        it('should throw error when calling sendTransaction on read-only SVM client', () => {\n          const mockTxData = {\n            to: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n            value: BigInt(1000000000000000000), // 1 ETH\n            data: '0x' as `0x${string}`,\n            gas: BigInt(21000),\n          };\n\n          expect(() =>\n            readOnlyPushClientSVM.universal.sendTransaction(mockTxData)\n          ).toThrow('Read only mode cannot call sendTransaction function');\n        });\n\n        it('should throw error when calling signTypedData on read-only EVM client', async () => {\n          const typedData = {\n            domain: {\n              name: 'Test',\n              version: '1',\n              chainId: 11155111,\n            },\n            types: {\n              Message: [{ name: 'content', type: 'string' }],\n            },\n            primaryType: 'Message',\n            message: {\n              content: 'Hello, typed data!',\n            },\n          };\n\n          await expect(\n            readOnlyPushClientEVM.universal.signTypedData(typedData)\n          ).rejects.toThrow('Typed data signing not supported');\n        });\n      });\n\n      describe('Read-only allowed operations', () => {\n        it('should allow accessing origin property on read-only client', () => {\n          const origin = readOnlyPushClientEVM.universal.origin;\n          expect(origin).toBeDefined();\n          expect(typeof origin.address).toBe('string');\n          expect(typeof origin.chain).toBe('string');\n        });\n\n        it('should allow accessing account property on read-only client', () => {\n          const account = readOnlyPushClientEVM.universal.account;\n          expect(account).toBeDefined();\n          expect(typeof account).toBe('string');\n          expect(account.startsWith('0x')).toBe(true);\n        });\n\n        it('should allow accessing explorer methods on read-only client', () => {\n          const txUrl =\n            readOnlyPushClientEVM.explorer.getTransactionUrl('0x123');\n          expect(typeof txUrl).toBe('string');\n          expect(txUrl).toContain('0x123');\n\n          const { urls } = readOnlyPushClientEVM.explorer.listUrls();\n          expect(Array.isArray(urls)).toBe(true);\n        });\n\n        it('should allow accessing static constants and utils on read-only client', () => {\n          expect(PushChain.CONSTANTS).toBeDefined();\n          expect(PushChain.utils).toBeDefined();\n        });\n      });\n\n      describe('Comparison with writable clients', () => {\n        it('should have same origin and account addresses as writable client', () => {\n          // Compare EVM clients\n          expect(readOnlyPushClientEVM.universal.origin.address).toBe(\n            pushClientEVM.universal.origin.address\n          );\n          expect(readOnlyPushClientEVM.universal.account).toBe(\n            pushClientEVM.universal.account\n          );\n\n          // Compare Push clients\n          expect(readOnlyPushClientPush.universal.origin.address).toBe(\n            pushChainPush.universal.origin.address\n          );\n          expect(readOnlyPushClientPush.universal.account).toBe(\n            pushChainPush.universal.account\n          );\n\n          // Compare SVM clients\n          expect(readOnlyPushClientSVM.universal.origin.address).toBe(\n            pushChainSVM.universal.origin.address\n          );\n          expect(readOnlyPushClientSVM.universal.account).toBe(\n            pushChainSVM.universal.account\n          );\n        });\n\n        it('should allow signMessage on writable client but not on read-only client', async () => {\n          const testMessage = new TextEncoder().encode('Test message');\n\n          // Writable client should work\n          const signature = await pushClientEVM.universal.signMessage(\n            testMessage\n          );\n          expect(typeof signature).toBe('string');\n          expect(signature.length).toBeGreaterThan(0);\n\n          // Read-only client should throw error\n          await expect(\n            readOnlyPushClientEVM.universal.signMessage(testMessage)\n          ).rejects.toThrow('Read only mode cannot call signMessage function');\n        });\n      });\n\n      describe('Type checking', () => {\n        it('should correctly identify UniversalAccount vs UniversalSigner during initialization', async () => {\n          // Test with UniversalSigner - should not be read-only\n          const writableClient = pushClientEVM;\n\n          const testMessage = new TextEncoder().encode('Test');\n          const signature = await writableClient.universal.signMessage(\n            testMessage\n          );\n          expect(typeof signature).toBe('string');\n\n          // Test with UniversalAccount - should be read-only\n          const readOnlyAccount: UniversalAccount = {\n            address: writableClient.universal.origin.address,\n            chain: writableClient.universal.origin.chain,\n          };\n\n          const readOnlyClient = await PushChain.initialize(readOnlyAccount, {\n            network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          });\n\n          await expect(\n            readOnlyClient.universal.signMessage(testMessage)\n          ).rejects.toThrow('Read only mode cannot call signMessage function');\n        });\n      });\n    });\n  });\n\n  // TODO: THIS IS HOW TO TEST THE NEW FEE ABSTRACTION.\n  // TODO: WE ARE CREATING BRAND NEW WALLETS SO WE WILL NEED TO DEPLOY A UEA WHEN SENDING A TRANSCTION.\n  // TODO: THIS IS DONE SO WE TEST THE COMPLETE LOGIC THAT THE BACKEND IS INDEED CORRECTLY DEPLOYING THE UEA and funding the wallet.\n  describe('Test new fee abstraction - Ethereum Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[0]; // Ethereum Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n    let account: PrivateKeyAccount;\n    let client: PushChain;\n\n    beforeAll(async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n\n      const result = await setupEVMChainClient(config, PRIVATE_KEY);\n      account = result.account;\n      client = result.client;\n    });\n\n    it('new fee abstraction should work self', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionValueOnly(config, PRIVATE_KEY, 'self');\n    }, 300000);\n\n    it('new fee abstraction Payload + Value self', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionPayloadAndValue(client, config, 'self');\n    }, 300000);\n\n    it('new fee abstraction Payload + Value self new wallet deploy UEA', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionPayloadAndValueNewWalletDeployUEA(\n        client,\n        account,\n        config,\n        'other'\n      );\n    }, 300000);\n\n    it('new fee abstraction Payload + Value other', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionPayloadAndValue(client, config, 'other');\n    }, 300000);\n  });\n\n  describe('Test new fee abstraction - Base Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[2]; // Base Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n\n    it('new fee abstraction should work other', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionValueOnly(config, PRIVATE_KEY, 'other');\n    }, 300000);\n  });\n\n  describe('Test new fee abstraction - Arbitrum Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[1]; // Arbitrum Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n\n    it('new fee abstraction should work other', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionValueOnly(config, PRIVATE_KEY, 'other');\n    }, 300000);\n  });\n\n  describe('Test new fee abstraction - BNB Testnet', () => {\n    const config = EVM_CHAIN_CONFIGS[3]; // BNB Testnet\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n\n    it('new fee abstraction should work other', async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n      await testFeeAbstractionValueOnly(config, PRIVATE_KEY, 'other');\n    }, 300000);\n  });\n\n  // TODO: NEW FEE ABSTRACTION - SOLANA\n  describe('Test new fee abstraction (Solana Devnet - random wallet funding)', () => {\n    // Increase timeout for setup and network operations in this suite\n    jest.setTimeout(300000);\n\n    let newSolanaKeypair: Keypair;\n    let pushClientNewSolana: PushChain;\n\n    beforeAll(async () => {\n      newSolanaKeypair = Keypair.generate();\n\n      const connection = new Connection(SOLANA_RPC, 'confirmed');\n\n      const balanceBefore = await connection.getBalance(\n        newSolanaKeypair.publicKey,\n        'confirmed'\n      );\n      console.log(\n        'newSolana balance before (lamports):',\n        balanceBefore.toString()\n      );\n\n      // Fund the new wallet from a pre-funded SOLANA_PRIVATE_KEY\n      const SOL_FUNDING_KEY =\n        (process.env['SOLANA_PRIVATE_KEY'] as string | undefined) ||\n        (process.env['SVM_PRIVATE_KEY'] as string | undefined);\n      if (!SOL_FUNDING_KEY) {\n        throw new Error('SOLANA_PRIVATE_KEY (or SVM_PRIVATE_KEY) is not set');\n      }\n      let funderKeypair: Keypair;\n      try {\n        if (SOL_FUNDING_KEY.trim().startsWith('[')) {\n          const arr = JSON.parse(SOL_FUNDING_KEY) as number[];\n          funderKeypair = Keypair.fromSecretKey(Uint8Array.from(arr));\n        } else {\n          const decoded = anchorUtils.bytes.bs58.decode(SOL_FUNDING_KEY.trim());\n          funderKeypair = Keypair.fromSecretKey(Uint8Array.from(decoded));\n        }\n      } catch (e) {\n        throw new Error('Invalid SOLANA_PRIVATE_KEY format');\n      }\n      // Ensure we transfer at least rent-exempt minimum for a zero-data account\n      const minRent = await connection.getMinimumBalanceForRentExemption(\n        0,\n        'confirmed'\n      );\n      const transferIx = SystemProgram.transfer({\n        fromPubkey: funderKeypair.publicKey,\n        toPubkey: newSolanaKeypair.publicKey,\n        lamports: Math.max(minRent, 50000000),\n      });\n      const { blockhash, lastValidBlockHeight } =\n        await connection.getLatestBlockhash('confirmed');\n      const tx = new Transaction({\n        feePayer: funderKeypair.publicKey,\n        recentBlockhash: blockhash,\n      }).add(transferIx);\n      tx.sign(funderKeypair);\n      let sig: string;\n      try {\n        sig = await connection.sendRawTransaction(tx.serialize(), {\n          skipPreflight: false,\n          preflightCommitment: 'confirmed',\n        });\n      } catch (err) {\n        if (err instanceof SendTransactionError) {\n          const logs = await err.getLogs(connection);\n          // eslint-disable-next-line no-console\n          console.error('Solana sendRawTransaction logs:', logs);\n        }\n        throw err;\n      }\n      await connection.confirmTransaction(\n        { signature: sig, blockhash, lastValidBlockHeight },\n        'confirmed'\n      );\n\n      const balanceAfter = await connection.getBalance(\n        newSolanaKeypair.publicKey,\n        'confirmed'\n      );\n      console.log(\n        'newSolana balance after (lamports):',\n        balanceAfter.toString()\n      );\n\n      const universalSignerNewSolana =\n        await PushChain.utils.signer.toUniversalFromKeypair(newSolanaKeypair, {\n          chain: PushChain.CONSTANTS.CHAIN.SOLANA_DEVNET,\n          library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n        });\n\n      pushClientNewSolana = await PushChain.initialize(\n        universalSignerNewSolana,\n        {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          progressHook: (progress) => {\n            console.log('Progress', progress);\n          },\n          rpcUrls: {\n            [CHAIN.SOLANA_DEVNET]: [SOLANA_RPC],\n          },\n        }\n      );\n    }, 300000);\n\n    it('random solana wallet is funded', async () => {\n      // Prepare Push EVM client and compute executor (UEA) address on Push Chain\n      const pushEvmClient = new EvmClient({\n        rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n      });\n      const executorInfo =\n        await PushChain.utils.account.convertOriginToExecutor(\n          pushClientNewSolana.universal.origin,\n          { onlyCompute: true }\n        );\n      const pcBeforeUEA = await pushEvmClient.getBalance(executorInfo.address);\n      const pcBeforeRecipient = await pushEvmClient.getBalance(\n        '0x1234567890123456789012345678901234567890'\n      );\n      console.log(\n        'Executor PC balance before (wei):',\n        pcBeforeRecipient.toString()\n      );\n\n      const tx = await pushClientNewSolana.universal.sendTransaction({\n        to: '0x1234567890123456789012345678901234567890',\n        value: BigInt(1),\n      });\n      expect(tx).toBeDefined();\n      console.log('txHash', tx.hash);\n      await tx.wait();\n\n      await new Promise((resolve) => setTimeout(resolve, 15000));\n\n      const pcAfterRecipient = await pushEvmClient.getBalance(\n        '0x1234567890123456789012345678901234567890'\n      );\n      const pcAfterUEA = await pushEvmClient.getBalance(executorInfo.address);\n      console.log(\n        'Executor PC balance after (wei):',\n        pcAfterRecipient.toString()\n      );\n      expect(pcAfterRecipient > pcBeforeRecipient).toBe(true);\n      expect(pcAfterUEA > pcBeforeUEA).toBe(true);\n    }, 300000);\n  });\n\n  describe('Reinitialize Method', () => {\n    let pushClientEVM: PushChain;\n    let universalSignerEVM: UniversalSigner;\n    let universalSignerEVM2: UniversalSigner;\n    let universalSignerPush: UniversalSigner;\n\n    beforeAll(async () => {\n      // Create first EVM signer\n      const account1 = privateKeyToAccount(generatePrivateKey());\n      const walletClient1 = createWalletClient({\n        account: account1,\n        chain: sepolia,\n        transport: http(EVM_RPC),\n      });\n      universalSignerEVM = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient1,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      // Create second EVM signer for testing signer change\n      const account2 = privateKeyToAccount(generatePrivateKey());\n      const walletClient2 = createWalletClient({\n        account: account2,\n        chain: sepolia,\n        transport: http(EVM_RPC),\n      });\n      universalSignerEVM2 = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient2,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      // Create Push signer\n      const pushTestnet = defineChain({\n        id: parseInt(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].chainId),\n        name: 'Push Testnet',\n        nativeCurrency: {\n          decimals: 18,\n          name: 'PC',\n          symbol: '$PC',\n        },\n        rpcUrls: {\n          default: {\n            http: [CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]],\n          },\n        },\n        blockExplorers: {\n          default: {\n            name: 'Push Testnet Explorer',\n            url: 'https://explorer.testnet.push.org/',\n          },\n        },\n      });\n      const accountPush = privateKeyToAccount(generatePrivateKey());\n      const walletClientPush = createWalletClient({\n        account: accountPush,\n        chain: pushTestnet,\n        transport: http(),\n      });\n      universalSignerPush = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClientPush,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      // Initialize first client\n      pushClientEVM = await PushChain.initialize(universalSignerEVM, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n    });\n\n    describe('Basic functionality', () => {\n      it('should reinitialize with same signer and return new instance', async () => {\n        const newClient = await pushClientEVM.reinitialize(universalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        });\n\n        // Should be different instances\n        expect(newClient).not.toBe(pushClientEVM);\n\n        // But should have same addresses since same signer\n        expect(newClient.universal.origin.address).toBe(\n          pushClientEVM.universal.origin.address\n        );\n        expect(newClient.universal.account).toBe(\n          pushClientEVM.universal.account\n        );\n      });\n\n      it('should reinitialize with different signer', async () => {\n        const newClient = await pushClientEVM.reinitialize(\n          universalSignerEVM2,\n          {\n            network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          }\n        );\n\n        // Should be different instances\n        expect(newClient).not.toBe(pushClientEVM);\n\n        // Should have different addresses since different signer\n        expect(newClient.universal.origin.address).not.toBe(\n          pushClientEVM.universal.origin.address\n        );\n        expect(newClient.universal.account).not.toBe(\n          pushClientEVM.universal.account\n        );\n\n        // New client should have the new signer's address\n        expect(newClient.universal.origin.address).toBe(\n          universalSignerEVM2.account.address\n        );\n      });\n\n      it('should reinitialize with different chain signer', async () => {\n        const newClient = await pushClientEVM.reinitialize(\n          universalSignerPush,\n          {\n            network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          }\n        );\n\n        // Should be different instances\n        expect(newClient).not.toBe(pushClientEVM);\n\n        // Should have different chain and addresses\n        expect(newClient.universal.origin.chain).toBe(\n          PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT\n        );\n        expect(newClient.universal.origin.chain).not.toBe(\n          pushClientEVM.universal.origin.chain\n        );\n      });\n    });\n\n    describe('With different options', () => {\n      it('should reinitialize with custom RPC URLs', async () => {\n        const customRpcUrls = {\n          [CHAIN.ETHEREUM_SEPOLIA]: ['https://custom-sepolia.rpc.com'],\n        };\n\n        const newClient = await pushClientEVM.reinitialize(universalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          rpcUrls: customRpcUrls,\n        });\n\n        expect(newClient).not.toBe(pushClientEVM);\n        expect(newClient).toBeDefined();\n      });\n\n      it('should reinitialize with custom block explorers', async () => {\n        const customBlockExplorers = {\n          [CHAIN.PUSH_TESTNET_DONUT]: [\n            'https://custom-explorer1.push.network',\n            'https://custom-explorer2.push.network',\n          ],\n        };\n\n        const newClient = await pushClientEVM.reinitialize(universalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          blockExplorers: customBlockExplorers,\n        });\n\n        expect(newClient).not.toBe(pushClientEVM);\n\n        const { urls } = newClient.explorer.listUrls();\n        expect(urls).toEqual([\n          'https://custom-explorer1.push.network',\n          'https://custom-explorer2.push.network',\n        ]);\n      });\n\n      it('should reinitialize with printTraces enabled', async () => {\n        const newClient = await pushClientEVM.reinitialize(universalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          printTraces: true,\n        });\n\n        expect(newClient).not.toBe(pushClientEVM);\n        expect(newClient).toBeDefined();\n      });\n\n      it('should reinitialize with progress hook', async () => {\n        const progressEvents: any[] = [];\n        const progressHook = (progress: any) => {\n          progressEvents.push(progress);\n        };\n\n        const newClient = await pushClientEVM.reinitialize(universalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n          progressHook,\n        });\n\n        expect(newClient).not.toBe(pushClientEVM);\n        expect(newClient).toBeDefined();\n      });\n    });\n  });\n\n  describe('Explorer Namespace', () => {\n    it('should get transaction url', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        transport: http(\n          CHAIN_INFO[PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]\n        ),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const pushChainClient = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n\n      const txHash = '0x123';\n      const url = pushChainClient.explorer.getTransactionUrl(txHash);\n      expect(url).toBe(`https://donut.push.network/tx/${txHash}`);\n    });\n\n    it('should list default block explorer URLs', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        transport: http(\n          CHAIN_INFO[PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]\n        ),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const pushChainClient = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n\n      const { urls } = pushChainClient.explorer.listUrls();\n      expect(Array.isArray(urls)).toBe(true);\n      expect(urls).toContain('https://donut.push.network');\n      expect(urls.length).toBeGreaterThan(0);\n    });\n\n    it('should list custom block explorer URLs when provided', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        transport: http(\n          CHAIN_INFO[PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]\n        ),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      const customBlockExplorers = {\n        [CHAIN.PUSH_TESTNET_DONUT]: [\n          'https://custom-explorer1.push.network',\n          'https://custom-explorer2.push.network',\n        ],\n      };\n\n      const pushChainClient = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        blockExplorers: customBlockExplorers,\n      });\n\n      const { urls } = pushChainClient.explorer.listUrls();\n      expect(Array.isArray(urls)).toBe(true);\n      expect(urls).toEqual([\n        'https://custom-explorer1.push.network',\n        'https://custom-explorer2.push.network',\n      ]);\n      expect(urls.length).toBe(2);\n    });\n\n    it('should handle multiple chains with different block explorer configurations', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        transport: http(\n          CHAIN_INFO[PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]\n        ),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n\n      const multiChainBlockExplorers = {\n        [CHAIN.PUSH_TESTNET_DONUT]: ['https://donut-explorer.push.network'],\n        [CHAIN.ETHEREUM_SEPOLIA]: ['https://sepolia.etherscan.io'],\n        [CHAIN.ARBITRUM_SEPOLIA]: ['https://sepolia.arbiscan.io'],\n        [CHAIN.BASE_SEPOLIA]: ['https://sepolia.basescan.org'],\n        [CHAIN.SOLANA_DEVNET]: ['https://explorer.solana.com'],\n      };\n\n      const pushChainClient = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        blockExplorers: multiChainBlockExplorers,\n      });\n\n      const { urls } = pushChainClient.explorer.listUrls();\n      expect(Array.isArray(urls)).toBe(true);\n      expect(urls).toEqual(['https://donut-explorer.push.network']);\n      expect(urls.length).toBe(1);\n    });\n  });\n\n  // Individual test suites for each EVM chain (for IDE run button support)\n  describe('Universal.sendTransaction (FUNDS_TX via UniversalGatewayV0) - Ethereum Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[0]; // Ethereum Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n    let account: PrivateKeyAccount;\n    let client: PushChain;\n\n    beforeAll(async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n\n      const result = await setupEVMChainClient(config, PRIVATE_KEY);\n      account = result.account;\n      client = result.client;\n    });\n\n    it('integration: sendFunds USDT via UniversalGatewayV0', async () => {\n      await testSendFundsUSDTNoValue(client, account, config);\n    }, 300000);\n\n    it('integration: sendFunds ETH self', async () => {\n      await testSendFundsETH(client, config, 'self');\n    }, 300000);\n\n    it('integration: sendFunds ETH other', async () => {\n      await testSendFundsETH(client, config, 'other');\n    }, 300000);\n\n    it('integration: sendTxWithFunds USDT Recipient other', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'other');\n    }, 500000);\n\n    it('integration: sendFunds USDT other new wallet deploy UEA other', async () => {\n      await testFundsUSDTNoValueNewWalletDeployUEA(\n        client,\n        account,\n        config,\n        'other'\n      );\n    }, 500000);\n\n    it('integration: sendFunds USDT other new wallet deploy UEA self', async () => {\n      await testFundsUSDTNoValueNewWalletDeployUEA(\n        client,\n        account,\n        config,\n        'self'\n      );\n    }, 500000);\n\n    it('integration: sendTxWithFunds USDT Recipient other new wallet deploy UEA', async () => {\n      await testSendFundsWithPayloadUSDTWithValueNewWalletDeployUEA(\n        client,\n        account,\n        config,\n        'other'\n      );\n    }, 500000);\n\n    it('integration: sendTxWithFunds USDT Recipient self', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'self');\n    }, 500000);\n\n    it('integration: pay gas with USDT via UniversalGatewayV0', async () => {\n      await testSendTxWithFundsPayGasUSDT(client, account, config);\n    }, 500000);\n    it('integration: sendTxWithFunds ETH should throw (not supported)', async () => {\n      try {\n        const bridgeAmount = BigInt(1);\n        const UCABI = [\n          {\n            inputs: [],\n            name: 'increment',\n            outputs: [],\n            stateMutability: 'nonpayable',\n            type: 'function',\n          },\n        ];\n        const COUNTER_ADDRESS =\n          '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n        const data = PushChain.utils.helpers.encodeTxData({\n          abi: UCABI,\n          functionName: 'increment',\n        });\n\n        const tenUsdt = PushChain.utils.helpers.parseUnits('10', {\n          decimals: client.payable.token.USDT.decimals,\n        });\n        const quote = await client.funds.getConversionQuote(tenUsdt, {\n          from: client.payable.token.USDT,\n          to: client.moveable.token.WETH,\n        });\n        const ethValue = BigInt(quote.amountOut);\n\n        await expect(\n          client.universal.sendTransaction({\n            to: COUNTER_ADDRESS,\n            value: ethValue,\n            data,\n            funds: { amount: bridgeAmount, token: client.moveable.token.ETH },\n          })\n        ).rejects.toThrow(\n          'Only ERC-20 tokens are supported for funds+payload on EVM; native and permit2 are not supported yet'\n        );\n      } catch (err) {\n        console.warn(\n          `ETH sendTxWithFunds flow failed (non-fatal for test on ${config.name}):`,\n          err\n        );\n      }\n    });\n  });\n\n  describe('Universal.sendTransaction (FUNDS_TX via UniversalGatewayV0) - Arbitrum Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[1]; // Arbitrum Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n    let account: PrivateKeyAccount;\n    let client: PushChain;\n\n    beforeAll(async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n\n      const result = await setupEVMChainClient(config, PRIVATE_KEY);\n      account = result.account;\n      client = result.client;\n    });\n\n    it('integration: sendFunds USDT via UniversalGatewayV0', async () => {\n      await testSendFundsUSDTNoValue(client, account, config);\n    }, 300000);\n\n    it('integration: sendFunds ETH other', async () => {\n      await testSendFundsETH(client, config, 'other');\n    }, 300000);\n\n    it('integration: sendTxWithFunds USDT Recipient other', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'other');\n    }, 500000);\n\n    it('integration: sendTxWithFunds USDT Recipient self', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'self');\n    }, 500000);\n\n    it('integration: pay gas with USDT via UniversalGatewayV0', async () => {\n      await testSendTxWithFundsPayGasUSDT(client, account, config);\n    }, 500000);\n  });\n\n  describe('Universal.sendTransaction (FUNDS_TX via UniversalGatewayV0) - Base Sepolia', () => {\n    const config = EVM_CHAIN_CONFIGS[2]; // Base Sepolia\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n    let account: PrivateKeyAccount;\n    let client: PushChain;\n\n    beforeAll(async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n\n      const result = await setupEVMChainClient(config, PRIVATE_KEY);\n      account = result.account;\n      client = result.client;\n    });\n\n    it('integration: sendFunds USDT via UniversalGatewayV0', async () => {\n      await testSendFundsUSDTNoValue(client, account, config);\n    }, 300000);\n\n    it('integration: sendFunds USDT With Value to other', async () => {\n      await testSendFundsUSDTWithValue(client, account, config, 'self');\n    }, 300000);\n\n    it('integration: sendFunds USDT With Value to other', async () => {\n      await testSendFundsUSDTWithValue(client, account, config, 'other');\n    }, 300000);\n\n    it('integration: sendFunds ETH other', async () => {\n      await testSendFundsETH(client, config, 'other');\n    }, 300000);\n\n    it('integration: sendTxWithFunds USDT No Value Recipient Other', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'other');\n    }, 500000);\n\n    it('integration: sendTxWithFunds USDT No Value Recipient Self', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'self');\n    }, 500000);\n\n    it('integration: sendTxWithFunds With Value USDT other', async () => {\n      await testSendTxWithFundsUSDTWithValue(client, account, config, 'other');\n    }, 500000);\n\n    it('integration: sendTxWithFunds With Value USDT self', async () => {\n      await testSendTxWithFundsUSDTWithValue(client, account, config, 'self');\n    }, 500000);\n\n    it('integration: value + payload', async () => {\n      await testSendTxValueAndPayload(client, account, config);\n    }, 500000);\n\n    it('integration: payload only', async () => {\n      await testSendTxPayloadOnly(client, account, config);\n    }, 500000);\n  });\n\n  describe('Universal.sendTransaction (FUNDS_TX via UniversalGatewayV0) - BNB Testnet', () => {\n    const config = EVM_CHAIN_CONFIGS[3]; // BNB Testnet\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as\n      | `0x${string}`\n      | undefined;\n    let account: PrivateKeyAccount;\n    let client: PushChain;\n\n    beforeAll(async () => {\n      if (!PRIVATE_KEY) {\n        throw new Error('EVM_PRIVATE_KEY environment variable is not set');\n      }\n\n      const result = await setupEVMChainClient(config, PRIVATE_KEY);\n      account = result.account;\n      client = result.client;\n    });\n\n    it('integration: sendFunds USDT via UniversalGatewayV0', async () => {\n      await testSendFundsUSDTNoValue(client, account, config);\n    }, 300000);\n\n    it('integration: sendFunds BNB other', async () => {\n      await testSendFundsETH(client, config, 'other');\n    }, 300000);\n\n    it('integration: sendTxWithFunds USDT Recipient other', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'other');\n    }, 500000);\n\n    it('integration: sendTxWithFunds USDT Recipient self', async () => {\n      await testSendTxWithFundsUSDTNoValue(client, account, config, 'self');\n    }, 500000);\n  });\n\n  // Test for unsupported origin chains (only needs to run once, not per chain)\n  describe('Universal.sendTransaction - Unsupported chains', () => {\n    it('should throw on unsupported origin chains', async () => {\n      // Use SVM signer (unsupported for FUNDS_TX origin)\n      const accountSVM = Keypair.generate();\n      const svmSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n        accountSVM,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.SOLANA_DEVNET,\n          library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n        }\n      );\n      const svmClient = await PushChain.initialize(svmSigner, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        rpcUrls: { [CHAIN.ETHEREUM_SEPOLIA]: [EVM_RPC] },\n      });\n\n      const amount = PushChain.utils.helpers.parseUnits('100', { decimals: 6 });\n      await expect(\n        svmClient.universal.sendTransaction({\n          to: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n          funds: {\n            amount,\n            token: {\n              symbol: 'USDC',\n              decimals: 6,\n              address: '0xA0b8',\n              requiresApprove: true,\n            } as any,\n          },\n        } as any)\n      ).rejects.toThrow(/Unsupported token mechanism on Solana/i);\n    });\n  });\n\n  describe('Solana sendTransaction (FUNDS_TX via pushsolanagateway - Solana Devnet)', () => {\n    // Live RPCs can be slower\n    const SOL_PRIVATE_KEY =\n      (process.env['SOLANA_PRIVATE_KEY'] as string | undefined) ||\n      (process.env['SVM_PRIVATE_KEY'] as string | undefined);\n    let signer: UniversalSigner;\n    let client: PushChain;\n\n    function getSolKeypairFromEnv(): Keypair {\n      if (!SOL_PRIVATE_KEY) {\n        throw new Error('SOL_PRIVATE_KEY (or SVM_PRIVATE_KEY) is not set');\n      }\n      try {\n        // Try JSON array format\n        if (SOL_PRIVATE_KEY.trim().startsWith('[')) {\n          const arr = JSON.parse(SOL_PRIVATE_KEY) as number[];\n          return Keypair.fromSecretKey(Uint8Array.from(arr));\n        }\n        // Else assume base58-encoded secret key\n        const decoded = anchorUtils.bytes.bs58.decode(SOL_PRIVATE_KEY.trim());\n        return Keypair.fromSecretKey(Uint8Array.from(decoded));\n      } catch (e) {\n        throw new Error('Invalid SOL_PRIVATE_KEY format');\n      }\n    }\n\n    beforeAll(async () => {\n      const kp = getSolKeypairFromEnv();\n      signer = await PushChain.utils.signer.toUniversalFromKeypair(kp, {\n        chain: PushChain.CONSTANTS.CHAIN.SOLANA_DEVNET,\n        library: PushChain.CONSTANTS.LIBRARY.SOLANA_WEB3JS,\n      });\n      client = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        progressHook: (progress) => {\n          console.log('Progress (SVM)', progress);\n        },\n        // rpcUrls: {\n        //   [CHAIN.SOLANA_DEVNET]: [SOLANA_RPC],\n        // },\n      });\n    });\n\n    describe('sendFundsNative function and sendFunds function', () => {\n      it('sendFundsNative function', async () => {\n        try {\n          // const amountLamports = PushChain.utils.helpers.parseUnits('0.001', 9);\n          const amountLamports = BigInt(1);\n          // const recipient = client.universal.account;\n          const recipient = '0x0000000000000000000000000000000000042101';\n\n          // Check pSOL balance on PushChain before bridging\n          const pushChainClient = new EvmClient({\n            rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n          });\n          const pSOL_ADDRESS =\n            SYNTHETIC_PUSH_ERC20[PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT]\n              .pSOL;\n          const balanceBefore = await pushChainClient.getErc20Balance({\n            tokenAddress: pSOL_ADDRESS,\n            ownerAddress: recipient as `0x${string}`,\n          });\n          console.log('pSOL balance before bridging', balanceBefore);\n\n          const resNative = await client.universal.sendTransaction({\n            to: recipient,\n            funds: { amount: amountLamports, token: client.moveable.token.SOL },\n          });\n          console.log('txHash', resNative.hash);\n\n          const receipt = await resNative.wait();\n          expect(receipt.status).toBe(1);\n          console.log('SVM Native Receipt', receipt);\n\n          // Check pSOL balance on PushChain after bridging\n          const balanceAfter = await pushChainClient.getErc20Balance({\n            tokenAddress: pSOL_ADDRESS,\n            ownerAddress: recipient as `0x${string}`,\n          });\n          console.log('pSOL balance after bridging', balanceAfter);\n          expect(balanceAfter > balanceBefore).toBe(true);\n        } catch (err) {\n          console.error('SVM sendFunds SOL flow failed (non-fatal):', err);\n        }\n      }, 300000);\n\n      it('sendFunds function SPL', async () => {\n        const amountLamports = BigInt(1);\n        // const recipient = client.universal.account;\n        const recipient = '0x0000000000000000000000000000000000042101';\n        // Check pUSDT (USDT.sol) balance on PushChain before bridging\n        const pushChainClient = new EvmClient({\n          rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n        });\n        const USDT_SOL_ADDRESS = PushChain.utils.tokens.getPRC20Mapping(\n          client.moveable.token.USDT\n        );\n        const balanceBefore = await pushChainClient.getErc20Balance({\n          tokenAddress: USDT_SOL_ADDRESS,\n          ownerAddress: recipient as `0x${string}`,\n        });\n        console.log('pUSDT(SOL) balance before bridging', balanceBefore);\n        // Compute USDT SPL balance before sending\n        const connection = new Connection(SOLANA_RPC, 'confirmed');\n        const mintPk = new PublicKey(client.moveable.token.USDT.address);\n        const ownerPk = new PublicKey(signer.account.address);\n        const TOKEN_PROGRAM_ID = new PublicKey(\n          'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n        );\n        const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\n          'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\n        );\n        const ata = PublicKey.findProgramAddressSync(\n          [ownerPk.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPk.toBuffer()],\n          ASSOCIATED_TOKEN_PROGRAM_ID\n        )[0];\n        let usdtRawAmount = BigInt(0);\n        try {\n          const balInfo = await connection.getTokenAccountBalance(ata);\n          // amount is a string of the raw token units (no decimals applied)\n          usdtRawAmount = BigInt(balInfo.value.amount);\n        } catch (_) {\n          // ATA may not exist or balance is zero; default stays 0\n        }\n        console.log(\n          'USDT (SPL) balance before send (raw units):',\n          usdtRawAmount.toString()\n        );\n        const resNative = await client.universal.sendTransaction({\n          to: recipient,\n          funds: {\n            amount: amountLamports,\n            token: client.moveable.token.USDT,\n          },\n        });\n\n        const receipt = await resNative.wait();\n        console.log('txHash', resNative.hash);\n        expect(receipt.status).toBe(1);\n        // Check pUSDT (USDT.sol) balance on PushChain after bridging\n        const balanceAfter = await pushChainClient.getErc20Balance({\n          tokenAddress: USDT_SOL_ADDRESS,\n          ownerAddress: recipient as `0x${string}`,\n        });\n        console.log('pUSDT(SOL) balance after bridging', balanceAfter);\n        expect(balanceAfter > balanceBefore).toBe(true);\n      }, 300000);\n    });\n\n    describe('sendTxWithFunds function', () => {\n      it('sendTxWithFunds SOL function', async () => {\n        const bridgeAmount = BigInt(1);\n        const COUNTER_ABI = [\n          {\n            inputs: [],\n            name: 'increment',\n            outputs: [],\n            stateMutability: 'nonpayable',\n            type: 'function',\n          },\n          {\n            inputs: [],\n            name: 'countPC',\n            outputs: [\n              {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n              },\n            ],\n            stateMutability: 'view',\n            type: 'function',\n          },\n        ];\n        const COUNTER_ADDRESS =\n          '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n        const data = PushChain.utils.helpers.encodeTxData({\n          abi: COUNTER_ABI,\n          functionName: 'increment',\n        });\n\n        const pushPublicClient = createPublicClient({\n          transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n        });\n\n        // Ensure the address is a contract on Push chain\n        const bytecode = await pushPublicClient.getBytecode({\n          address: COUNTER_ADDRESS,\n        });\n        if (!bytecode || bytecode === '0x') {\n          console.warn(\n            `Skipping test: no contract bytecode at ${COUNTER_ADDRESS} on Push Testnet`\n          );\n          return;\n        }\n\n        const beforeCount = (await pushPublicClient.readContract({\n          abi: COUNTER_ABI,\n          address: COUNTER_ADDRESS,\n          functionName: 'countPC',\n        })) as bigint;\n\n        // Check pSOL balance on PushChain before bridging\n        const recipient = client.universal.account;\n        const pushChainClient = new EvmClient({\n          rpcUrls: CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC,\n        });\n        const pSOL_ADDRESS =\n          SYNTHETIC_PUSH_ERC20[PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT]\n            .pSOL;\n        const balanceBefore = await pushChainClient.getErc20Balance({\n          tokenAddress: pSOL_ADDRESS,\n          ownerAddress: COUNTER_ADDRESS,\n        });\n        console.log(\n          'pSOL balance before bridging (sendTxWithFunds SOL)',\n          balanceBefore\n        );\n\n        const res = await client.universal.sendTransaction({\n          to: COUNTER_ADDRESS,\n          data,\n          funds: { amount: bridgeAmount, token: client.moveable.token.SOL },\n        });\n\n        expect(typeof res.hash).toBe('string');\n        expect(res.hash.length).toBeGreaterThan(0);\n        console.log('SVM sendTxWithFunds hash', res.hash);\n        console.log('txHash', res.hash);\n\n        await res.wait();\n\n        // Check pSOL balance on PushChain after bridging\n        const balanceAfter = await pushChainClient.getErc20Balance({\n          tokenAddress: pSOL_ADDRESS,\n          ownerAddress: COUNTER_ADDRESS,\n        });\n        expect(balanceAfter > balanceBefore).toBe(true);\n\n        const afterCount = (await pushPublicClient.readContract({\n          abi: COUNTER_ABI,\n          address: COUNTER_ADDRESS,\n          functionName: 'countPC',\n        })) as bigint;\n        expect(afterCount).toBe(beforeCount + BigInt(1));\n      }, 300000);\n\n      it('sendTxWithFunds USDT function', async () => {\n        const bridgeAmount = BigInt(1);\n        const COUNTER_ABI = [\n          {\n            inputs: [],\n            name: 'increment',\n            outputs: [],\n            stateMutability: 'nonpayable',\n            type: 'function',\n          },\n          {\n            inputs: [],\n            name: 'countPC',\n            outputs: [\n              {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256',\n              },\n            ],\n            stateMutability: 'view',\n            type: 'function',\n          },\n        ];\n        const COUNTER_ADDRESS =\n          '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n        const data = PushChain.utils.helpers.encodeTxData({\n          abi: COUNTER_ABI,\n          functionName: 'increment',\n        });\n\n        const pushPublicClient = createPublicClient({\n          transport: http(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]),\n        });\n\n        // Ensure the address is a contract on Push chain\n        const bytecode = await pushPublicClient.getBytecode({\n          address: COUNTER_ADDRESS,\n        });\n        if (!bytecode || bytecode === '0x') {\n          console.warn(\n            `Skipping test: no contract bytecode at ${COUNTER_ADDRESS} on Push Testnet`\n          );\n          return;\n        }\n\n        const beforeCount = (await pushPublicClient.readContract({\n          abi: COUNTER_ABI,\n          address: COUNTER_ADDRESS,\n          functionName: 'countPC',\n        })) as bigint;\n\n        const res = await client.universal.sendTransaction({\n          to: COUNTER_ADDRESS,\n          data,\n          funds: { amount: bridgeAmount, token: client.moveable.token.USDT },\n        });\n\n        expect(typeof res.hash).toBe('string');\n        expect(res.hash.length).toBeGreaterThan(0);\n        console.log('SVM sendTxWithFunds USDT hash', res.hash);\n        console.log('txHash', res.hash);\n\n        await res.wait();\n\n        const afterCount = (await pushPublicClient.readContract({\n          abi: COUNTER_ABI,\n          address: COUNTER_ADDRESS,\n          functionName: 'countPC',\n        })) as bigint;\n        expect(afterCount).toBe(beforeCount + BigInt(1));\n      }, 300000);\n\n      it('sendTxWithFunds payWith USDT should fail on Solana Devnet', async () => {\n        const bridgeAmount = BigInt(1);\n        const COUNTER_ABI = [\n          {\n            inputs: [],\n            name: 'increment',\n            outputs: [],\n            stateMutability: 'nonpayable',\n            type: 'function',\n          },\n        ];\n        const COUNTER_ADDRESS =\n          '0x5FbDB2315678afecb367f032d93F642f64180aa3' as `0x${string}`;\n        const data = PushChain.utils.helpers.encodeTxData({\n          abi: COUNTER_ABI,\n          functionName: 'increment',\n        });\n\n        console.log(client.moveable.token.USDT);\n\n        await expect(\n          client.universal.sendTransaction({\n            to: COUNTER_ADDRESS,\n            value: BigInt(0),\n            data,\n            funds: {\n              amount: bridgeAmount,\n              token: client.moveable.token.USDT,\n            },\n            payGasWith: {\n              token: client.payable.token.USDT,\n            },\n          })\n        ).rejects.toThrow('Pay-with token is not supported on Solana');\n      });\n    });\n\n    it('sendTxWithFunds SOL with new Solana wallet deploy UEA (recipient other)', async () => {\n      await testFundsSOLNoValueNewWalletDeployUEA_SVM('other');\n    }, 300000);\n  });\n\n  describe('Validation: funds + value guard', () => {\n    it('Should fail when moving funds when client connected to Push Chain', async () => {\n      // Create a client on Push chain (so we fail early on the sepolia-only check without network calls)\n      const pushTestnet = defineChain({\n        id: parseInt(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].chainId),\n        name: 'Push Testnet',\n        nativeCurrency: { decimals: 18, name: 'PC', symbol: '$PC' },\n        rpcUrls: {\n          default: {\n            http: [CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]],\n          },\n        },\n      });\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        chain: pushTestnet,\n        transport: http(),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const client = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n\n      const recipient =\n        '0x1234567890123456789012345678901234567890' as `0x${string}`;\n\n      // 2) value = 0 with funds should pass the guard and then fail on sepolia-only check\n      await expect(\n        client.universal.sendTransaction({\n          to: recipient,\n          value: BigInt(0),\n          funds: { amount: BigInt(1) },\n        })\n      ).rejects.toThrow(\n        'Funds bridging is only supported on Ethereum Sepolia, Arbitrum Sepolia, Base Sepolia, BNB Testnet, and Solana Devnet for now'\n      );\n    });\n  });\n\n  describe('Funds Namespace (Integration - Uniswap live on Sepolia)', () => {\n    // Live RPCs can be slower\n    jest.setTimeout(30000);\n\n    it('should error on unsupported chains (non-Ethereum origin)', async () => {\n      // Create a client on Push chain (origin not Ethereum)\n      const pushAccount = privateKeyToAccount(generatePrivateKey());\n      const pushWallet = createWalletClient({\n        account: pushAccount,\n        chain: defineChain({\n          id: parseInt(CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].chainId),\n          name: 'Push Testnet',\n          nativeCurrency: { decimals: 18, name: 'PC', symbol: '$PC' },\n          rpcUrls: {\n            default: {\n              http: [CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0]],\n            },\n          },\n        }),\n        transport: http(),\n      });\n      const pushSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n        pushWallet,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.PUSH_TESTNET_DONUT,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const pushClient = await PushChain.initialize(pushSigner, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n\n      const amountIn = PushChain.utils.helpers.parseUnits('1', 18);\n\n      await expect(\n        pushClient.funds.getConversionQuote(amountIn, {\n          from: pushClient.payable.token.USDT,\n          to: pushClient.moveable.token.ETH,\n        })\n      ).rejects.toThrow(\n        'getConversionQuote is only supported on Ethereum Sepolia for now'\n      );\n    });\n\n    it('sepolia: WETH -> WETH should fail gracefully (no direct pool)', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        chain: sepolia,\n        transport: http(EVM_RPC),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const client = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        rpcUrls: { [CHAIN.ETHEREUM_SEPOLIA]: [EVM_RPC] },\n      });\n\n      // Use WETH9 Sepolia\n      const WETH9 =\n        '0xfff9976782d46cc05630d1f6ebab18b2324d6b14' as `0x${string}`;\n      const amountIn = PushChain.utils.helpers.parseUnits('0.01', 18);\n      await expect(\n        client.funds.getConversionQuote(amountIn, {\n          from: client.payable.token.WETH,\n          // from: { symbol: 'WETH', decimals: 18, address: WETH9 },\n          to: client.moveable.token.WETH,\n          // to: { symbol: 'WETH', decimals: 18, address: WETH9 },\n        })\n      ).rejects.toThrow(/No direct Uniswap V3 pool found/);\n    });\n\n    it('sepolia: WETH -> USDT quote via Uniswap V3', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account,\n        chain: sepolia,\n        transport: http(),\n      });\n      const signer = await PushChain.utils.signer.toUniversalFromKeypair(\n        walletClient,\n        {\n          chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n          library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n        }\n      );\n      const client = await PushChain.initialize(signer, {\n        network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n      });\n\n      const WETH9 =\n        '0xfff9976782d46cc05630d1f6ebab18b2324d6b14' as `0x${string}`; // Sepolia WETH9\n      const USDC =\n        '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238' as `0x${string}`; // Provided Sepolia USDC\n\n      // Quote: 0.005 WETH -> USDC\n      const amountIn = PushChain.utils.helpers.parseUnits('0.005', 18);\n      const quote = await client.funds.getConversionQuote(amountIn, {\n        from: client.payable.token.WETH,\n        to: client.moveable.token.USDT,\n      });\n\n      expect(BigInt(quote.amountOut)).toBeGreaterThan(BigInt(0));\n      expect(quote.rate).toBeGreaterThan(0);\n      expect(quote.route).toEqual(['WETH', 'USDT']);\n    });\n  });\n\n  describe('Helpers Utils Namespace', () => {\n    describe('getChainName', () => {\n      it('should get chain name', () => {\n        // Test Push chains\n        expect(PushChain.utils.chains.getChainName(CHAIN.PUSH_MAINNET)).toBe(\n          'PUSH_MAINNET'\n        );\n        expect(PushChain.utils.chains.getChainName(CHAIN.PUSH_TESTNET)).toBe(\n          'PUSH_TESTNET_DONUT'\n        );\n        expect(\n          PushChain.utils.chains.getChainName(CHAIN.PUSH_TESTNET_DONUT)\n        ).toBe('PUSH_TESTNET_DONUT');\n        expect(PushChain.utils.chains.getChainName(CHAIN.PUSH_LOCALNET)).toBe(\n          'PUSH_LOCALNET'\n        );\n        // Test Ethereum chains\n        expect(\n          PushChain.utils.chains.getChainName(CHAIN.ETHEREUM_MAINNET)\n        ).toBe('ETHEREUM_MAINNET');\n        expect(\n          PushChain.utils.chains.getChainName(CHAIN.ETHEREUM_SEPOLIA)\n        ).toBe('ETHEREUM_SEPOLIA');\n        expect(\n          PushChain.utils.chains.getChainName(CHAIN.ARBITRUM_SEPOLIA)\n        ).toBe('ARBITRUM_SEPOLIA');\n        expect(PushChain.utils.chains.getChainName(CHAIN.BASE_SEPOLIA)).toBe(\n          'BASE_SEPOLIA'\n        );\n        // Test Solana chains\n        expect(PushChain.utils.chains.getChainName(CHAIN.SOLANA_MAINNET)).toBe(\n          'SOLANA_MAINNET'\n        );\n        expect(PushChain.utils.chains.getChainName(CHAIN.SOLANA_TESTNET)).toBe(\n          'SOLANA_TESTNET'\n        );\n        expect(PushChain.utils.chains.getChainName(CHAIN.SOLANA_DEVNET)).toBe(\n          'SOLANA_DEVNET'\n        );\n      });\n\n      it('should handle chain values directly', () => {\n        // Test with raw chain values\n        expect(PushChain.utils.chains.getChainName('eip155:9')).toBe(\n          'PUSH_MAINNET'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:42101')).toBe(\n          'PUSH_TESTNET_DONUT'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:9001')).toBe(\n          'PUSH_LOCALNET'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:1')).toBe(\n          'ETHEREUM_MAINNET'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:11155111')).toBe(\n          'ETHEREUM_SEPOLIA'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:421614')).toBe(\n          'ARBITRUM_SEPOLIA'\n        );\n        expect(PushChain.utils.chains.getChainName('eip155:84532')).toBe(\n          'BASE_SEPOLIA'\n        );\n        expect(\n          PushChain.utils.chains.getChainName(\n            'solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'\n          )\n        ).toBe('SOLANA_MAINNET');\n        expect(\n          PushChain.utils.chains.getChainName(\n            'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z'\n          )\n        ).toBe('SOLANA_TESTNET');\n        expect(\n          PushChain.utils.chains.getChainName(\n            'solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1'\n          )\n        ).toBe('SOLANA_DEVNET');\n      });\n\n      it('should return undefined for invalid chain values', () => {\n        // Test with invalid chain values\n        expect(\n          PushChain.utils.chains.getChainName('invalid-chain')\n        ).toBeUndefined();\n        expect(\n          PushChain.utils.chains.getChainName('eip155:999999')\n        ).toBeUndefined();\n        expect(\n          PushChain.utils.chains.getChainName('solana:invalid')\n        ).toBeUndefined();\n        expect(PushChain.utils.chains.getChainName('')).toBeUndefined();\n      });\n\n      it('should handle case sensitivity correctly (returns undefined)', () => {\n        // Test that the function is case sensitive\n        expect(PushChain.utils.chains.getChainName('EIP155:1')).toBeUndefined();\n        expect(\n          PushChain.utils.chains.getChainName(\n            'SOLANA:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp'\n          )\n        ).toBeUndefined();\n      });\n\n      it('should handle whitespace correctly (returns undefined)', () => {\n        // Test that whitespace is not ignored\n        expect(\n          PushChain.utils.chains.getChainName(' eip155:1')\n        ).toBeUndefined();\n        expect(\n          PushChain.utils.chains.getChainName('eip155:1 ')\n        ).toBeUndefined();\n      });\n    });\n\n    describe('getChainNamespace', () => {\n      it('should get chain namespace from enum key name', () => {\n        expect(\n          PushChain.utils.chains.getChainNamespace('ETHEREUM_SEPOLIA')\n        ).toBe(CHAIN.ETHEREUM_SEPOLIA);\n\n        expect(\n          PushChain.utils.chains.getChainNamespace('ETHEREUM_MAINNET')\n        ).toBe(CHAIN.ETHEREUM_MAINNET);\n\n        expect(\n          PushChain.utils.chains.getChainNamespace('ARBITRUM_SEPOLIA')\n        ).toBe(CHAIN.ARBITRUM_SEPOLIA);\n\n        expect(PushChain.utils.chains.getChainNamespace('BASE_SEPOLIA')).toBe(\n          CHAIN.BASE_SEPOLIA\n        );\n\n        expect(\n          PushChain.utils.chains.getChainNamespace('PUSH_TESTNET_DONUT')\n        ).toBe(CHAIN.PUSH_TESTNET_DONUT);\n\n        expect(PushChain.utils.chains.getChainNamespace('SOLANA_DEVNET')).toBe(\n          CHAIN.SOLANA_DEVNET\n        );\n      });\n\n      it('should return input unchanged when already a namespace', () => {\n        expect(\n          PushChain.utils.chains.getChainNamespace(CHAIN.ETHEREUM_SEPOLIA)\n        ).toBe(CHAIN.ETHEREUM_SEPOLIA);\n\n        expect(\n          PushChain.utils.chains.getChainNamespace(CHAIN.ARBITRUM_SEPOLIA)\n        ).toBe(CHAIN.ARBITRUM_SEPOLIA);\n\n        expect(\n          PushChain.utils.chains.getChainNamespace(CHAIN.BASE_SEPOLIA)\n        ).toBe(CHAIN.BASE_SEPOLIA);\n\n        expect(\n          PushChain.utils.chains.getChainNamespace(CHAIN.PUSH_TESTNET_DONUT)\n        ).toBe(CHAIN.PUSH_TESTNET_DONUT);\n      });\n\n      it('should return undefined for unsupported names', () => {\n        expect(\n          PushChain.utils.chains.getChainNamespace('UNKNOWN_CHAIN')\n        ).toBeUndefined();\n        expect(\n          PushChain.utils.chains.getChainNamespace('ethereum_sepolia' as any)\n        ).toBeUndefined();\n        expect(PushChain.utils.chains.getChainNamespace('')).toBeUndefined();\n      });\n    });\n\n    describe('getSupportedChain', () => {\n      it('should return supported chains for TESTNET', () => {\n        const res = PushChain.utils.chains.getSupportedChains(\n          PushChain.CONSTANTS.PUSH_NETWORK.TESTNET\n        );\n        expect(res).toEqual({\n          chains: [\n            CHAIN.ETHEREUM_SEPOLIA,\n            CHAIN.ARBITRUM_SEPOLIA,\n            CHAIN.BASE_SEPOLIA,\n            CHAIN.SOLANA_DEVNET,\n          ],\n        });\n      });\n\n      it('should return supported chains for TESTNET_DONUT', () => {\n        const res = PushChain.utils.chains.getSupportedChains(\n          PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT\n        );\n        expect(res).toEqual({\n          chains: [\n            CHAIN.ETHEREUM_SEPOLIA,\n            CHAIN.ARBITRUM_SEPOLIA,\n            CHAIN.BASE_SEPOLIA,\n            CHAIN.SOLANA_DEVNET,\n          ],\n        });\n      });\n\n      it('should return supported chains for LOCALNET', () => {\n        const res = PushChain.utils.chains.getSupportedChains(\n          PushChain.CONSTANTS.PUSH_NETWORK.LOCALNET\n        );\n        expect(res).toEqual({\n          chains: [\n            CHAIN.ETHEREUM_SEPOLIA,\n            CHAIN.ARBITRUM_SEPOLIA,\n            CHAIN.BASE_SEPOLIA,\n            CHAIN.SOLANA_DEVNET,\n          ],\n        });\n      });\n\n      it('should return empty list for MAINNET', () => {\n        const res = PushChain.utils.chains.getSupportedChains(\n          PushChain.CONSTANTS.PUSH_NETWORK.MAINNET\n        );\n        expect(res).toEqual({ chains: [] });\n      });\n    });\n\n    describe('encodeTxData', () => {\n      const testAbi = [\n        {\n          inputs: [],\n          stateMutability: 'nonpayable',\n          type: 'constructor',\n        },\n        {\n          anonymous: false,\n          inputs: [\n            {\n              indexed: false,\n              internalType: 'uint256',\n              name: 'newCount',\n              type: 'uint256',\n            },\n            {\n              indexed: true,\n              internalType: 'address',\n              name: 'caller',\n              type: 'address',\n            },\n            {\n              indexed: false,\n              internalType: 'string',\n              name: 'chainNamespace',\n              type: 'string',\n            },\n            {\n              indexed: false,\n              internalType: 'string',\n              name: 'chainId',\n              type: 'string',\n            },\n          ],\n          name: 'CountIncremented',\n          type: 'event',\n        },\n        {\n          inputs: [],\n          name: 'increment',\n          outputs: [],\n          stateMutability: 'nonpayable',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'reset',\n          outputs: [],\n          stateMutability: 'nonpayable',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'countEth',\n          outputs: [\n            {\n              internalType: 'uint256',\n              name: '',\n              type: 'uint256',\n            },\n          ],\n          stateMutability: 'view',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'countPC',\n          outputs: [\n            {\n              internalType: 'uint256',\n              name: '',\n              type: 'uint256',\n            },\n          ],\n          stateMutability: 'view',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'countSol',\n          outputs: [\n            {\n              internalType: 'uint256',\n              name: '',\n              type: 'uint256',\n            },\n          ],\n          stateMutability: 'view',\n          type: 'function',\n        },\n        {\n          inputs: [],\n          name: 'getCount',\n          outputs: [\n            {\n              internalType: 'uint256',\n              name: '',\n              type: 'uint256',\n            },\n          ],\n          stateMutability: 'view',\n          type: 'function',\n        },\n      ];\n\n      it('should encode function data correctly', () => {\n        const result = PushChain.utils.helpers.encodeTxData({\n          abi: testAbi,\n          functionName: 'increment',\n        });\n        expect(result).toBe('0xd09de08a');\n      });\n\n      it('should encode function data with arguments', () => {\n        // Test with a function that has no arguments (reset)\n        const result = PushChain.utils.helpers.encodeTxData({\n          abi: testAbi,\n          functionName: 'reset',\n        });\n        expect(result).toMatch(/^0x[a-fA-F0-9]+$/);\n        expect(typeof result).toBe('string');\n      });\n\n      it('should throw error for invalid ABI', () => {\n        expect(() =>\n          PushChain.utils.helpers.encodeTxData({\n            abi: 'invalid' as any,\n            functionName: 'increment',\n          })\n        ).toThrow('ABI must be an array');\n        expect(() =>\n          PushChain.utils.helpers.encodeTxData({\n            abi: null as any,\n            functionName: 'increment',\n          })\n        ).toThrow('ABI must be an array');\n      });\n\n      it('should throw error for invalid arguments', () => {\n        expect(() =>\n          PushChain.utils.helpers.encodeTxData({\n            abi: testAbi,\n            functionName: 'increment',\n            args: 'invalid' as any,\n          })\n        ).toThrow('Arguments must be an array');\n      });\n\n      it('should throw error for non-existent function', () => {\n        expect(() =>\n          PushChain.utils.helpers.encodeTxData({\n            abi: testAbi,\n            functionName: 'nonExistentFunction',\n          })\n        ).toThrow(\"Function 'nonExistentFunction' not found in ABI\");\n      });\n\n      it('should handle empty args array', () => {\n        const result = PushChain.utils.helpers.encodeTxData({\n          abi: testAbi,\n          functionName: 'increment',\n          args: [],\n        });\n        expect(result).toBe('0xd09de08a');\n      });\n    });\n\n    describe('parseUnits', () => {\n      it('should parse integer values correctly', () => {\n        // Test basic integer parsing like the viem example\n        const result = PushChain.utils.helpers.parseUnits('420', 9);\n        expect(result).toBe(BigInt('420000000000'));\n      });\n\n      it('should parse decimal values correctly', () => {\n        // Test ETH to wei conversion (18 decimals)\n        const result1 = PushChain.utils.helpers.parseUnits('1.5', 18);\n        expect(result1).toBe(BigInt('1500000000000000000'));\n\n        // Test smaller decimal values\n        const result2 = PushChain.utils.helpers.parseUnits('0.1', 6);\n        expect(result2).toBe(BigInt('100000'));\n\n        // Test fractional values with fewer decimals than exponent\n        const result3 = PushChain.utils.helpers.parseUnits('1.23', 6);\n        expect(result3).toBe(BigInt('1230000'));\n      });\n\n      it('should handle zero values', () => {\n        const result1 = PushChain.utils.helpers.parseUnits('0', 18);\n        expect(result1).toBe(BigInt('0'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('0.0', 6);\n        expect(result2).toBe(BigInt('0'));\n\n        const result3 = PushChain.utils.helpers.parseUnits('0.000', 18);\n        expect(result3).toBe(BigInt('0'));\n      });\n\n      it('should handle negative values', () => {\n        const result1 = PushChain.utils.helpers.parseUnits('-1', 18);\n        expect(result1).toBe(BigInt('-1000000000000000000'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('-0.5', 6);\n        expect(result2).toBe(BigInt('-500000'));\n      });\n\n      it('should handle values without decimals', () => {\n        const result1 = PushChain.utils.helpers.parseUnits('100', 0);\n        expect(result1).toBe(BigInt('100'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('1000', 3);\n        expect(result2).toBe(BigInt('1000000'));\n      });\n\n      it('should handle values with leading/trailing whitespace', () => {\n        const result1 = PushChain.utils.helpers.parseUnits(' 1.5 ', 18);\n        expect(result1).toBe(BigInt('1500000000000000000'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('\\t420\\n', 9);\n        expect(result2).toBe(BigInt('420000000000'));\n      });\n\n      it('should handle values starting with decimal point', () => {\n        const result1 = PushChain.utils.helpers.parseUnits('.5', 18);\n        expect(result1).toBe(BigInt('500000000000000000'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('.123', 6);\n        expect(result2).toBe(BigInt('123000'));\n      });\n\n      it('should handle exact decimal place matches', () => {\n        // When decimal places exactly match the exponent\n        const result = PushChain.utils.helpers.parseUnits('1.123456', 6);\n        expect(result).toBe(BigInt('1123456'));\n      });\n\n      it('should throw error for invalid value types', () => {\n        expect(() =>\n          PushChain.utils.helpers.parseUnits(123 as any, 18)\n        ).toThrow('Value must be a string');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits(null as any, 18)\n        ).toThrow('Value must be a string');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits(undefined as any, 18)\n        ).toThrow('Value must be a string');\n      });\n\n      it('should throw error for invalid exponent types', () => {\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', '18' as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', null as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('1', 1.5)).toThrow(\n          'Exponent must be an integer'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('1', -1)).toThrow(\n          'Exponent must be non-negative'\n        );\n      });\n\n      it('should throw error for empty or invalid value strings', () => {\n        expect(() => PushChain.utils.helpers.parseUnits('', 18)).toThrow(\n          'Value cannot be empty'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('   ', 18)).toThrow(\n          'Value cannot be empty'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('.', 18)).toThrow(\n          'Value must be a valid number string'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('-.', 18)).toThrow(\n          'Value must be a valid number string'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('abc', 18)).toThrow(\n          'Value must be a valid number string'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('1.2.3', 18)).toThrow(\n          'Value must be a valid number string'\n        );\n\n        expect(() => PushChain.utils.helpers.parseUnits('1e5', 18)).toThrow(\n          'Value must be a valid number string'\n        );\n      });\n\n      it('should throw error when decimal places exceed exponent', () => {\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1.123456789', 6)\n        ).toThrow('Value has more decimal places (9) than exponent allows (6)');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('0.12345678901234567890', 18)\n        ).toThrow(\n          'Value has more decimal places (20) than exponent allows (18)'\n        );\n      });\n\n      it('should handle large numbers', () => {\n        const result1 = PushChain.utils.helpers.parseUnits(\n          '999999999999999999',\n          18\n        );\n        expect(result1).toBe(BigInt('999999999999999999000000000000000000'));\n\n        const result2 = PushChain.utils.helpers.parseUnits('1000000', 0);\n        expect(result2).toBe(BigInt('1000000'));\n      });\n\n      it('should handle common token decimal scenarios', () => {\n        // ETH (18 decimals)\n        const ethResult = PushChain.utils.helpers.parseUnits('1', 18);\n        expect(ethResult).toBe(BigInt('1000000000000000000'));\n\n        // USDC (6 decimals)\n        const usdcResult = PushChain.utils.helpers.parseUnits('100', 6);\n        expect(usdcResult).toBe(BigInt('100000000'));\n\n        // BTC (8 decimals)\n        const btcResult = PushChain.utils.helpers.parseUnits('0.00000001', 8);\n        expect(btcResult).toBe(BigInt('1'));\n\n        // Push token (18 decimals) - example amount\n        const pushResult = PushChain.utils.helpers.parseUnits('1000.5', 18);\n        expect(pushResult).toBe(BigInt('1000500000000000000000'));\n      });\n\n      it('should handle object-based exponent input', () => {\n        // Test basic integer parsing with object format\n        const result1 = PushChain.utils.helpers.parseUnits('420', {\n          decimals: 9,\n        });\n        expect(result1).toBe(BigInt('420000000000'));\n\n        // Test ETH to wei conversion (18 decimals) with object format\n        const result2 = PushChain.utils.helpers.parseUnits('1.5', {\n          decimals: 18,\n        });\n        expect(result2).toBe(BigInt('1500000000000000000'));\n\n        // Test smaller decimal values with object format\n        const result3 = PushChain.utils.helpers.parseUnits('0.1', {\n          decimals: 6,\n        });\n        expect(result3).toBe(BigInt('100000'));\n\n        // Test fractional values with fewer decimals than exponent\n        const result4 = PushChain.utils.helpers.parseUnits('1.23', {\n          decimals: 6,\n        });\n        expect(result4).toBe(BigInt('1230000'));\n\n        // Test zero values with object format\n        const result5 = PushChain.utils.helpers.parseUnits('0', {\n          decimals: 18,\n        });\n        expect(result5).toBe(BigInt('0'));\n\n        const result6 = PushChain.utils.helpers.parseUnits('0.0', {\n          decimals: 6,\n        });\n        expect(result6).toBe(BigInt('0'));\n\n        // Test negative values with object format\n        const result7 = PushChain.utils.helpers.parseUnits('-1', {\n          decimals: 18,\n        });\n        expect(result7).toBe(BigInt('-1000000000000000000'));\n\n        const result8 = PushChain.utils.helpers.parseUnits('-0.5', {\n          decimals: 6,\n        });\n        expect(result8).toBe(BigInt('-500000'));\n\n        // Test values without decimals with object format\n        const result9 = PushChain.utils.helpers.parseUnits('100', {\n          decimals: 0,\n        });\n        expect(result9).toBe(BigInt('100'));\n\n        const result10 = PushChain.utils.helpers.parseUnits('1000', {\n          decimals: 3,\n        });\n        expect(result10).toBe(BigInt('1000000'));\n\n        // Test values with leading/trailing whitespace with object format\n        const result11 = PushChain.utils.helpers.parseUnits(' 1.5 ', {\n          decimals: 18,\n        });\n        expect(result11).toBe(BigInt('1500000000000000000'));\n\n        const result12 = PushChain.utils.helpers.parseUnits('\\t420\\n', {\n          decimals: 9,\n        });\n        expect(result12).toBe(BigInt('420000000000'));\n\n        // Test values starting with decimal point with object format\n        const result13 = PushChain.utils.helpers.parseUnits('.5', {\n          decimals: 18,\n        });\n        expect(result13).toBe(BigInt('500000000000000000'));\n\n        const result14 = PushChain.utils.helpers.parseUnits('.123', {\n          decimals: 6,\n        });\n        expect(result14).toBe(BigInt('123000'));\n\n        // Test exact decimal place matches with object format\n        const result15 = PushChain.utils.helpers.parseUnits('1.123456', {\n          decimals: 6,\n        });\n        expect(result15).toBe(BigInt('1123456'));\n\n        // Test large numbers with object format\n        const result16 = PushChain.utils.helpers.parseUnits(\n          '999999999999999999',\n          { decimals: 18 }\n        );\n        expect(result16).toBe(BigInt('999999999999999999000000000000000000'));\n\n        const result17 = PushChain.utils.helpers.parseUnits('1000000', {\n          decimals: 0,\n        });\n        expect(result17).toBe(BigInt('1000000'));\n\n        // Test common token decimal scenarios with object format\n        // ETH (18 decimals)\n        const ethResult = PushChain.utils.helpers.parseUnits('1', {\n          decimals: 18,\n        });\n        expect(ethResult).toBe(BigInt('1000000000000000000'));\n\n        // USDC (6 decimals)\n        const usdcResult = PushChain.utils.helpers.parseUnits('100', {\n          decimals: 6,\n        });\n        expect(usdcResult).toBe(BigInt('100000000'));\n\n        // BTC (8 decimals)\n        const btcResult = PushChain.utils.helpers.parseUnits('0.00000001', {\n          decimals: 8,\n        });\n        expect(btcResult).toBe(BigInt('1'));\n\n        // Push token (18 decimals) - example amount\n        const pushResult = PushChain.utils.helpers.parseUnits('1000.5', {\n          decimals: 18,\n        });\n        expect(pushResult).toBe(BigInt('1000500000000000000000'));\n      });\n\n      it('should throw error for invalid object-based exponent types', () => {\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', { decimals: '18' } as any)\n        ).toThrow('Exponent must be a number');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', { decimals: null } as any)\n        ).toThrow('Exponent must be a number');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', { decimals: 1.5 })\n        ).toThrow('Exponent must be an integer');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', { decimals: -1 })\n        ).toThrow('Exponent must be non-negative');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', {} as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', { invalid: 18 } as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', null as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1', undefined as any)\n        ).toThrow(\n          'Exponent must be a number or an object with decimals property'\n        );\n      });\n\n      it('should throw error when decimal places exceed exponent with object format', () => {\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('1.123456789', { decimals: 6 })\n        ).toThrow('Value has more decimal places (9) than exponent allows (6)');\n\n        expect(() =>\n          PushChain.utils.helpers.parseUnits('0.12345678901234567890', {\n            decimals: 18,\n          })\n        ).toThrow(\n          'Value has more decimal places (20) than exponent allows (18)'\n        );\n      });\n\n      it('should produce same results for number and object-based exponent formats', () => {\n        const testCases = [\n          { value: '420', decimals: 9 },\n          { value: '1.5', decimals: 18 },\n          { value: '0.1', decimals: 6 },\n          { value: '1.23', decimals: 6 },\n          { value: '0', decimals: 18 },\n          { value: '0.0', decimals: 6 },\n          { value: '-1', decimals: 18 },\n          { value: '-0.5', decimals: 6 },\n          { value: '100', decimals: 0 },\n          { value: '1000', decimals: 3 },\n          { value: ' 1.5 ', decimals: 18 },\n          { value: '\\t420\\n', decimals: 9 },\n          { value: '.5', decimals: 18 },\n          { value: '.123', decimals: 6 },\n          { value: '1.123456', decimals: 6 },\n          { value: '999999999999999999', decimals: 18 },\n          { value: '1000000', decimals: 0 },\n          { value: '1', decimals: 18 },\n          { value: '100', decimals: 6 },\n          { value: '0.00000001', decimals: 8 },\n          { value: '1000.5', decimals: 18 },\n        ];\n\n        testCases.forEach(({ value, decimals }) => {\n          const numberResult = PushChain.utils.helpers.parseUnits(\n            value,\n            decimals\n          );\n          const objectResult = PushChain.utils.helpers.parseUnits(value, {\n            decimals,\n          });\n          expect(numberResult).toBe(objectResult);\n        });\n      });\n    });\n\n    describe('formatUnits', () => {\n      describe('EVM-style usage (number decimals)', () => {\n        it('should format bigint values correctly', () => {\n          const readable1 = PushChain.utils.helpers.formatUnits(\n            BigInt('1500000000000000000'),\n            18\n          );\n          console.log(readable1);\n          const readable2 = PushChain.utils.helpers.formatUnits('1500000', {\n            decimals: 6,\n          });\n          console.log(readable2);\n          const readable3 = PushChain.utils.helpers.formatUnits('1234567', {\n            decimals: 6,\n            precision: 2,\n          });\n          console.log(readable3);\n\n          // ETH (18 decimals)\n          const result1 = PushChain.utils.helpers.formatUnits(\n            BigInt('1500000000000000000'),\n            18\n          );\n          expect(result1).toBe('1.5');\n\n          // USDC (6 decimals)\n          const result2 = PushChain.utils.helpers.formatUnits(\n            BigInt('1500000'),\n            6\n          );\n          expect(result2).toBe('1.5');\n\n          // BTC (8 decimals)\n          const result3 = PushChain.utils.helpers.formatUnits(\n            BigInt('123456789'),\n            8\n          );\n          expect(result3).toBe('1.23456789');\n\n          // Zero value\n          const result4 = PushChain.utils.helpers.formatUnits(BigInt('0'), 18);\n          expect(result4).toBe('0.0');\n\n          // Large value\n          const result5 = PushChain.utils.helpers.formatUnits(\n            BigInt('1000000000000000000000'),\n            18\n          );\n          expect(result5).toBe('1000.0');\n        });\n\n        it('should format string values correctly', () => {\n          // ETH (18 decimals)\n          const result1 = PushChain.utils.helpers.formatUnits(\n            '1500000000000000000',\n            18\n          );\n          expect(result1).toBe('1.5');\n\n          // USDC (6 decimals)\n          const result2 = PushChain.utils.helpers.formatUnits('1500000', 6);\n          expect(result2).toBe('1.5');\n\n          // BTC (8 decimals)\n          const result3 = PushChain.utils.helpers.formatUnits('123456789', 8);\n          expect(result3).toBe('1.23456789');\n\n          // Zero value\n          const result4 = PushChain.utils.helpers.formatUnits('0', 18);\n          expect(result4).toBe('0.0');\n\n          // Large value\n          const result5 = PushChain.utils.helpers.formatUnits(\n            '1000000000000000000000',\n            18\n          );\n          expect(result5).toBe('1000.0');\n        });\n\n        it('should handle different decimal scenarios', () => {\n          // No decimals (0)\n          const result1 = PushChain.utils.helpers.formatUnits(BigInt('100'), 0);\n          expect(result1).toBe('100');\n\n          // Single decimal (1)\n          const result2 = PushChain.utils.helpers.formatUnits(BigInt('123'), 1);\n          expect(result2).toBe('12.3');\n\n          // Many decimals (30)\n          const result3 = PushChain.utils.helpers.formatUnits(\n            BigInt('123456789012345678901234567890'),\n            30\n          );\n          expect(result3).toBe('0.12345678901234567890123456789');\n        });\n      });\n\n      describe('Push-style usage (options object)', () => {\n        it('should format with decimals option', () => {\n          // ETH (18 decimals)\n          const result1 = PushChain.utils.helpers.formatUnits(\n            BigInt('1500000000000000000'),\n            { decimals: 18 }\n          );\n          expect(result1).toBe('1.5');\n\n          // USDC (6 decimals)\n          const result2 = PushChain.utils.helpers.formatUnits('1500000', {\n            decimals: 6,\n          });\n          expect(result2).toBe('1.5');\n\n          // BTC (8 decimals)\n          const result3 = PushChain.utils.helpers.formatUnits('123456789', {\n            decimals: 8,\n          });\n          expect(result3).toBe('1.23456789');\n\n          // Zero value\n          const result4 = PushChain.utils.helpers.formatUnits('0', {\n            decimals: 18,\n          });\n          expect(result4).toBe('0.0');\n\n          // Large value\n          const result5 = PushChain.utils.helpers.formatUnits(\n            '1000000000000000000000',\n            { decimals: 18 }\n          );\n          expect(result5).toBe('1000.0');\n        });\n\n        it('should format with precision option', () => {\n          // Truncate to 2 decimal places\n          const result1 = PushChain.utils.helpers.formatUnits('1234567', {\n            decimals: 6,\n            precision: 2,\n          });\n          expect(result1).toBe('1.23');\n\n          // Truncate to 4 decimal places\n          const result2 = PushChain.utils.helpers.formatUnits('123456789', {\n            decimals: 8,\n            precision: 4,\n          });\n          expect(result2).toBe('1.2345');\n\n          // Truncate to 0 decimal places (integer)\n          const result3 = PushChain.utils.helpers.formatUnits('1500000', {\n            decimals: 6,\n            precision: 0,\n          });\n          expect(result3).toBe('1');\n\n          // Truncate to 1 decimal place\n          const result4 = PushChain.utils.helpers.formatUnits(\n            '1500000000000000000',\n            { decimals: 18, precision: 1 }\n          );\n          expect(result4).toBe('1.5');\n\n          // Precision larger than actual decimals\n          const result5 = PushChain.utils.helpers.formatUnits('1500000', {\n            decimals: 6,\n            precision: 10,\n          });\n          expect(result5).toBe('1.5');\n        });\n\n        it('should handle edge cases with precision', () => {\n          // Very small number with precision\n          const result1 = PushChain.utils.helpers.formatUnits('1', {\n            decimals: 18,\n            precision: 2,\n          });\n          expect(result1).toBe('0');\n\n          // Number that rounds down with precision\n          const result2 = PushChain.utils.helpers.formatUnits('123456', {\n            decimals: 6,\n            precision: 1,\n          });\n          expect(result2).toBe('0.1');\n\n          // Number that rounds down to zero\n          const result3 = PushChain.utils.helpers.formatUnits('123456', {\n            decimals: 6,\n            precision: 0,\n          });\n          expect(result3).toBe('0');\n        });\n      });\n\n      describe('Common token scenarios', () => {\n        it('should handle ETH scenarios', () => {\n          // 1 ETH\n          const result1 = PushChain.utils.helpers.formatUnits(\n            '1000000000000000000',\n            18\n          );\n          expect(result1).toBe('1.0');\n\n          // 0.5 ETH\n          const result2 = PushChain.utils.helpers.formatUnits(\n            '500000000000000000',\n            18\n          );\n          expect(result2).toBe('0.5');\n\n          // 0.001 ETH\n          const result3 = PushChain.utils.helpers.formatUnits(\n            '1000000000000000',\n            18\n          );\n          expect(result3).toBe('0.001');\n        });\n\n        it('should handle USDC scenarios', () => {\n          // 100 USDC\n          const result1 = PushChain.utils.helpers.formatUnits('100000000', 6);\n          expect(result1).toBe('100.0');\n\n          // 0.01 USDC\n          const result2 = PushChain.utils.helpers.formatUnits('10000', 6);\n          expect(result2).toBe('0.01');\n\n          // 0.000001 USDC (smallest unit)\n          const result3 = PushChain.utils.helpers.formatUnits('1', 6);\n          expect(result3).toBe('0.000001');\n        });\n\n        it('should handle BTC scenarios', () => {\n          // 1 BTC\n          const result1 = PushChain.utils.helpers.formatUnits('100000000', 8);\n          expect(result1).toBe('1.0');\n\n          // 0.5 BTC\n          const result2 = PushChain.utils.helpers.formatUnits('50000000', 8);\n          expect(result2).toBe('0.5');\n\n          // 0.00000001 BTC (1 satoshi)\n          const result3 = PushChain.utils.helpers.formatUnits('1', 8);\n          expect(result3).toBe('0.00000001');\n        });\n      });\n\n      describe('Error handling and validation', () => {\n        it('should throw error for invalid value types', () => {\n          expect(() =>\n            PushChain.utils.helpers.formatUnits(123 as any, 18)\n          ).toThrow('Value must be a bigint or string');\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits(null as any, 18)\n          ).toThrow('Value must be a bigint or string');\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits(undefined as any, 18)\n          ).toThrow('Value must be a bigint or string');\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits({} as any, 18)\n          ).toThrow('Value must be a bigint or string');\n        });\n\n        it('should throw error for invalid decimals parameter', () => {\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', '18' as any)\n          ).toThrow(\n            'Second parameter must be a number (decimals) or an object with decimals property'\n          );\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', null as any)\n          ).toThrow(\n            'Second parameter must be a number (decimals) or an object with decimals property'\n          );\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', undefined as any)\n          ).toThrow(\n            'Second parameter must be a number (decimals) or an object with decimals property'\n          );\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', {} as any)\n          ).toThrow(\n            'Second parameter must be a number (decimals) or an object with decimals property'\n          );\n        });\n\n        it('should throw error for invalid decimals values', () => {\n          expect(() => PushChain.utils.helpers.formatUnits('100', 1.5)).toThrow(\n            'Decimals must be an integer'\n          );\n\n          expect(() => PushChain.utils.helpers.formatUnits('100', -1)).toThrow(\n            'Decimals must be non-negative'\n          );\n\n          expect(() => PushChain.utils.helpers.formatUnits('100', NaN)).toThrow(\n            'Decimals must be an integer'\n          );\n        });\n\n        it('should throw error for invalid precision values', () => {\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', {\n              decimals: 18,\n              precision: 1.5,\n            })\n          ).toThrow('Precision must be an integer');\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', {\n              decimals: 18,\n              precision: -1,\n            })\n          ).toThrow('Precision must be non-negative');\n\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('100', {\n              decimals: 18,\n              precision: NaN,\n            })\n          ).toThrow('Precision must be an integer');\n        });\n\n        it('should throw error for invalid string values', () => {\n          expect(() =>\n            PushChain.utils.helpers.formatUnits('invalid', 18)\n          ).toThrow('Failed to format units');\n        });\n      });\n\n      describe('Edge cases', () => {\n        it('should handle very large numbers', () => {\n          const result1 = PushChain.utils.helpers.formatUnits(\n            '999999999999999999999999999999999999999999',\n            18\n          );\n          expect(result1).toBe('999999999999999999999999.999999999999999999');\n\n          const result2 = PushChain.utils.helpers.formatUnits(\n            '999999999999999999999999999999999999999999',\n            { decimals: 18, precision: 2 }\n          );\n          expect(result2).toBe('1e+24');\n        });\n\n        it('should handle very small numbers', () => {\n          const result1 = PushChain.utils.helpers.formatUnits('1', 30);\n          expect(result1).toBe('0.000000000000000000000000000001');\n\n          const result2 = PushChain.utils.helpers.formatUnits('1', {\n            decimals: 30,\n            precision: 10,\n          });\n          expect(result2).toBe('0');\n        });\n\n        it('should handle zero with different decimals', () => {\n          const result1 = PushChain.utils.helpers.formatUnits('0', 0);\n          expect(result1).toBe('0');\n\n          const result2 = PushChain.utils.helpers.formatUnits('0', 18);\n          expect(result2).toBe('0.0');\n\n          const result3 = PushChain.utils.helpers.formatUnits('0', {\n            decimals: 6,\n            precision: 2,\n          });\n          expect(result3).toBe('0');\n        });\n\n        it('should handle negative numbers', () => {\n          const result1 = PushChain.utils.helpers.formatUnits(\n            '-1500000000000000000',\n            18\n          );\n          expect(result1).toBe('-1.5');\n\n          const result2 = PushChain.utils.helpers.formatUnits('-1500000', {\n            decimals: 6,\n            precision: 2,\n          });\n          expect(result2).toBe('-1.5');\n        });\n      });\n\n      describe('Consistency between EVM-style and Push-style', () => {\n        it('should produce same results for number and object-based formats', () => {\n          const testCases = [\n            { value: '1500000000000000000', decimals: 18 },\n            { value: '1500000', decimals: 6 },\n            { value: '123456789', decimals: 8 },\n            { value: '0', decimals: 18 },\n            { value: '1000000000000000000000', decimals: 18 },\n            { value: '123456', decimals: 6 },\n            { value: '999999999999999999', decimals: 18 },\n            { value: '1', decimals: 30 },\n          ];\n\n          testCases.forEach(({ value, decimals }) => {\n            const numberResult = PushChain.utils.helpers.formatUnits(\n              value,\n              decimals\n            );\n            const objectResult = PushChain.utils.helpers.formatUnits(value, {\n              decimals,\n            });\n            expect(numberResult).toBe(objectResult);\n          });\n        });\n\n        it('should handle bigint and string inputs consistently', () => {\n          const testCases = [\n            { value: '1500000000000000000', decimals: 18 },\n            { value: '1500000', decimals: 6 },\n            { value: '123456789', decimals: 8 },\n            { value: '0', decimals: 18 },\n            { value: '1000000000000000000000', decimals: 18 },\n          ];\n\n          testCases.forEach(({ value, decimals }) => {\n            const stringResult = PushChain.utils.helpers.formatUnits(\n              value,\n              decimals\n            );\n            const bigintResult = PushChain.utils.helpers.formatUnits(\n              BigInt(value),\n              decimals\n            );\n            expect(stringResult).toBe(bigintResult);\n          });\n        });\n      });\n    });\n\n    describe('slippageToMinAmount', () => {\n      describe('basic functionality', () => {\n        it('should calculate minimum amount out with 1% slippage', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount('100', {\n            slippageBps: 100,\n          });\n          expect(result).toBe('99');\n        });\n\n        it('should calculate minimum amount out with 1% slippage for large amounts', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 100,\n            }\n          );\n          expect(result).toBe('99000000');\n        });\n\n        it('should calculate minimum amount out with 0.5% slippage', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 50,\n            }\n          );\n          expect(result).toBe('99500000');\n        });\n\n        it('should calculate minimum amount out with 2% slippage', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 200,\n            }\n          );\n          expect(result).toBe('98000000');\n        });\n\n        it('should handle zero slippage', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 0,\n            }\n          );\n          expect(result).toBe('100000000');\n        });\n\n        it('should handle maximum slippage (100%)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 10000,\n            }\n          );\n          expect(result).toBe('0');\n        });\n      });\n\n      describe('edge cases', () => {\n        it('should handle very small amounts', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount('1', {\n            slippageBps: 100,\n          });\n          expect(result).toBe('0');\n        });\n\n        it('should handle very large amounts', () => {\n          const largeAmount = '999999999999999999999999999999';\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            largeAmount,\n            {\n              slippageBps: 100,\n            }\n          );\n          // Should be 99% of the large amount\n          const expected = (BigInt(largeAmount) * BigInt(9900)) / BigInt(10000);\n          expect(result).toBe(expected.toString());\n        });\n\n        it('should handle fractional slippage calculations correctly', () => {\n          // Test with amount that doesn't divide evenly by 10000\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000001',\n            {\n              slippageBps: 100,\n            }\n          );\n          // 100000001 * 9900 / 10000 = 99000000.99, truncated to 99000000\n          expect(result).toBe('99000000');\n        });\n      });\n\n      describe('different slippage rates', () => {\n        it('should handle 0.1% slippage (10 bps)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 10,\n            }\n          );\n          expect(result).toBe('99900000');\n        });\n\n        it('should handle 0.25% slippage (25 bps)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 25,\n            }\n          );\n          expect(result).toBe('99750000');\n        });\n\n        it('should handle 5% slippage (500 bps)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 500,\n            }\n          );\n          expect(result).toBe('95000000');\n        });\n\n        it('should handle 10% slippage (1000 bps)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 1000,\n            }\n          );\n          expect(result).toBe('90000000');\n        });\n\n        it('should handle 50% slippage (5000 bps)', () => {\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            '100000000',\n            {\n              slippageBps: 5000,\n            }\n          );\n          expect(result).toBe('50000000');\n        });\n      });\n\n      describe('error handling', () => {\n        it('should throw error for non-string amount', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount(100 as any, {\n              slippageBps: 100,\n            });\n          }).toThrow('Amount must be a string');\n        });\n\n        it('should throw error for non-number slippageBps', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('100', {\n              slippageBps: '100' as any,\n            });\n          }).toThrow('slippageBps must be a number');\n        });\n\n        it('should throw error for non-integer slippageBps', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('100', {\n              slippageBps: 100.5,\n            });\n          }).toThrow('slippageBps must be an integer');\n        });\n\n        it('should throw error for negative slippageBps', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('100', {\n              slippageBps: -100,\n            });\n          }).toThrow('slippageBps must be non-negative');\n        });\n\n        it('should throw error for slippageBps exceeding 10000', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('100', {\n              slippageBps: 10001,\n            });\n          }).toThrow('slippageBps cannot exceed 10000 (100%)');\n        });\n\n        it('should throw error for empty amount string', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('', {\n              slippageBps: 100,\n            });\n          }).toThrow('Amount cannot be empty');\n        });\n\n        it('should throw error for whitespace-only amount string', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('   ', {\n              slippageBps: 100,\n            });\n          }).toThrow('Amount cannot be empty');\n        });\n\n        it('should throw error for invalid amount format', () => {\n          expect(() => {\n            PushChain.utils.conversion.slippageToMinAmount('invalid', {\n              slippageBps: 100,\n            });\n          }).toThrow('Failed to calculate slippage');\n        });\n      });\n\n      describe('real-world scenarios', () => {\n        it('should work with USDC amounts (6 decimals)', () => {\n          // 1000 USDC with 0.3% slippage\n          const usdcAmount = '1000000000'; // 1000 USDC in smallest units\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            usdcAmount,\n            {\n              slippageBps: 30, // 0.3%\n            }\n          );\n          expect(result).toBe('997000000'); // 997 USDC\n        });\n\n        it('should work with ETH amounts (18 decimals)', () => {\n          // 1 ETH with 0.5% slippage\n          const ethAmount = '1000000000000000000'; // 1 ETH in wei\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            ethAmount,\n            {\n              slippageBps: 50, // 0.5%\n            }\n          );\n          expect(result).toBe('995000000000000000'); // 0.995 ETH\n        });\n\n        it('should work with small token amounts', () => {\n          // 0.001 tokens with 1% slippage\n          const smallAmount = '1000';\n          const result = PushChain.utils.conversion.slippageToMinAmount(\n            smallAmount,\n            {\n              slippageBps: 100, // 1%\n            }\n          );\n          expect(result).toBe('990');\n        });\n      });\n    });\n\n    describe('Tokens Utils', () => {\n      let tokensClientEVM: PushChain;\n      let tokensUniversalSignerEVM: UniversalSigner;\n\n      beforeAll(async () => {\n        const account = privateKeyToAccount(generatePrivateKey());\n        const walletClient = createWalletClient({\n          account,\n          chain: sepolia,\n          transport: http(),\n        });\n        tokensUniversalSignerEVM =\n          await PushChain.utils.signer.toUniversalFromKeypair(walletClient, {\n            chain: PushChain.CONSTANTS.CHAIN.ETHEREUM_SEPOLIA,\n            library: PushChain.CONSTANTS.LIBRARY.ETHEREUM_VIEM,\n          });\n        tokensClientEVM = await PushChain.initialize(tokensUniversalSignerEVM, {\n          network: PushChain.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n        });\n      });\n      it('should list all moveable tokens across all chains', () => {\n        const { tokens } = PushChain.utils.tokens.getMoveableTokens();\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Sanity check for common tokens present in the registry\n        const hasETH = tokens.some(\n          (t) => t.symbol === 'ETH' && t.decimals === 18\n        );\n        const hasWETH = tokens.some(\n          (t) => t.symbol === 'WETH' && t.decimals === 18\n        );\n        const hasUSDT = tokens.some(\n          (t) => t.symbol === 'USDT' && t.decimals === 6\n        );\n        expect(hasETH).toBe(true);\n        expect(hasWETH).toBe(true);\n        expect(hasUSDT).toBe(true);\n      });\n\n      it('should list moveable tokens for a specific chain (Ethereum Sepolia)', () => {\n        const { tokens } = PushChain.utils.tokens.getMoveableTokens(\n          CHAIN.ETHEREUM_SEPOLIA\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect ETH, WETH, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ETHEREUM_SEPOLIA &&\n              t.symbol === 'ETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ETHEREUM_SEPOLIA &&\n              t.symbol === 'WETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ETHEREUM_SEPOLIA &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should list moveable tokens for a specific chain (Arbitrum Sepolia)', () => {\n        const { tokens } = PushChain.utils.tokens.getMoveableTokens(\n          CHAIN.ARBITRUM_SEPOLIA\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect ETH, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ARBITRUM_SEPOLIA &&\n              t.symbol === 'ETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ARBITRUM_SEPOLIA &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should list moveable tokens for a specific chain (Base Sepolia)', () => {\n        const { tokens } = PushChain.utils.tokens.getMoveableTokens(\n          CHAIN.BASE_SEPOLIA\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect ETH, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.BASE_SEPOLIA &&\n              t.symbol === 'ETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.BASE_SEPOLIA &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should list all payable tokens across all chains', () => {\n        const { tokens } = PushChain.utils.tokens.getPayableTokens();\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Sanity check for common tokens present in the registry\n        const hasSOL = tokens.some(\n          (t) => t.symbol === 'SOL' && t.decimals === 9\n        );\n        const hasUSDT = tokens.some(\n          (t) => t.symbol === 'USDT' && t.decimals === 6\n        );\n        expect(hasSOL).toBe(true);\n        expect(hasUSDT).toBe(true);\n      });\n\n      it('should list payable tokens for a specific chain (Solana Devnet)', () => {\n        const { tokens } = PushChain.utils.tokens.getPayableTokens(\n          CHAIN.SOLANA_DEVNET\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect SOL, USDC, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.SOLANA_DEVNET &&\n              t.symbol === 'SOL' &&\n              t.decimals === 9\n          )\n        ).toBe(true);\n\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.SOLANA_DEVNET &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should list payable tokens for a specific chain (Arbitrum Sepolia)', () => {\n        const { tokens } = PushChain.utils.tokens.getPayableTokens(\n          CHAIN.ARBITRUM_SEPOLIA\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect ETH, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ARBITRUM_SEPOLIA &&\n              t.symbol === 'ETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.ARBITRUM_SEPOLIA &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should list payable tokens for a specific chain (Base Sepolia)', () => {\n        const { tokens } = PushChain.utils.tokens.getPayableTokens(\n          CHAIN.BASE_SEPOLIA\n        );\n        expect(Array.isArray(tokens)).toBe(true);\n        expect(tokens.length).toBeGreaterThan(0);\n\n        // Expect ETH, USDT per tokens registry\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.BASE_SEPOLIA &&\n              t.symbol === 'ETH' &&\n              t.decimals === 18\n          )\n        ).toBe(true);\n\n        expect(\n          tokens.some(\n            (t) =>\n              t.chain === CHAIN.BASE_SEPOLIA &&\n              t.symbol === 'USDT' &&\n              t.decimals === 6\n          )\n        ).toBe(true);\n      });\n\n      it('should resolve chain via client instance for moveable tokens', () => {\n        const clientTokens =\n          PushChain.utils.tokens.getMoveableTokens(tokensClientEVM).tokens;\n        const chainTokens = PushChain.utils.tokens.getMoveableTokens(\n          CHAIN.ETHEREUM_SEPOLIA\n        ).tokens;\n\n        // Compare by symbol presence and count (order not guaranteed by spec)\n        const symbolsFromClient = new Set(\n          clientTokens\n            .filter((t) => t.chain === CHAIN.ETHEREUM_SEPOLIA)\n            .map((t) => t.symbol)\n        );\n        const symbolsFromChain = new Set(\n          chainTokens\n            .filter((t) => t.chain === CHAIN.ETHEREUM_SEPOLIA)\n            .map((t) => t.symbol)\n        );\n        expect(symbolsFromClient).toEqual(symbolsFromChain);\n        expect(clientTokens.length).toBe(chainTokens.length);\n      });\n    });\n  });\n});\n",
  "packages/core/src/lib/push-chain/push-chain.ts": "import { CONSTANTS } from '../constants';\nimport { CHAIN, PUSH_NETWORK, VM } from '../constants/enums';\nimport { CHAIN_INFO } from '../constants/chain';\nimport { Orchestrator } from '../orchestrator/orchestrator';\nimport { createUniversalSigner } from '../universal/signer';\nimport {\n  UniversalAccount,\n  UniversalSigner,\n} from '../universal/universal.types';\nimport { Utils } from '../utils';\nimport { utils } from '@coral-xyz/anchor';\nimport { Abi, bytesToHex, parseAbi, TypedData, TypedDataDomain } from 'viem';\nimport { ProgressEvent } from '../progress-hook/progress-hook.types';\nimport { EvmClient } from '../vm-client/evm-client';\nimport {\n  MOVEABLE_TOKENS,\n  PAYABLE_TOKENS,\n  MoveableToken,\n  PayableToken,\n  ConversionQuote,\n  MoveableTokenAccessor,\n  PayableTokenAccessor,\n} from '../constants/tokens';\n\n/**\n * @class PushChain\n *\n * Entry point to interact with Push Chain in your application.\n * Provides access to cross-chain execution, utilities, and signer abstraction.\n */\nexport class PushChain {\n  /**\n   * @static\n   * Constants for the PushChain SDK.\n   */\n  public static CONSTANTS = CONSTANTS;\n\n  /**\n   * @static\n   * Utility functions for encoding, hashing, and data formatting.\n   */\n  public static utils = Utils;\n\n  /**\n   * Helper function to check if input is UniversalAccount (read-only) or UniversalSigner\n   */\n  private static isUniversalAccount(\n    input: UniversalSigner | UniversalAccount\n  ): input is UniversalAccount {\n    return !('signMessage' in input) && !('signAndSendTransaction' in input);\n  }\n\n  /**\n   * Universal namespace containing core transaction and address computation methods\n   */\n  universal: {\n    // pushChainClient.universal.origin. not a function, just a property. => Return UOA wallet address. If from Push chain, both returns above will match. Else, it will tell from which chian it comes from.\n    get origin(): ReturnType<Orchestrator['getUOA']>;\n    // pushChainClient.universal.account. not a function, just a property. => Return UEA (wallet from push chain). If on push, return Push Chain wallet itself.\n    get account(): ReturnType<Orchestrator['computeUEAOffchain']>;\n    /**\n     * Executes a transaction on Push Chain\n     */\n    sendTransaction: Orchestrator['execute'];\n    /**\n     * Signs an arbitrary message\n     */\n    signMessage: (data: Uint8Array) => Promise<string>;\n    /**\n     * Signs EIP-712 typed data\n     */\n    signTypedData: ({\n      domain,\n      types,\n      primaryType,\n      message,\n    }: {\n      domain: TypedDataDomain;\n      types: TypedData;\n      primaryType: string;\n      message: Record<string, any>;\n    }) => Promise<string>;\n  };\n\n  explorer: {\n    getTransactionUrl: (txHash: string) => string;\n    listUrls: () => { urls: string[] };\n  };\n\n  /**\n   * Moveable and payable token registries exposed on the client instance.\n   * These are derived from the origin chain and only include tokens available for that chain.\n   */\n  moveable: { token: MoveableTokenAccessor };\n  payable: { token: PayableTokenAccessor };\n\n  funds: {\n    getConversionQuote: (\n      amountIn: bigint,\n      options: {\n        from: PayableToken | undefined;\n        to: MoveableToken | undefined;\n      }\n    ) => Promise<ConversionQuote>;\n  };\n\n  private constructor(\n    private orchestrator: Orchestrator,\n    private universalSigner: UniversalSigner,\n    private blockExplorers: Partial<Record<CHAIN, string[]>>,\n    public isReadMode: boolean\n  ) {\n    this.orchestrator = orchestrator;\n\n    this.universal = {\n      get origin() {\n        return orchestrator.getUOA();\n      },\n      get account() {\n        return orchestrator.computeUEAOffchain();\n      },\n      sendTransaction: (...args) => {\n        if (this.isReadMode) {\n          throw new Error(\n            'Read only mode cannot call sendTransaction function'\n          );\n        }\n        return orchestrator.execute.bind(orchestrator)(...args);\n      },\n      signMessage: async (data: Uint8Array) => {\n        if (this.isReadMode) {\n          throw new Error('Read only mode cannot call signMessage function');\n        }\n        const sigBytes = await universalSigner.signMessage(data);\n        const chain = universalSigner.account.chain;\n        if (CHAIN_INFO[chain].vm === VM.EVM) {\n          return bytesToHex(sigBytes);\n        } else if (CHAIN_INFO[chain].vm === VM.SVM) {\n          return utils.bytes.bs58.encode(sigBytes);\n        }\n        return bytesToHex(sigBytes);\n      },\n      signTypedData: async (...args) => {\n        if (typeof universalSigner.signTypedData !== 'function') {\n          throw new Error('Typed data signing not supported');\n        }\n        const signBytes = await universalSigner.signTypedData(...args);\n        return bytesToHex(signBytes);\n      },\n    };\n\n    this.explorer = {\n      getTransactionUrl: (txHash: string) => {\n        return `https://donut.push.network/tx/${txHash}`;\n      },\n      listUrls: () => {\n        return { urls: blockExplorers[CHAIN.PUSH_TESTNET_DONUT] ?? [] };\n      },\n    };\n\n    // Derive moveable/payable tokens for the current origin chain\n    const originChain = universalSigner.account.chain;\n    const toTokenMap = <T extends { symbol: string }>(arr: T[] | undefined) =>\n      (arr ?? []).reduce<Record<string, T>>((acc, t) => {\n        acc[t.symbol] = t;\n        return acc;\n      }, {});\n\n    const moveableList =\n      MOVEABLE_TOKENS[originChain] ??\n      MOVEABLE_TOKENS[CHAIN.ETHEREUM_MAINNET] ??\n      MOVEABLE_TOKENS[CHAIN.ETHEREUM_SEPOLIA] ??\n      [];\n    const payableList =\n      PAYABLE_TOKENS[originChain] ??\n      PAYABLE_TOKENS[CHAIN.ETHEREUM_MAINNET] ??\n      PAYABLE_TOKENS[CHAIN.ETHEREUM_SEPOLIA] ??\n      [];\n\n    this.moveable = {\n      token: new MoveableTokenAccessor(\n        toTokenMap(moveableList) as Record<string, MoveableToken>\n      ),\n    };\n    this.payable = {\n      token: new PayableTokenAccessor(\n        toTokenMap(payableList) as Record<string, PayableToken>\n      ),\n    };\n\n    this.funds = {\n      getConversionQuote: async (\n        amountIn: bigint,\n        {\n          from,\n          to,\n        }: {\n          from: PayableToken | undefined;\n          to: MoveableToken | undefined;\n        }\n      ): Promise<ConversionQuote> => {\n        const originChain = universalSigner.account.chain;\n        if (originChain !== CHAIN.ETHEREUM_SEPOLIA) {\n          throw new Error(\n            'getConversionQuote is only supported on Ethereum Sepolia for now'\n          );\n        }\n\n        if (!from) {\n          throw new Error('from token is required');\n        }\n\n        if (!to) {\n          throw new Error('to token is required');\n        }\n\n        // Resolve RPCs from client config, falling back to defaults\n        const rpcUrls =\n          orchestrator.getRpcUrls()[originChain] ||\n          CHAIN_INFO[originChain].defaultRPC;\n\n        const evm = new EvmClient({ rpcUrls });\n\n        // Minimal ABIs and Uniswap V3 addresses sourced from chain config\n        const factoryFromConfig = CHAIN_INFO[originChain].dex?.uniV3Factory;\n        const quoterFromConfig = CHAIN_INFO[originChain].dex?.uniV3QuoterV2;\n        if (!factoryFromConfig || !quoterFromConfig) {\n          throw new Error('Uniswap V3 addresses not configured for this chain');\n        }\n        const UNISWAP_V3_FACTORY = factoryFromConfig as `0x${string}`;\n        const UNISWAP_V3_QUOTER_V2 = quoterFromConfig as `0x${string}`;\n\n        const factoryAbi: Abi = parseAbi([\n          'function getPool(address tokenA, address tokenB, uint24 fee) view returns (address)',\n        ]);\n        const quoterAbi: Abi = parseAbi([\n          'function quoteExactInputSingle((address tokenIn, address tokenOut, uint256 amountIn, uint24 fee, uint160 sqrtPriceLimitX96) params) returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate)',\n        ]);\n        const poolAbi: Abi = parseAbi([\n          'function liquidity() view returns (uint128)',\n        ]);\n\n        const feeTiers: number[] = [100, 500, 3000, 10000];\n\n        let bestAmountOut = BigInt(0);\n        let bestFee: number | null = null;\n\n        for (const fee of feeTiers) {\n          // Find pool address for this fee tier\n          const poolAddress = await evm.readContract<string>({\n            abi: factoryAbi,\n            address: UNISWAP_V3_FACTORY,\n            functionName: 'getPool',\n            args: [from.address, to.address, fee],\n          });\n\n          const isZero =\n            !poolAddress ||\n            poolAddress.toLowerCase() ===\n              '0x0000000000000000000000000000000000000000';\n          if (isZero) continue;\n\n          // Skip uninitialized/empty pools to avoid Quoter reverts\n          try {\n            const liquidity = await evm.readContract<bigint>({\n              abi: poolAbi,\n              address: poolAddress as `0x${string}`,\n              functionName: 'liquidity',\n              args: [],\n            });\n            if (!liquidity || liquidity === BigInt(0)) {\n              continue;\n            }\n          } catch {\n            // If we can't read liquidity, skip this pool/fee tier\n            continue;\n          }\n\n          // Quote exact input single for this fee tier; catch reverts due to empty/uninitialized pools\n          try {\n            const result = await evm.readContract<\n              [bigint, bigint, number, bigint]\n            >({\n              abi: quoterAbi,\n              address: UNISWAP_V3_QUOTER_V2,\n              functionName: 'quoteExactInputSingle',\n              args: [\n                {\n                  tokenIn: from.address,\n                  tokenOut: to.address,\n                  amountIn,\n                  fee,\n                  sqrtPriceLimitX96: BigInt(0),\n                },\n              ],\n            });\n\n            const amountOut = result?.[0] ?? BigInt(0);\n            if (amountOut > bestAmountOut) {\n              bestAmountOut = amountOut;\n              bestFee = fee;\n            }\n          } catch {\n            // try next fee\n          }\n        }\n\n        if (!bestFee) {\n          throw new Error(\n            'No direct Uniswap V3 pool found for the given token pair on common fee tiers'\n          );\n        }\n\n        // Compute normalized rate: tokenOut per tokenIn\n        const amountInHuman = parseFloat(\n          Utils.helpers.formatUnits(amountIn, { decimals: from.decimals })\n        );\n        const amountOutHuman = parseFloat(\n          Utils.helpers.formatUnits(bestAmountOut, { decimals: to.decimals })\n        );\n        const rate = amountInHuman > 0 ? amountOutHuman / amountInHuman : 0;\n\n        return {\n          amountIn: amountIn.toString(),\n          amountOut: bestAmountOut.toString(),\n          rate,\n          route: [from.symbol, to.symbol],\n          timestamp: Date.now(),\n        };\n      },\n    };\n  }\n\n  /**\n   * @private\n   * Internal method to create a PushChain instance with the given parameters.\n   * Used by both initialize and reinitialize methods to avoid code duplication.\n   */\n  private static async createInstance(\n    universalSigner: UniversalSigner | UniversalAccount,\n    options?: {\n      network: PUSH_NETWORK;\n      rpcUrls?: Partial<Record<CHAIN, string[]>>;\n      blockExplorers?: Partial<Record<CHAIN, string[]>>;\n      printTraces?: boolean;\n      progressHook?: (progress: ProgressEvent) => void;\n    }\n  ): Promise<PushChain> {\n    const isReadOnly = PushChain.isUniversalAccount(universalSigner);\n\n    // If it's a UniversalAccount (read-only), create a dummy signer for the orchestrator\n    const validatedUniversalSigner = isReadOnly\n      ? createUniversalSigner({\n          account: universalSigner,\n          signMessage: async () => {\n            throw new Error('Read only mode cannot call signMessage function');\n          },\n          signAndSendTransaction: async () => {\n            throw new Error(\n              'Read only mode cannot call signAndSendTransaction function'\n            );\n          },\n        })\n      : createUniversalSigner(universalSigner as UniversalSigner);\n\n    const blockExplorers = options?.blockExplorers ?? {\n      [CHAIN.PUSH_TESTNET_DONUT]: ['https://donut.push.network'],\n    };\n    const orchestrator = new Orchestrator(\n      /**\n       * Ensures the signer conforms to the UniversalSigner interface.\n       */\n      validatedUniversalSigner,\n      options?.network ?? PUSH_NETWORK.TESTNET_DONUT,\n      options?.rpcUrls ?? {},\n      options?.printTraces ?? false,\n      options?.progressHook\n    );\n    return new PushChain(\n      orchestrator,\n      validatedUniversalSigner,\n      blockExplorers,\n      isReadOnly\n    );\n  }\n\n  /**\n   * @method initialize\n   * Initializes the PushChain SDK with a universal signer and optional config.\n   *\n   * @param universalSigner\n   * @param options - Optional settings to configure the SDK instance.\n   *   - network: PushChain network to target (e.g., TESTNET_DONUT, MAINNET).\n   *   - rpcUrls: Custom RPC URLs mapped by chain IDs.\n   *   - printTraces: Whether to print internal trace logs for debugging.\n   *\n   * @returns An initialized instance of PushChain.\n   */\n  static initialize = async (\n    universalSigner: UniversalSigner | UniversalAccount,\n    options?: {\n      network: PUSH_NETWORK;\n      rpcUrls?: Partial<Record<CHAIN, string[]>>;\n      blockExplorers?: Partial<Record<CHAIN, string[]>>;\n      printTraces?: boolean;\n      progressHook?: (progress: ProgressEvent) => void;\n    }\n  ): Promise<PushChain> => {\n    return PushChain.createInstance(universalSigner, options);\n  };\n\n  /**\n   * @method reinitialize\n   * Reinitializes the PushChain SDK with a new universal signer and optional config.\n   *\n   * @param universalSigner\n   * @param options - Optional settings to configure the SDK instance.\n   *   - network: PushChain network to target (e.g., TESTNET_DONUT, MAINNET).\n   *   - rpcUrls: Custom RPC URLs mapped by chain IDs.\n   *   - printTraces: Whether to print internal trace logs for debugging.\n   *\n   * @returns A new initialized instance of PushChain.\n   */\n  reinitialize = async (\n    universalSigner: UniversalSigner | UniversalAccount,\n    options?: {\n      network: PUSH_NETWORK;\n      rpcUrls?: Partial<Record<CHAIN, string[]>>;\n      blockExplorers?: Partial<Record<CHAIN, string[]>>;\n      printTraces?: boolean;\n      progressHook?: (progress: ProgressEvent) => void;\n    }\n  ): Promise<PushChain> => {\n    const mergedOptions = {\n      network: options?.network ?? this.orchestrator.getNetwork(),\n      rpcUrls: options?.rpcUrls ?? this.orchestrator.getRpcUrls(),\n      blockExplorers: options?.blockExplorers ?? this.blockExplorers,\n      printTraces: options?.printTraces ?? this.orchestrator.getPrintTraces(),\n      progressHook:\n        options?.progressHook ?? this.orchestrator.getProgressHook(),\n    } as {\n      network: PUSH_NETWORK;\n      rpcUrls?: Partial<Record<CHAIN, string[]>>;\n      blockExplorers?: Partial<Record<CHAIN, string[]>>;\n      printTraces?: boolean;\n      progressHook?: (progress: ProgressEvent) => void;\n    };\n    return PushChain.createInstance(universalSigner, mergedOptions);\n  };\n}\n",
  "packages/core/src/lib/push-client/push-client.spec.ts": "import { PushClient } from './push-client';\nimport { CHAIN_INFO, PUSH_CHAIN_INFO, VM_NAMESPACE } from '../constants/chain';\nimport {\n  MsgDeployUEA,\n  MsgMintPC,\n  MsgExecutePayload,\n  VerificationType,\n} from '../generated/v1/tx';\nimport { CHAIN, PUSH_NETWORK } from '../constants/enums';\n\ndescribe('PushClient', () => {\n  let client: PushClient;\n  const MSG_DEPLOY_UEA: MsgDeployUEA = {\n    signer: 'push1f5th78lzntc2h0krzqn5yldvwg43lcrgkqxtsv',\n    universalAccountId: {\n      chainNamespace: VM_NAMESPACE[CHAIN_INFO[CHAIN.ETHEREUM_SEPOLIA].vm],\n      chainId: CHAIN_INFO[CHAIN.ETHEREUM_SEPOLIA].chainId,\n      owner: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n    },\n    txHash:\n      '0x7faf47ef206f8aa356fe60a14d998cef6403ae8753948a5d8cddff7b23965be7',\n  };\n\n  const MSG_MINT_PC: MsgMintPC = {\n    signer: 'push1f5th78lzntc2h0krzqn5yldvwg43lcrgkqxtsv',\n    universalAccountId: {\n      chainNamespace: VM_NAMESPACE[CHAIN_INFO[CHAIN.SOLANA_DEVNET].vm],\n      chainId: CHAIN_INFO[CHAIN.SOLANA_DEVNET].chainId,\n      owner:\n        '0x30ea71869947818d27b718592ea44010b458903bd9bf0370f50eda79e87d9f69',\n    },\n    txHash: '0xbhcdfbjhv',\n  };\n\n  const MSG_EXECUTE_PAYLOAD: MsgExecutePayload = {\n    signer: 'push1f5th78lzntc2h0krzqn5yldvwg43lcrgkqxtsv',\n    universalAccountId: {\n      chainNamespace: VM_NAMESPACE[CHAIN_INFO[CHAIN.SOLANA_DEVNET].vm],\n      chainId: CHAIN_INFO[CHAIN.SOLANA_DEVNET].chainId,\n      owner:\n        '0x30ea71869947818d27b718592ea44010b458903bd9bf0370f50eda79e87d9f69',\n    },\n    universalPayload: {\n      to: '0x527F3692F5C53CfA83F7689885995606F93b6164',\n      value: '0',\n      data: '0x2ba2ed980000000000000000000000000000000000000000000000000000000000000312',\n      gasLimit: '21000000',\n      maxFeePerGas: '1000000000',\n      maxPriorityFeePerGas: '200000000',\n      nonce: '1',\n      deadline: '9999999999',\n      vType: VerificationType.signedVerification,\n    },\n    verificationData:\n      '0x911d4ee13db2ca041e52c0e77035e4c7c82705a77e59368740ef42edcdb813144aff65d2a3a6d03215f764a037a229170c69ffbaaad50fff690940a5ef458304',\n  };\n\n  beforeEach(() => {\n    client = new PushClient({\n      rpcUrls: PUSH_CHAIN_INFO[CHAIN.PUSH_TESTNET].defaultRPC,\n      network: PUSH_NETWORK.TESTNET,\n    });\n  });\n\n  describe('pushToUSDC', () => {\n    it('converts 1 PUSH (1e18) to 0.1 USDC (1e7)', () => {\n      const result = client.pushToUSDC(BigInt('1000000000000000000'));\n      expect(result).toBe(BigInt(10000000));\n    });\n\n    it('returns 0 when input is 0', () => {\n      expect(client.pushToUSDC(BigInt(0))).toBe(BigInt(0));\n    });\n  });\n\n  describe('usdcToPush', () => {\n    it('converts 0.1 USDC (1e7) to 1 PUSH (1e18)', () => {\n      const result = client.usdcToPush(BigInt(10000000));\n      expect(result).toBe(BigInt('1000000000000000000'));\n    });\n\n    it('returns 0 when input is 0', () => {\n      expect(client.usdcToPush(BigInt(0))).toBe(BigInt(0));\n    });\n  });\n\n  describe('PushClient Msg & Cosmos Tx Tests', () => {\n    it('creates MsgDeployUEA', () => {\n      const msg = client.createMsgDeployUEA(MSG_DEPLOY_UEA);\n      expect(msg.typeUrl).toBe('/uexecutor.v1.MsgDeployUEA');\n      expect(msg.value.length).toBeGreaterThan(0);\n    });\n\n    it('creates MsgMintPC', () => {\n      const msg = client.createMsgMintPC(MSG_MINT_PC);\n      expect(msg.typeUrl).toBe('/uexecutor.v1.MsgMintPC');\n      expect(msg.value.length).toBeGreaterThan(0);\n    });\n\n    it('creates MsgExecutePayload', () => {\n      const msg = client.createMsgExecutePayload(MSG_EXECUTE_PAYLOAD);\n      expect(msg.typeUrl).toBe('/uexecutor.v1.MsgExecutePayload');\n      expect(msg.value.length).toBeGreaterThan(0);\n    });\n\n    it('creates TxBody from multiple messages', async () => {\n      const msg1 = client.createMsgDeployUEA(MSG_DEPLOY_UEA);\n      const msg2 = client.createMsgMintPC(MSG_MINT_PC);\n      const txBody = await client.createCosmosTxBody([msg1, msg2], 'test memo');\n      expect(txBody.messages.length).toBe(2);\n      expect(txBody.memo).toBe('test memo');\n    });\n\n    it('signs tx', async () => {\n      const msg1 = client.createMsgDeployUEA(MSG_DEPLOY_UEA);\n      const msg2 = client.createMsgMintPC(MSG_MINT_PC);\n      const msg3 = client.createMsgExecutePayload(MSG_EXECUTE_PAYLOAD);\n      const txBody = await client.createCosmosTxBody([msg1, msg2, msg3]);\n      await client.signCosmosTx(txBody);\n    });\n\n    it('get tx', async () => {\n      const query =\n        '0x7faf47ef206f8aa356fe60a14d998cef6403ae8753948a5d8cddff7b23965be7';\n      const tx = await client.getCosmosTx(query);\n      console.log(tx);\n    });\n  });\n});\n",
  "packages/core/src/lib/push-client/push-client.ts": "import { hexToBytes, keccak256 } from 'viem';\nimport { MsgDeployUEA, MsgExecutePayload, MsgMintPC } from '../generated/v1/tx';\nimport { Any } from 'cosmjs-types/google/protobuf/any';\nimport { SignDoc, TxBody, TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\nimport { Writer } from 'protobufjs';\nimport { makeAuthInfoBytes, makeSignDoc } from '@cosmjs/proto-signing';\nimport {\n  DeliverTxResponse,\n  QueryClient,\n  setupAuthExtension,\n  StargateClient,\n  createProtobufRpcClient,\n} from '@cosmjs/stargate';\nimport {\n  QueryGetUniversalTxRequest,\n  QueryGetUniversalTxResponse,\n} from '../generated/uexecutor/v1/query';\nimport { Secp256k1 } from '@cosmjs/crypto';\nimport { Tendermint34Client } from '@cosmjs/tendermint-rpc';\nimport { BaseAccount } from 'cosmjs-types/cosmos/auth/v1beta1/auth';\nimport { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';\nimport { toBech32 } from '@cosmjs/encoding';\nimport { EvmClient } from '../vm-client/evm-client';\nimport { PushClientOptions } from './push-client.types';\nimport { PUSH_CHAIN_INFO } from '../constants/chain';\nimport { CHAIN, PUSH_NETWORK } from '../constants/enums';\n\nexport class PushClient extends EvmClient {\n  public pushChainInfo;\n  private readonly ephemeralKey;\n  constructor(clientOptions: PushClientOptions) {\n    super(clientOptions);\n    this.pushChainInfo =\n      clientOptions.network === PUSH_NETWORK.MAINNET\n        ? PUSH_CHAIN_INFO[CHAIN.PUSH_MAINNET]\n        : clientOptions.network === PUSH_NETWORK.TESTNET_DONUT\n        ? PUSH_CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT]\n        : PUSH_CHAIN_INFO[CHAIN.PUSH_LOCALNET];\n\n    if (clientOptions.network === PUSH_NETWORK.MAINNET) {\n      this.pushChainInfo = PUSH_CHAIN_INFO[CHAIN.PUSH_MAINNET];\n    } else if (\n      clientOptions.network === PUSH_NETWORK.TESTNET_DONUT ||\n      clientOptions.network === PUSH_NETWORK.TESTNET\n    ) {\n      this.pushChainInfo = PUSH_CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT];\n    } else {\n      this.pushChainInfo = PUSH_CHAIN_INFO[CHAIN.PUSH_LOCALNET];\n    }\n\n    this.ephemeralKey = generatePrivateKey();\n  }\n\n  /**\n   * Converts nPUSH (1e18) to USDC (1e8), fixed rate: 1 PUSH = 0.1 USDC\n   */\n  pushToUSDC(amount: bigint): bigint {\n    return (\n      (amount * this.pushChainInfo.pushToUsdcNumerator) /\n      this.pushChainInfo.pushToUsdcDenominator\n    );\n  }\n\n  /**\n   * Converts USDC (1e8) to nPUSH (1e18), fixed rate: 1 PUSH = 0.1 USDC\n   */\n  usdcToPush(amount: bigint): bigint {\n    return (\n      (amount * this.pushChainInfo.pushToUsdcDenominator) /\n      this.pushChainInfo.pushToUsdcNumerator\n    );\n  }\n\n  // --- Msg Creators ---\n\n  createMsgDeployUEA(input: MsgDeployUEA): Any {\n    return {\n      typeUrl: '/uexecutor.v1.MsgDeployUEA',\n      value: MsgDeployUEA.encode(MsgDeployUEA.fromPartial(input)).finish(),\n    };\n  }\n\n  createMsgMintPC(input: MsgMintPC): Any {\n    return {\n      typeUrl: '/uexecutor.v1.MsgMintPC',\n      value: MsgMintPC.encode(MsgMintPC.fromPartial(input)).finish(),\n    };\n  }\n\n  createMsgExecutePayload(input: MsgExecutePayload): Any {\n    return {\n      typeUrl: '/uexecutor.v1.MsgExecutePayload',\n      value: MsgExecutePayload.encode(\n        MsgExecutePayload.fromPartial(input)\n      ).finish(),\n    };\n  }\n\n  // --- Tx Builder ---\n\n  async createCosmosTxBody(messages: Any[], memo?: string): Promise<TxBody> {\n    return TxBody.fromPartial({ messages, memo });\n  }\n\n  // --- Tx Signer ---\n  getSignerAddress() {\n    const account = privateKeyToAccount(this.ephemeralKey);\n    return {\n      evmAddress: account.address,\n      cosmosAddress: toBech32(\n        this.pushChainInfo.prefix,\n        hexToBytes(account.address)\n      ),\n    };\n  }\n\n  /**\n   * Signs a Cosmos tx using a temporary account.\n   * In prod, signer should be passed in instead.\n   */\n  async signCosmosTx(txBody: TxBody): Promise<TxRaw> {\n    const account = privateKeyToAccount(this.ephemeralKey);\n    const sender = toBech32(\n      this.pushChainInfo.prefix,\n      hexToBytes(account.address)\n    );\n\n    //  Get on-chain account info\n    const tmClient = await Tendermint34Client.connect(\n      this.pushChainInfo.tendermintRpc\n    );\n    const status = await tmClient.status();\n    const chainId = status.nodeInfo.network;\n\n    const queryClient = QueryClient.withExtensions(\n      tmClient,\n      setupAuthExtension\n    );\n    let baseAccount: BaseAccount | null = null;\n    try {\n      const accountResp = await queryClient.auth.account(sender);\n      baseAccount = BaseAccount.decode(accountResp!.value);\n    } catch (err) {\n      // Ignore\n    }\n\n    //  Encode pubkey\n    const uncompressedPubKey = hexToBytes(account.publicKey);\n    const compressedPubKey = Secp256k1.compressPubkey(uncompressedPubKey);\n    const pubkeyEncoded = {\n      typeUrl: '/cosmos.evm.crypto.v1.ethsecp256k1.PubKey',\n      value: Writer.create().uint32(10).bytes(compressedPubKey).finish(),\n    };\n\n    const authInfoBytes = makeAuthInfoBytes(\n      [\n        {\n          pubkey: pubkeyEncoded,\n          sequence: baseAccount ? Number(baseAccount.sequence) : 0,\n        },\n      ],\n      [],\n      100000000000, // gas\n      undefined,\n      undefined\n    );\n\n    const txBodyBytes = TxBody.encode(txBody).finish();\n    const signDoc = makeSignDoc(\n      txBodyBytes,\n      authInfoBytes,\n      chainId,\n      baseAccount ? Number(baseAccount.accountNumber) : 0\n    );\n\n    const digest = keccak256(SignDoc.encode(signDoc).finish());\n    const signature = await account.sign({ hash: digest });\n\n    return TxRaw.fromPartial({\n      bodyBytes: txBodyBytes,\n      authInfoBytes,\n      signatures: [hexToBytes(signature)],\n    });\n  }\n\n  async broadcastCosmosTx(txRaw: TxRaw): Promise<DeliverTxResponse> {\n    const client = await StargateClient.connect(\n      this.pushChainInfo.tendermintRpc\n    );\n    const result = await client.broadcastTx(TxRaw.encode(txRaw).finish());\n    return result;\n  }\n\n  /**\n   * Queries Push Chain's uexecutor gRPC service for a UniversalTx by its ID.\n   */\n  public async getUniversalTxById(\n    id: string\n  ): Promise<QueryGetUniversalTxResponse> {\n    const tmClient = await Tendermint34Client.connect(\n      this.pushChainInfo.tendermintRpc\n    );\n    const queryClient = new QueryClient(tmClient);\n    const rpc = createProtobufRpcClient(queryClient);\n\n    const request = QueryGetUniversalTxRequest.fromPartial({ id });\n    const responseBytes = await rpc.request(\n      'uexecutor.v1.Query',\n      'GetUniversalTx',\n      QueryGetUniversalTxRequest.encode(request).finish()\n    );\n    const response = QueryGetUniversalTxResponse.decode(responseBytes);\n    return response;\n  }\n\n  /**\n   * Fetches a Cosmos transaction by its hash.\n   * @param txHash The hexencoded transaction hash (without 0x or withboth work).\n   * @returns The indexed transaction (height, logs, events, etc.).\n   * @throws If the tx isnt found.\n   */\n  public async getCosmosTx(txHash: string): Promise<DeliverTxResponse> {\n    // 1. Connect to the Tendermint RPC\n    const client = await StargateClient.connect(\n      this.pushChainInfo.tendermintRpc\n    );\n\n    // Raw string querymust be one string, not a KV array:\n    const query = `ethereum_tx.ethereumTxHash='${txHash}'`;\n\n    const results = await client.searchTx(query);\n\n    // Convert bigint values to strings in the results. This is done to avoid JSON.stringify()\n    // from converting bigint to string when on the client side.\n    // On documentation, one thing very common was to use JSON.stringify() to log the results, then we would get an error.\n    const convertedResults = results.map((result) =>\n      JSON.parse(\n        JSON.stringify(result, (key, value) =>\n          typeof value === 'bigint' ? value.toString() : value\n        )\n      )\n    );\n\n    if (convertedResults.length === 0) {\n      throw new Error(`No Cosmos-indexed tx for EVM hash ${txHash}`);\n    }\n    return { ...convertedResults[0], transactionHash: txHash };\n  }\n}\n",
  "packages/core/src/lib/push-client/push-client.types.ts": "import { PUSH_NETWORK } from '../constants/enums';\nimport { ClientOptions } from '../vm-client/vm-client.types';\n\nexport type PushClientOptions = ClientOptions & {\n  network: PUSH_NETWORK;\n};\n",
  "packages/core/src/lib/universal/account/account.spec.ts": "import { CHAIN, LIBRARY, PUSH_NETWORK } from '../../constants/enums';\nimport { PushChain } from '../../push-chain/push-chain';\nimport { Orchestrator } from '../../orchestrator/orchestrator';\nimport { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';\nimport { toUniversalFromKeypair } from '../signer';\nimport { createWalletClient, getAddress, http } from 'viem';\nimport { CHAIN_INFO } from '../../constants/chain';\nimport { convertOriginToExecutor } from './account';\n\nconst EVM_ADDRESS = '0xeCba9a32A9823f1cb00cdD8344Bf2D1d87a8dd97';\n\ndescribe('Universal Account Utilities', () => {\n  describe('toChainAgnostic()', () => {\n    it('converts an address and chain to a CAIP-10 string for EVM', () => {\n      const caip = PushChain.utils.account.toChainAgnostic(EVM_ADDRESS, {\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n      });\n\n      expect(caip).toBe(`eip155:11155111:${EVM_ADDRESS}`);\n    });\n\n    it('converts an address and chain to a CAIP-10 string for Solana', () => {\n      const caip = PushChain.utils.account.toChainAgnostic('solanaAddress123', {\n        chain: CHAIN.SOLANA_TESTNET,\n      });\n\n      expect(caip).toBe(\n        'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z:solanaAddress123'\n      );\n    });\n  });\n\n  describe('fromChainAgnostic()', () => {\n    it('converts a CAIP-10 string to a UniversalAccount (EVM)', () => {\n      const account = PushChain.utils.account.fromChainAgnostic(\n        `eip155:11155111:${EVM_ADDRESS}`\n      );\n\n      expect(account.chain).toBe(CHAIN.ETHEREUM_SEPOLIA);\n      expect(account.address).toBe(EVM_ADDRESS);\n    });\n\n    it('converts a CAIP-10 string to a UniversalAccount (Solana)', () => {\n      const account = PushChain.utils.account.fromChainAgnostic(\n        'solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z:solanaAddress123'\n      );\n\n      expect(account.chain).toBe(CHAIN.SOLANA_TESTNET);\n      expect(account.address).toBe('solanaAddress123');\n    });\n\n    it('throws an error if the CAIP string is unsupported', () => {\n      expect(() =>\n        PushChain.utils.account.fromChainAgnostic('foo:999:bar')\n      ).toThrow('Unsupported or unknown CAIP address: foo:999:bar');\n    });\n  });\n\n  describe('convertOriginToExecutor() - Not Mocked', () => {\n    it('should return same address and pushChainClient.universal.account', async () => {\n      const account = privateKeyToAccount(generatePrivateKey());\n      const walletClient = createWalletClient({\n        account: account,\n        transport: http(CHAIN_INFO[CHAIN.ETHEREUM_SEPOLIA].defaultRPC[0]),\n      });\n      const signer = await toUniversalFromKeypair(walletClient, {\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n        library: LIBRARY.ETHEREUM_VIEM,\n      });\n\n      const orchestrator = new Orchestrator(signer, PUSH_NETWORK.TESTNET_DONUT);\n      const address = orchestrator.computeUEAOffchain();\n      const address2 = await orchestrator.computeUEA();\n      const result = await PushChain.utils.account.convertOriginToExecutor(\n        signer.account,\n        {\n          onlyCompute: true,\n        }\n      );\n\n      expect(address).toBe(result.address);\n      expect(address2.address).toBe(result.address);\n\n      const address3 = await PushChain.utils.account.convertOriginToExecutor(\n        signer.account,\n        {\n          onlyCompute: true,\n        }\n      );\n      expect(address3.address).toBe(address2.address);\n    });\n  });\n\n  describe('convertExecutorToOriginAccount()', () => {\n    it('Solana: should return valid origin data for a UEA address', async () => {\n      const testAddress = '0xbCfaD05E5f19Ae46feAab2F72Ad9977BC239b395';\n\n      const result =\n        await PushChain.utils.account.convertExecutorToOriginAccount(\n          testAddress\n        );\n\n      // Validate the result structure - should be an object { account, exists }\n      expect(result).toHaveProperty('account');\n      expect(result).toHaveProperty('exists');\n\n      const { account, exists } = result;\n\n      // Validate the account object structure\n      expect(account).toEqual({\n        chain: CHAIN.SOLANA_DEVNET,\n        address: '72JBejJFXrRKpQ69Hmaqr7vWJr6pdZXFEL6jt3sadsXU',\n      });\n\n      // Validate exists flag\n      expect(exists).toBe(true);\n    }, 30000); // 30 second timeout for network call\n\n    it('Ethereum: should return valid origin data for a UEA address', async () => {\n      const testAddress = '0x7AEE1699FeE2C906251863D24D35B3dEbe0932EC';\n\n      const result =\n        await PushChain.utils.account.convertExecutorToOriginAccount(\n          testAddress\n        );\n\n      // Validate the result structure - should be an object { account, exists }\n      expect(result).toHaveProperty('account');\n      expect(result).toHaveProperty('exists');\n\n      const { account, exists } = result;\n\n      // Validate the account object structure\n      expect(account).toEqual({\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n        address: getAddress('0xFd6C2fE69bE13d8bE379CCB6c9306e74193EC1A9'),\n      });\n\n      // Validate exists flag\n      expect(exists).toBe(true);\n    }, 30000); // 30 second timeout for network call\n  });\n\n  describe('convertOriginToExecutor() - Direct Tests', () => {\n    it('should return same address for Push Chain with onlyCompute=true', async () => {\n      const pushAccount = {\n        chain: CHAIN.PUSH_TESTNET_DONUT,\n        address: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n      };\n\n      const result = await convertOriginToExecutor(pushAccount, {\n        onlyCompute: true,\n      });\n\n      expect(result.address).toBe(pushAccount.address);\n      expect(result.deployed).toBe(false);\n    });\n\n    it('should return address without deployed status for Push Chain with onlyCompute=false', async () => {\n      const pushAccount = {\n        chain: CHAIN.PUSH_TESTNET_DONUT,\n        address: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n      };\n\n      const result = await convertOriginToExecutor(pushAccount, {\n        onlyCompute: false,\n      });\n\n      expect(result.address).toBe(pushAccount.address);\n      expect(result.deployed).toBeUndefined();\n    });\n\n    it('should return address without deployed status for Push Chain with default options', async () => {\n      const pushAccount = {\n        chain: CHAIN.PUSH_TESTNET_DONUT,\n        address: '0x1234567890123456789012345678901234567890' as `0x${string}`,\n      };\n\n      const result = await convertOriginToExecutor(pushAccount);\n\n      expect(result.address).toBe(pushAccount.address);\n      expect(result.deployed).toBe(false);\n    });\n\n    it('should compute and cache address for EVM chain', async () => {\n      const evmAccount = {\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n        address: EVM_ADDRESS,\n      };\n\n      // First call should compute the address\n      const result1 = await convertOriginToExecutor(evmAccount, {\n        onlyCompute: true,\n      });\n\n      expect(result1.address).toMatch(/^0x[a-fA-F0-9]{40}$/);\n      expect(typeof result1.deployed).toBe('boolean');\n\n      // Second call should use cached address\n      const result2 = await convertOriginToExecutor(evmAccount, {\n        onlyCompute: true,\n      });\n\n      expect(result2.address).toBe(result1.address);\n      expect(result2.deployed).toBe(result1.deployed);\n    });\n  });\n\n  describe('toUniversal()', () => {\n    it('returns a checksummed address for EVM chains', () => {\n      const account = PushChain.utils.account.toUniversal(\n        EVM_ADDRESS.toLowerCase(),\n        {\n          chain: CHAIN.ETHEREUM_SEPOLIA,\n        }\n      );\n\n      expect(account.address).toBe(EVM_ADDRESS);\n      expect(account.chain).toBe(CHAIN.ETHEREUM_SEPOLIA);\n    });\n\n    it('returns the address as-is for non-EVM chains', () => {\n      const account = PushChain.utils.account.toUniversal('solanaAddress123', {\n        chain: CHAIN.SOLANA_TESTNET,\n      });\n\n      expect(account.address).toBe('solanaAddress123');\n      expect(account.chain).toBe(CHAIN.SOLANA_TESTNET);\n    });\n\n    it('throws an error on invalid EVM address format', () => {\n      expect(() =>\n        PushChain.utils.account.toUniversal('not-an-eth-address', {\n          chain: CHAIN.ETHEREUM_SEPOLIA,\n        })\n      ).toThrow('Invalid EVM address format');\n    });\n\n    it('works with different EVM chains', () => {\n      const account = PushChain.utils.account.toUniversal(EVM_ADDRESS, {\n        chain: CHAIN.ETHEREUM_MAINNET,\n      });\n\n      expect(account.address).toBe(EVM_ADDRESS);\n      expect(account.chain).toBe(CHAIN.ETHEREUM_MAINNET);\n    });\n\n    it('works with different Solana chains', () => {\n      const solanaAddress = 'DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1';\n      const account = PushChain.utils.account.toUniversal(solanaAddress, {\n        chain: CHAIN.SOLANA_DEVNET,\n      });\n\n      expect(account.address).toBe(solanaAddress);\n      expect(account.chain).toBe(CHAIN.SOLANA_DEVNET);\n    });\n  });\n});\n",
  "packages/core/src/lib/universal/account/account.ts": "import {\n  bytesToHex,\n  getAddress,\n  Abi,\n  http,\n  createPublicClient,\n  hexToBytes,\n} from 'viem';\nimport {\n  CHAIN_INFO,\n  PUSH_CHAIN_INFO,\n  VM_NAMESPACE,\n} from '../../constants/chain';\nimport { CHAIN, VM, PUSH_NETWORK } from '../../constants/enums';\nimport {\n  ExecutorAccountInfo,\n  OriginAccountInfo,\n  UniversalAccount,\n} from '../universal.types';\nimport { utils } from '@coral-xyz/anchor';\nimport { FACTORY_V1 } from '../../constants/abi';\nimport { PushClient } from '../../push-client/push-client';\nimport { Cache, CacheKeys } from '../../cache/cache';\nimport { PushChain } from '../../push-chain/push-chain';\n\n/**\n * Formats a blockchain address based on the virtual machine type of the provided chain.\n *\n * - For EVM chains, it converts the address to its checksummed format.\n * - For non-EVM chains (e.g., Solana), the original address is returned as-is. - Can be changed in future\n * @param {CHAIN} chain - A fully qualified chain identifier (e.g., CHAIN.ETHEREUM_MAINNET).\n * @param {string} address - The raw address string to normalize.\n * @returns {string} - A VM-compliant formatted address.\n *\n * @throws {Error} If an invalid EVM address is provided.\n *\n * @example\n * // EVM address gets checksummed\n * formatAddress(CHAIN.ETHEREUM_SEPOLIA, \"0xabcd...\") //  \"0xAbCd...\"\n *\n * @example\n * // Non-EVM address is returned as-is\n * formatAddress(CHAIN.SOLANA_DEVNET, \"solanaAddress123\") //  \"solanaAddress123\"\n */\nfunction formatAddress(chain: CHAIN, address: string): string {\n  if (CHAIN_INFO[chain].vm === VM.EVM) {\n    try {\n      return getAddress(address.toLowerCase());\n    } catch {\n      throw new Error('Invalid EVM address format');\n    }\n  }\n  return address;\n}\n\n/**\n * Creates a `UniversalAccount` object from an address and chain options.\n * Alternative to createUniversalAccount with a different parameter structure.\n *\n * @param {string} address - The account address.\n * @param {Object} options - The configuration options.\n * @param {CHAIN} options.chain - The chain the account is associated with.\n * @returns {UniversalAccount} A normalized account object with chain and address.\n *\n * @example\n * const universalAccount = toUniversal(\n *   '0x35B84d6848D16415177c64D64504663b998A6ab4',\n *   { chain: CHAIN.ETHEREUM_SEPOLIA }\n * );\n * //  { chain: CHAIN.ETHEREUM_SEPOLIA, address: '0x35B84d6848D16415177c64D64504663b998A6ab4' }\n */\nexport function toUniversal(\n  address: string,\n  options: { chain: CHAIN }\n): UniversalAccount {\n  return {\n    chain: options.chain,\n    address: formatAddress(options.chain, address),\n  };\n}\n\n/**\n * Converts an address and chain into a CAIP-10 style address string.\n *\n * Format: `namespace:chainId:address`\n * Namespace is derived from the chain's VM type using VM_NAMESPACE.\n *\n * @param {string} address - The account address to convert.\n * @param {Object} options - The configuration options.\n * @param {CHAIN} options.chain - The chain the account is associated with.\n * @returns {string} A CAIP-10 formatted string.\n *\n * @example\n * Utils.account.toChainAgnostic('0xabc123...', {\n *   chain: CHAIN.ETHEREUM_SEPOLIA\n * })\n * //  'eip155:11155111:0xabc123...'\n */\nexport function toChainAgnostic(\n  address: string,\n  options: { chain: CHAIN }\n): string {\n  const { chain } = options;\n\n  const chainMeta = CHAIN_INFO[chain];\n  if (!chainMeta) {\n    throw new Error(`Unrecognized chain: ${chain}`);\n  }\n\n  const { chainId, vm } = chainMeta;\n  const namespace = VM_NAMESPACE[vm];\n\n  return `${namespace}:${chainId}:${formatAddress(chain, address)}`;\n}\n\n/**\n * Converts a CAIP-10 formatted string into a UniversalAccount.\n *\n * @param {string} caip - A CAIP-10 address string (e.g., 'eip155:1:0xabc...').\n * @returns {UniversalAccount} The resolved account.\n * @throws {Error} If the CAIP string is invalid or unsupported.\n *\n * @example\n * Utils.account.fromChainAgnostic('eip155:11155111:0xabc...')\n * //  { chain: CHAIN.ETHEREUM_SEPOLIA, address: '0xabc...' }\n */\nexport function fromChainAgnostic(caip: string): UniversalAccount {\n  const [namespace, chainId, rawAddress] = caip.split(':');\n\n  const chain = (Object.entries(CHAIN_INFO).find(\n    ([, info]) =>\n      info.chainId === chainId && VM_NAMESPACE[info.vm] === namespace\n  )?.[0] ?? null) as CHAIN | null;\n\n  if (!chain) {\n    throw new Error(`Unsupported or unknown CAIP address: ${caip}`);\n  }\n\n  return {\n    chain,\n    address: formatAddress(chain, rawAddress),\n  };\n}\n\n// Global cache instance for convertOriginToExecutor\nconst accountCache = new Cache();\n\n/**\n * Determines the Push Network based on the chain type (testnet vs mainnet)\n */\nfunction getPushNetworkFromChain(chain: CHAIN): PUSH_NETWORK {\n  const testnetChains = [\n    CHAIN.ETHEREUM_SEPOLIA,\n    CHAIN.ARBITRUM_SEPOLIA,\n    CHAIN.BASE_SEPOLIA,\n    CHAIN.BNB_TESTNET,\n    CHAIN.SOLANA_TESTNET,\n    CHAIN.SOLANA_DEVNET,\n    CHAIN.PUSH_TESTNET_DONUT,\n    CHAIN.PUSH_TESTNET,\n    CHAIN.PUSH_LOCALNET,\n  ];\n\n  const mainnetChains = [\n    CHAIN.ETHEREUM_MAINNET,\n    CHAIN.SOLANA_MAINNET,\n    CHAIN.PUSH_MAINNET,\n  ];\n\n  const localnetChains = [CHAIN.PUSH_LOCALNET];\n\n  if (testnetChains.includes(chain)) {\n    return PUSH_NETWORK.TESTNET_DONUT;\n  } else if (mainnetChains.includes(chain)) {\n    return PUSH_NETWORK.MAINNET;\n  } else if (localnetChains.includes(chain)) {\n    return PUSH_NETWORK.LOCALNET;\n  } else {\n    throw new Error(`Unsupported chain for Push Network mapping: ${chain}`);\n  }\n}\n\nexport async function convertOriginToExecutor(\n  account: UniversalAccount,\n  options: {\n    onlyCompute?: boolean;\n  } = { onlyCompute: true }\n): Promise<ExecutorAccountInfo> {\n  const { chain, address } = account;\n  const { vm, chainId } = CHAIN_INFO[chain];\n\n  if (isPushChain(chain)) {\n    if (options.onlyCompute) {\n      return { address: account.address as `0x${string}`, deployed: false };\n    }\n    return { address: account.address as `0x${string}` };\n  }\n\n  // Determine Push Network from the chain\n  const pushNetwork = getPushNetworkFromChain(chain);\n\n  // Check cache for computed address\n  const cachedAddress = accountCache.get(\n    CacheKeys.ueaAddressOnchain(chain, address, pushNetwork, vm)\n  );\n\n  if (cachedAddress) {\n    if (options.onlyCompute) {\n      // Check cache for deployment status\n      const cachedDeploymentStatus = accountCache.get(\n        CacheKeys.deploymentStatus(cachedAddress)\n      );\n      if (cachedDeploymentStatus !== null) {\n        return {\n          address: cachedAddress as `0x${string}`,\n          deployed: cachedDeploymentStatus,\n        };\n      }\n    } else {\n      return { address: cachedAddress as `0x${string}` };\n    }\n  }\n\n  let pushChain: CHAIN;\n  if (pushNetwork === PUSH_NETWORK.MAINNET) {\n    pushChain = CHAIN.PUSH_MAINNET;\n  } else if (\n    pushNetwork === PUSH_NETWORK.TESTNET_DONUT ||\n    pushNetwork === PUSH_NETWORK.TESTNET\n  ) {\n    pushChain = CHAIN.PUSH_TESTNET_DONUT;\n  } else {\n    pushChain = CHAIN.PUSH_LOCALNET;\n  }\n\n  // Create PushClient to get factory address\n  const pushClient = new PushClient({\n    rpcUrls: CHAIN_INFO[pushChain].defaultRPC,\n    network: pushNetwork,\n  });\n\n  const computedAddress: `0x${string}` = await pushClient.readContract({\n    address: pushClient.pushChainInfo.factoryAddress,\n    abi: FACTORY_V1 as Abi,\n    functionName: 'computeUEA',\n    args: [\n      {\n        chainNamespace: VM_NAMESPACE[vm],\n        chainId: chainId,\n        /**\n         * @dev - OwnerKey should be in bytes\n         * for eth - convert hex to bytes\n         * for sol - convert base64 to bytes\n         * for others - not defined yet\n         */\n        owner:\n          vm === VM.EVM\n            ? address\n            : vm === VM.SVM\n            ? bytesToHex(utils.bytes.bs58.decode(address))\n            : address,\n      },\n    ],\n  });\n\n  // Cache the computed address\n  accountCache.set(\n    CacheKeys.ueaAddressOnchain(chain, address, pushNetwork, vm),\n    computedAddress\n  );\n\n  const byteCode = await pushClient.publicClient.getCode({\n    address: computedAddress,\n  });\n\n  const isDeployed = byteCode !== undefined;\n\n  // Cache the deployment status\n  accountCache.set(CacheKeys.deploymentStatus(computedAddress), isDeployed);\n\n  if (options.onlyCompute) {\n    return { address: computedAddress, deployed: isDeployed };\n  }\n  return { address: computedAddress };\n}\n\n/**\n * Convert Executor to Origin Account\n *\n * Given a UEA (executor) address on Push Chain, returns the mapped origin\n * account and an existence flag.\n */\nexport async function convertExecutorToOriginAccount(\n  ueaAddress: `0x${string}`\n): Promise<OriginAccountInfo> {\n  const RPC_URL = PUSH_CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].defaultRPC[0];\n  const FACTORY_ADDRESS =\n    PUSH_CHAIN_INFO[CHAIN.PUSH_TESTNET_DONUT].factoryAddress;\n\n  // Create viem public client\n  const client = createPublicClient({\n    transport: http(RPC_URL),\n  });\n\n  const originResult = (await client.readContract({\n    address: FACTORY_ADDRESS,\n    abi: FACTORY_V1,\n    functionName: 'getOriginForUEA',\n    args: [ueaAddress],\n  })) as [\n    { chainNamespace: string; chainId: string; owner: `0x${string}` },\n    boolean\n  ];\n\n  const [account, isUEA] = originResult;\n\n  if (\n    account.chainNamespace === '' ||\n    account.chainId === '' ||\n    account.owner === '0x'\n  ) {\n    return { account: null, exists: isUEA };\n  }\n\n  const universalAccount = PushChain.utils.account.fromChainAgnostic(\n    `${account.chainNamespace}:${account.chainId}:${account.owner}`\n  );\n  if (isUEA) {\n    if (universalAccount.chain.startsWith(VM_NAMESPACE[VM.SVM])) {\n      // Convert hex-encoded owner to base58 address format\n      const hexBytes = hexToBytes(account.owner);\n      universalAccount.address = utils.bytes.bs58.encode(hexBytes);\n    }\n  }\n\n  return { account: universalAccount, exists: isUEA };\n}\n\nfunction isPushChain(chain: CHAIN): boolean {\n  return (\n    chain === CHAIN.PUSH_MAINNET ||\n    chain === CHAIN.PUSH_TESTNET_DONUT ||\n    chain === CHAIN.PUSH_LOCALNET\n  );\n}\n",
  "packages/core/src/lib/universal/account/index.ts": "export * from './account';\n",
  "packages/core/src/lib/universal/signer/index.ts": "export * from './signer';\n",
  "packages/core/src/lib/universal/signer/signer.spec.ts": "import {\n  createUniversalSigner,\n  toUniversalFromKeypair,\n  toUniversal,\n  construct,\n} from './signer';\nimport {\n  WalletClient,\n  hexToBytes,\n  serializeTransaction,\n  TransactionSerializableEIP1559,\n} from 'viem';\nimport { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';\nimport { sepolia } from 'viem/chains';\nimport { Keypair } from '@solana/web3.js';\nimport { ethers } from 'ethers';\nimport { CHAIN, LIBRARY } from '../../constants/enums';\n\ndescribe('UniversalSigner utilities', () => {\n  describe('createUniversalSigner', () => {\n    it('should return a signer with provided methods and account', () => {\n      const dummy = {\n        account: { chain: CHAIN.ETHEREUM_SEPOLIA, address: '0xabc' },\n        signMessage: async (d: Uint8Array) => d,\n        signAndSendTransaction: async (d: Uint8Array) => d,\n        signTypedData: async () => new Uint8Array([1]),\n      };\n      const signer = createUniversalSigner(dummy);\n      expect(signer.account).toEqual(dummy.account);\n      expect(typeof signer.signMessage).toBe('function');\n      expect(typeof signer.signAndSendTransaction).toBe('function');\n      expect(typeof signer.signTypedData).toBe('function');\n    });\n  });\n\n  describe('toUniversalFromKeypair - viem', () => {\n    let mockClient: WalletClient;\n    let account: any;\n\n    beforeAll(() => {\n      const pk = generatePrivateKey();\n      account = privateKeyToAccount(pk);\n      mockClient = {\n        account,\n        getAddresses: jest.fn().mockResolvedValue([account.address]),\n        signMessage: jest.fn().mockResolvedValue('0xabcdef'),\n        sendTransaction: jest.fn().mockResolvedValue('0x123456'),\n        signTypedData: jest.fn().mockResolvedValue('0x789abc'),\n      } as unknown as WalletClient;\n    });\n\n    it('wraps WalletClient correctly', async () => {\n      const signer = await toUniversalFromKeypair(mockClient, {\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n        library: LIBRARY.ETHEREUM_VIEM,\n      });\n      expect(signer.account.chain).toBe(CHAIN.ETHEREUM_SEPOLIA);\n      expect(signer.account.address).toBe(account.address);\n\n      const msg = new TextEncoder().encode('hello');\n      const sig = await signer.signMessage(msg);\n      expect(sig).toBeInstanceOf(Uint8Array);\n      expect(sig).toEqual(hexToBytes('0xabcdef'));\n\n      const tx: TransactionSerializableEIP1559 = {\n        to: account.address as `0x${string}`,\n        value: BigInt(0),\n        data: '0x' as any,\n        chainId: sepolia.id,\n        maxFeePerGas: BigInt(1),\n        maxPriorityFeePerGas: BigInt(1),\n        nonce: 0,\n      };\n      const raw = hexToBytes(serializeTransaction(tx));\n      const hash = await signer.signAndSendTransaction(raw);\n      expect(hash).toBeInstanceOf(Uint8Array);\n      expect(hash).toEqual(hexToBytes('0x123456'));\n    });\n\n    it('rejects invalid account', async () => {\n      await expect(\n        toUniversalFromKeypair({} as any, {\n          chain: CHAIN.ETHEREUM_SEPOLIA,\n          library: LIBRARY.ETHEREUM_VIEM,\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('toUniversalFromKeypair - ethers v6', () => {\n    const pk = generatePrivateKey();\n    const mockProvider = {\n      getNetwork: jest.fn().mockResolvedValue({ chainId: BigInt(11155111) }),\n    } as any;\n    const wallet = new ethers.Wallet(pk, mockProvider);\n\n    it('wraps ethers.Wallet correctly', async () => {\n      const signer = await toUniversalFromKeypair(wallet, {\n        chain: CHAIN.ETHEREUM_SEPOLIA,\n        library: LIBRARY.ETHEREUM_ETHERSV6,\n      });\n      expect(signer.account.chain).toBe(CHAIN.ETHEREUM_SEPOLIA);\n      expect(signer.account.address).toBe(await wallet.getAddress());\n\n      const msg = new TextEncoder().encode('world');\n      const sig = await signer.signMessage(msg);\n      expect(sig).toBeInstanceOf(Uint8Array);\n      expect(sig.length).toBeGreaterThan(0);\n    });\n\n    it('throws if no provider', async () => {\n      const w = new ethers.Wallet(pk);\n      await expect(\n        toUniversalFromKeypair(w, {\n          chain: CHAIN.ETHEREUM_SEPOLIA,\n          library: LIBRARY.ETHEREUM_ETHERSV6,\n        })\n      ).rejects.toThrow('provider');\n    });\n  });\n\n  describe('toUniversalFromKeypair - solana', () => {\n    const keypair = Keypair.generate();\n\n    it('wraps Solana Keypair correctly', async () => {\n      const signer = await toUniversalFromKeypair(keypair, {\n        chain: CHAIN.SOLANA_DEVNET,\n        library: LIBRARY.SOLANA_WEB3JS,\n      });\n      expect(signer.account.chain).toBe(CHAIN.SOLANA_DEVNET);\n      expect(signer.account.address).toBe(keypair.publicKey.toBase58());\n\n      const msg = new TextEncoder().encode('sol');\n      const sig = await signer.signMessage(msg);\n      expect(sig).toBeInstanceOf(Uint8Array);\n      expect(sig.length).toBe(64);\n    });\n\n    it('throws on wrong chain', async () => {\n      await expect(\n        toUniversalFromKeypair(keypair, {\n          chain: CHAIN.ETHEREUM_MAINNET,\n          library: LIBRARY.SOLANA_WEB3JS,\n        })\n      ).rejects.toThrow('Invalid chain');\n    });\n  });\n\n  describe('toUniversal', () => {\n    it('preserves skeleton methods', async () => {\n      const skeleton = {\n        signerId: 's',\n        account: { chain: CHAIN.ETHEREUM_SEPOLIA, address: '0x1' },\n        signMessage: async (d: Uint8Array) => d,\n        signAndSendTransaction: async (d: Uint8Array) => d,\n        signTypedData: async () => new Uint8Array([1]),\n      };\n      const uni = await toUniversal(skeleton as any);\n      expect(uni.signMessage).toBe(skeleton.signMessage);\n      expect(uni.signAndSendTransaction).toBe(skeleton.signAndSendTransaction);\n      expect(uni.signTypedData).toBe(skeleton.signTypedData);\n    });\n  });\n\n  describe('construct', () => {\n    const mockAccount = {\n      chain: CHAIN.ETHEREUM_SEPOLIA,\n      address: '0x123',\n    };\n\n    const mockOptions = {\n      signMessage: async (data: Uint8Array) => data,\n      signAndSendTransaction: async (data: Uint8Array) => data,\n    };\n\n    it('should create a UniversalSignerSkeleton with required parameters', () => {\n      const signer = construct(mockAccount, mockOptions);\n\n      expect(signer.signerId).toBe('CustomGeneratedSigner');\n      expect(signer.account).toEqual(mockAccount);\n      expect(signer.signMessage).toBe(mockOptions.signMessage);\n      expect(signer.signAndSendTransaction).toBe(\n        mockOptions.signAndSendTransaction\n      );\n      expect(signer.signTypedData).toBeUndefined();\n    });\n\n    it('should include signTypedData when provided', () => {\n      const mockSignTypedData = async () => new Uint8Array([1]);\n      const signer = construct(mockAccount, {\n        ...mockOptions,\n        signTypedData: mockSignTypedData,\n      });\n\n      expect(signer.signTypedData).toBe(mockSignTypedData);\n    });\n\n    it('should throw error when signTypedData is provided for Solana chain', () => {\n      const solanaAccount = {\n        chain: CHAIN.SOLANA_MAINNET,\n        address: 'solana-address',\n      };\n\n      const mockSignTypedData = async () => new Uint8Array([1]);\n\n      expect(() =>\n        construct(solanaAccount, {\n          ...mockOptions,\n          signTypedData: mockSignTypedData,\n        })\n      ).toThrow('Typed data signing is not supported for Solana');\n    });\n\n    it('should work with Solana chain when signTypedData is not provided', () => {\n      const solanaAccount = {\n        chain: CHAIN.SOLANA_MAINNET,\n        address: 'solana-address',\n      };\n\n      const signer = construct(solanaAccount, mockOptions);\n\n      expect(signer.signerId).toBe('CustomGeneratedSigner');\n      expect(signer.account).toEqual(solanaAccount);\n      expect(signer.signMessage).toBe(mockOptions.signMessage);\n      expect(signer.signAndSendTransaction).toBe(\n        mockOptions.signAndSendTransaction\n      );\n      expect(signer.signTypedData).toBeUndefined();\n    });\n  });\n\n  describe('construct + toUniversal two-step process', () => {\n    const mockAccount = {\n      chain: CHAIN.ETHEREUM_SEPOLIA,\n      address: '0x123',\n    };\n\n    // Raw functions that will be used to create the signer\n    const rawSignMessage = async (data: Uint8Array) => {\n      return new Uint8Array([...data, 1, 2, 3]); // Append some bytes to simulate signing\n    };\n\n    const rawSignAndSendTransaction = async (data: Uint8Array) => {\n      return new Uint8Array([...data, 4, 5, 6]); // Append some bytes to simulate tx hash\n    };\n\n    const rawSignTypedData = async ({\n      domain,\n      types,\n      primaryType,\n      message,\n    }: {\n      domain: any;\n      types: any;\n      primaryType: string;\n      message: any;\n    }) => {\n      return new Uint8Array([7, 8, 9]); // Return some bytes to simulate typed data signature\n    };\n\n    it('should create a UniversalSigner through construct + toUniversal', async () => {\n      // Step 1: Create a UniversalSignerSkeleton using construct\n      const skeleton = construct(mockAccount, {\n        signMessage: rawSignMessage,\n        signAndSendTransaction: rawSignAndSendTransaction,\n        signTypedData: rawSignTypedData,\n      });\n\n      // Verify the skeleton structure\n      expect(skeleton.signerId).toBe('CustomGeneratedSigner');\n      expect(skeleton.account).toEqual(mockAccount);\n      expect(skeleton.signMessage).toBe(rawSignMessage);\n      expect(skeleton.signAndSendTransaction).toBe(rawSignAndSendTransaction);\n      expect(skeleton.signTypedData).toBe(rawSignTypedData);\n\n      // Step 2: Convert the skeleton to a UniversalSigner using toUniversal\n      const universalSigner = await toUniversal(skeleton);\n\n      // Verify the universal signer structure\n      expect(universalSigner.account).toEqual(mockAccount);\n      expect(universalSigner.signMessage).toBe(rawSignMessage);\n      expect(universalSigner.signAndSendTransaction).toBe(\n        rawSignAndSendTransaction\n      );\n      expect(universalSigner.signTypedData).toBe(rawSignTypedData);\n\n      // Test the actual functionality\n      const testMessage = new Uint8Array([1, 2, 3]);\n      const signedMessage = await universalSigner.signMessage(testMessage);\n      expect(signedMessage).toEqual(new Uint8Array([1, 2, 3, 1, 2, 3]));\n\n      const testTx = new Uint8Array([4, 5, 6]);\n      const txHash = await universalSigner.signAndSendTransaction(testTx);\n      expect(txHash).toEqual(new Uint8Array([4, 5, 6, 4, 5, 6]));\n\n      if (universalSigner.signTypedData) {\n        const typedDataSignature = await universalSigner.signTypedData({\n          domain: {},\n          types: {},\n          primaryType: 'Test',\n          message: {},\n        });\n        expect(typedDataSignature).toEqual(new Uint8Array([7, 8, 9]));\n      }\n    });\n\n    it('should work without signTypedData for Solana chain', async () => {\n      const solanaAccount = {\n        chain: CHAIN.SOLANA_MAINNET,\n        address: 'solana-address',\n      };\n\n      // Step 1: Create skeleton without signTypedData\n      const skeleton = construct(solanaAccount, {\n        signMessage: rawSignMessage,\n        signAndSendTransaction: rawSignAndSendTransaction,\n      });\n\n      // Step 2: Convert to UniversalSigner\n      const universalSigner = await toUniversal(skeleton);\n\n      // Verify structure\n      expect(universalSigner.account).toEqual(solanaAccount);\n      expect(universalSigner.signMessage).toBe(rawSignMessage);\n      expect(universalSigner.signAndSendTransaction).toBe(\n        rawSignAndSendTransaction\n      );\n      expect(universalSigner.signTypedData).toBeUndefined();\n\n      // Test functionality\n      const testMessage = new Uint8Array([1, 2, 3]);\n      const signedMessage = await universalSigner.signMessage(testMessage);\n      expect(signedMessage).toEqual(new Uint8Array([1, 2, 3, 1, 2, 3]));\n    });\n  });\n});\n",
  "packages/core/src/lib/universal/signer/signer.ts": "import {\n  bytesToHex,\n  hexToBytes,\n  parseTransaction,\n  WalletClient,\n  Hex,\n} from 'viem';\nimport { TypedDataDomain, TypedData } from '../../constants';\nimport {\n  EthersV5SignerType,\n  EthersV6SignerType,\n  UniversalAccount,\n  UniversalSigner,\n  UniversalSignerSkeleton,\n  ViemSignerType,\n} from '../universal.types';\nimport * as nacl from 'tweetnacl';\nimport { Connection, Keypair, PublicKey, Transaction } from '@solana/web3.js';\nimport { CHAIN, LIBRARY } from '../../constants/enums';\nimport { ethers, getBytes, hexlify } from 'ethers';\nimport { CHAIN_INFO } from '../../constants/chain';\nimport { utils } from '@coral-xyz/anchor';\n\n/**\n * Creates a `UniversalSigner` object for signing messages and transactions\n * on any supported chain.\n *\n * @param {Object} params - The signer configuration object.\n * @param {string} params.address - The signer's address.\n * @param {(data: Uint8Array) => Promise<Uint8Array>} params.signMessage - Required function to sign messages.\n * @param {(data: Uint8Array) => Promise<Uint8Array>} [params.signAndSendTransaction] - Required function to sign and send transactions.\n * @param {CHAIN} params.chain - The chain the signer will operate on.\n * @returns {UniversalSigner} A signer object with chain metadata.\n *\n * @example\n * const signer = createUniversalSigner({\n *   chain: CHAIN.ETHEREUM_SEPOLIA\n *   address: \"0xabc...\",\n *   signMessage: async (data) => sign(data),\n *   signAndSendTransaction: async (data) => signRawTx(data),\n * });\n */\nexport function createUniversalSigner({\n  account,\n  signMessage,\n  signAndSendTransaction,\n  signTypedData,\n}: UniversalSigner): UniversalSigner {\n  return {\n    account,\n    signMessage,\n    signAndSendTransaction,\n    signTypedData,\n  };\n}\n\n/**\n * Creates a UniversalSigner from either a viem, ethers, solana WalletClient or Account instance.\n *\n * @param {WalletClient | Account | Keypair | ethers.HDNodeWallet} clientOrAccount - The viem WalletClient or Account instance\n * @param {CHAIN} chain - The chain the signer will operate on\n * @returns {Promise<UniversalSigner>} A signer object configured for the specified chain\n */\nexport async function toUniversalFromKeypair(\n  clientOrAccount: WalletClient | Keypair | ethers.Wallet | ethers.HDNodeWallet,\n  { chain, library }: { chain: CHAIN; library: LIBRARY }\n): Promise<UniversalSigner> {\n  let address: string;\n  let signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n  let signAndSendTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n  let signTypedData: ({\n    domain,\n    types,\n    primaryType,\n    message,\n  }: {\n    domain: TypedDataDomain;\n    types: TypedData;\n    primaryType: string;\n    message: Record<string, any>;\n  }) => Promise<Uint8Array>;\n\n  // Check if signer has UID='custom', then we take signMessage, signAndSendTransaction, signTypedData, chain and address from the CustomUniversalSigner.\n  // If ViemSigner, convert ViemSigner to UniversalSigner.\n\n  switch (library) {\n    case LIBRARY.ETHEREUM_ETHERSV6: {\n      if (\n        typeof (clientOrAccount as any).signMessage !== 'function' ||\n        typeof (clientOrAccount as any).sendTransaction !== 'function' ||\n        typeof (clientOrAccount as any).getAddress !== 'function'\n      ) {\n        throw new Error(\n          'Expected an object with signMessage, sendTransaction, getAddress methods for ETHEREUM_ETHERSV6 library'\n        );\n      }\n      const wallet = clientOrAccount as ethers.Wallet | ethers.HDNodeWallet;\n      if (!wallet.provider) {\n        throw new Error('ethers.Wallet must have a provider attached');\n      }\n      // fetch on-chain chainId\n      const { chainId } = await wallet.provider.getNetwork();\n      if (chainId.toString() !== chain.split(':')[1]) {\n        throw new Error(\n          `Chain mismatch: wallet is on ${chainId}, expected ${chain}`\n        );\n      }\n\n      address = await wallet.getAddress();\n\n      // raw bytes  ethers.signMessage  hex  back to bytes\n      signMessage = async (data) => {\n        const sigHex = await wallet.signMessage(data);\n        return getBytes(sigHex);\n      };\n\n      // raw unsigned tx bytes  hex  parse  signAndSendTransaction  bytes\n      signAndSendTransaction = async (raw) => {\n        const unsignedHex = hexlify(raw);\n        const tx = ethers.Transaction.from(unsignedHex);\n        const txResponse = await wallet.sendTransaction(tx);\n        return hexToBytes(txResponse.hash as Hex);\n      };\n\n      // EIP-712 typed data  _signTypedData  hex  bytes\n      signTypedData = async ({ domain, types, primaryType, message }) => {\n        const sigHex = await wallet.signTypedData(\n          domain,\n          types as unknown as Record<string, any[]>,\n          message\n        );\n        return getBytes(sigHex);\n      };\n\n      break;\n    }\n\n    case LIBRARY.ETHEREUM_VIEM: {\n      const wallet = clientOrAccount as WalletClient;\n      address = (await wallet.getAddresses())[0];\n\n      signMessage = async (data: Uint8Array) => {\n        const hexSig = await (clientOrAccount as WalletClient).signMessage({\n          account: wallet.account || (address as `0x${string}`),\n          message: { raw: data },\n        });\n        return hexToBytes(hexSig);\n      };\n\n      signAndSendTransaction = async (unsignedTx: Uint8Array) => {\n        const tx = parseTransaction(bytesToHex(unsignedTx));\n        const txHash = await wallet.sendTransaction(tx as never);\n        return hexToBytes(txHash);\n      };\n\n      signTypedData = async ({ domain, types, primaryType, message }) => {\n        const hexSig = await wallet.signTypedData({\n          domain,\n          types,\n          primaryType,\n          message,\n          account:\n            (clientOrAccount as WalletClient).account ||\n            (address as `0x${string}`),\n        });\n        return hexToBytes(hexSig);\n      };\n      break;\n    }\n\n    case LIBRARY.SOLANA_WEB3JS: {\n      const keypair = clientOrAccount as Keypair;\n      if (\n        chain !== CHAIN.SOLANA_MAINNET &&\n        chain !== CHAIN.SOLANA_TESTNET &&\n        chain !== CHAIN.SOLANA_DEVNET\n      ) {\n        throw new Error('Invalid chain for Solana Keypair');\n      }\n\n      address = keypair.publicKey.toBase58();\n\n      signMessage = async (data: Uint8Array) => {\n        return nacl.sign.detached(data, keypair.secretKey);\n      };\n\n      //  Sign and send the transaction to Solana network\n      signAndSendTransaction = async (unsignedTx: Uint8Array) => {\n        // sign\n        const tx = Transaction.from(unsignedTx);\n        const messageBytes = tx.serializeMessage();\n        const signature = nacl.sign.detached(messageBytes, keypair.secretKey);\n        tx.addSignature(\n          new PublicKey(keypair.publicKey.toBase58()),\n          Buffer.from(signature)\n        );\n        const rawTx = tx.serialize();\n        const endpoint = CHAIN_INFO[chain].defaultRPC[0];\n        const connection = new Connection(endpoint, 'confirmed');\n        const txHash = await connection.sendRawTransaction(rawTx);\n        return utils.bytes.bs58.decode(txHash);\n      };\n\n      signTypedData = async () => {\n        throw new Error('Typed data signing is not supported for Solana');\n      };\n\n      break;\n    }\n\n    default: {\n      throw new Error(`Unsupported library: ${library}`);\n    }\n  }\n\n  const universalSigner: UniversalSigner = {\n    account: {\n      address,\n      chain,\n    },\n    signMessage,\n    signAndSendTransaction,\n    signTypedData,\n  };\n  return createUniversalSigner(universalSigner);\n}\n\n// `signTypedData` is only mandatory for EVM Signers. For Solana, this is not necessary.\nexport function construct(\n  account: UniversalAccount,\n  options: {\n    signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n    signAndSendTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n    signTypedData?: ({\n      domain,\n      types,\n      primaryType,\n      message,\n    }: {\n      domain: TypedDataDomain;\n      types: TypedData;\n      primaryType: string;\n      message: Record<string, any>;\n    }) => Promise<Uint8Array>;\n  }\n): UniversalSignerSkeleton {\n  const { signMessage, signAndSendTransaction, signTypedData } = options;\n  if (\n    signTypedData &&\n    (account.chain === CHAIN.SOLANA_MAINNET ||\n      account.chain === CHAIN.SOLANA_TESTNET ||\n      account.chain === CHAIN.SOLANA_DEVNET)\n  ) {\n    throw new Error('Typed data signing is not supported for Solana');\n  }\n\n  return {\n    signerId: 'CustomGeneratedSigner',\n    account,\n    signMessage,\n    signAndSendTransaction,\n    signTypedData,\n  };\n}\n\nexport async function toUniversal(\n  signer:\n    | UniversalSignerSkeleton\n    | EthersV6SignerType\n    | EthersV5SignerType\n    | ViemSignerType\n): Promise<UniversalSigner> {\n  if ('signerId' in signer) {\n    return createUniversalSigner(signer as UniversalSignerSkeleton);\n  }\n\n  let skeleton: UniversalSignerSkeleton;\n  if (!isViemSigner(signer)) {\n    const wallet = signer as EthersV5SignerType | EthersV6SignerType;\n    if (!wallet.provider) {\n      throw new Error(\n        'ethers.Wallet must have a provider attached to determine chain'\n      );\n    }\n\n    // Check if _signTypedData property is present to determine if it's EthersV5 or EthersV6\n    if ('_signTypedData' in wallet) {\n      skeleton = await generateSkeletonFromEthersV5(\n        wallet as EthersV5SignerType\n      );\n    } else {\n      skeleton = await generateSkeletonFromEthersV6(\n        wallet as EthersV6SignerType\n      );\n    }\n  } else {\n    skeleton = await generateSkeletonFromViem(signer as ViemSignerType);\n  }\n\n  return createUniversalSigner(skeleton);\n}\n\nasync function generateSkeletonFromEthersV5(\n  signer: EthersV5SignerType\n): Promise<UniversalSignerSkeleton> {\n  const address = await signer.getAddress();\n\n  const { chainId } = await signer.provider.getNetwork();\n\n  // Map chainId to CHAIN enum - this is a simplified mapping\n  let chain: CHAIN;\n  switch (chainId.toString()) {\n    case '11155111':\n      chain = CHAIN.ETHEREUM_SEPOLIA;\n      break;\n    case '421614':\n      chain = CHAIN.ARBITRUM_SEPOLIA;\n      break;\n    case '84532':\n      chain = CHAIN.BASE_SEPOLIA;\n      break;\n    case '97':\n      chain = CHAIN.BNB_TESTNET;\n      break;\n    case '1':\n      chain = CHAIN.ETHEREUM_MAINNET;\n      break;\n    case '9':\n      chain = CHAIN.PUSH_MAINNET;\n      break;\n    case '42101':\n      chain = CHAIN.PUSH_TESTNET;\n      break;\n    case '9000':\n      chain = CHAIN.PUSH_LOCALNET;\n      break;\n    default:\n      throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n\n  if (!Object.values(CHAIN).includes(chain)) {\n    throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n\n  return {\n    signerId: `EthersSignerV5-${address}`,\n    account: { address, chain },\n\n    signMessage: async (data) => {\n      const sigHex = await signer.signMessage(data);\n      return getBytes(sigHex);\n    },\n\n    // raw unsigned tx bytes  hex  parse  signTransaction  bytes\n    signAndSendTransaction: async (raw) => {\n      const unsignedHex = hexlify(raw);\n      const tx = ethers.Transaction.from(unsignedHex);\n      const txResponse = await signer.sendTransaction(tx);\n      return hexToBytes(txResponse.hash as Hex);\n    },\n\n    signTypedData: async ({ domain, types, primaryType, message }) => {\n      const sigHex = await signer._signTypedData(\n        domain,\n        types as unknown as Record<string, any[]>,\n        message\n      );\n      return getBytes(sigHex);\n    },\n  };\n}\n\nasync function generateSkeletonFromEthersV6(\n  signer: EthersV6SignerType\n): Promise<UniversalSignerSkeleton> {\n  const address = await signer.getAddress();\n\n  const { chainId } = await signer.provider.getNetwork();\n\n  // Map chainId to CHAIN enum - this is a simplified mapping\n  let chain: CHAIN;\n  switch (chainId.toString()) {\n    case '11155111':\n      chain = CHAIN.ETHEREUM_SEPOLIA;\n      break;\n    case '421614':\n      chain = CHAIN.ARBITRUM_SEPOLIA;\n      break;\n    case '84532':\n      chain = CHAIN.BASE_SEPOLIA;\n      break;\n    case '97':\n      chain = CHAIN.BNB_TESTNET;\n      break;\n    case '1':\n      chain = CHAIN.ETHEREUM_MAINNET;\n      break;\n    case '9':\n      chain = CHAIN.PUSH_MAINNET;\n      break;\n    case '42101':\n      chain = CHAIN.PUSH_TESTNET;\n      break;\n    case '9000':\n      chain = CHAIN.PUSH_LOCALNET;\n      break;\n    default:\n      throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n\n  if (!Object.values(CHAIN).includes(chain)) {\n    throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n\n  return {\n    signerId: `EthersSignerV6-${address}`,\n    account: { address, chain },\n\n    signMessage: async (data) => {\n      const sigHex = await signer.signMessage(data);\n      return getBytes(sigHex);\n    },\n\n    // raw unsigned tx bytes  hex  parse  signTransaction  bytes\n    signAndSendTransaction: async (raw) => {\n      const unsignedHex = hexlify(raw);\n      const tx = ethers.Transaction.from(unsignedHex);\n      const txResponse = await signer.sendTransaction(tx);\n      return hexToBytes(txResponse.hash as Hex);\n    },\n\n    signTypedData: async ({ domain, types, primaryType, message }) => {\n      const sigHex = await signer.signTypedData(\n        domain,\n        types as unknown as Record<string, any[]>,\n        message\n      );\n      return getBytes(sigHex);\n    },\n  };\n}\n\nfunction isViemSigner(\n  signer: ViemSignerType | EthersV5SignerType | EthersV6SignerType\n) {\n  return (\n    typeof (signer as any).signTypedData === 'function' &&\n    typeof (signer as any).getChainId === 'function'\n  );\n}\n\nasync function generateSkeletonFromViem(\n  signer: ViemSignerType\n): Promise<UniversalSignerSkeleton> {\n  if (!signer.account) {\n    throw new Error('Signer account is not set');\n  }\n  const address = signer.account['address'];\n  const chainId = await signer.getChainId();\n\n  // Map chainId to CHAIN enum\n  let chain: CHAIN;\n  switch (chainId.toString()) {\n    case '11155111':\n      chain = CHAIN.ETHEREUM_SEPOLIA;\n      break;\n    case '421614':\n      chain = CHAIN.ARBITRUM_SEPOLIA;\n      break;\n    case '84532':\n      chain = CHAIN.BASE_SEPOLIA;\n      break;\n    case '97':\n      chain = CHAIN.BNB_TESTNET;\n      break;\n    case '1':\n      chain = CHAIN.ETHEREUM_MAINNET;\n      break;\n    case '9':\n      chain = CHAIN.PUSH_MAINNET;\n      break;\n    case '42101':\n      chain = CHAIN.PUSH_TESTNET;\n      break;\n    case '9000':\n      chain = CHAIN.PUSH_LOCALNET;\n      break;\n    default:\n      throw new Error(`Unsupported chainId: ${chainId}`);\n  }\n\n  return {\n    signerId: `ViemSigner-${address}`,\n    account: {\n      address,\n      chain,\n    },\n    signMessage: async (data: Uint8Array) => {\n      const hexSig = await signer.signMessage({\n        account: address as `0x${string}`,\n        message: { raw: data },\n      });\n      return hexToBytes(hexSig);\n    },\n    signAndSendTransaction: async (unsignedTx: Uint8Array) => {\n      // For viem signers, we need to handle transaction signing differently\n      // Since the ViemSignerType doesn't have signTransaction, we'll need to\n      // use the account's signTransaction method if available\n      if (signer.account['signTransaction']) {\n        const tx = parseTransaction(bytesToHex(unsignedTx));\n        const txHash = await signer.sendTransaction(tx);\n        return hexToBytes(txHash as Hex);\n      }\n      throw new Error(\n        'Transaction signing not supported for this viem signer type'\n      );\n    },\n    signTypedData: async ({ domain, types, primaryType, message }) => {\n      const hexSig = await signer.signTypedData({\n        domain,\n        types,\n        primaryType,\n        message,\n        account: (signer as WalletClient).account || (address as `0x${string}`),\n      });\n      return hexToBytes(hexSig);\n    },\n  };\n}\n",
  "packages/core/src/lib/universal/signer/signer.types.ts": "import { TypedData, TypedDataDomain } from 'viem';\n\nexport type { TypedDataDomain, TypedData };\n",
  "packages/core/src/lib/universal/universal.types.ts": "import { TypedData, TypedDataDomain } from '../constants';\nimport { CHAIN } from '../constants/enums';\n\n/**\n * A chain-agnostic account representation.\n * Used to represent a wallet address along with its chain context.\n */\nexport interface UniversalAccount {\n  /**\n   * Fully qualified chain (e.g., CHAIN.ETHEREUM_SEPOLIA, CHAIN.SOLANA_DEVNET)\n   */\n  chain: CHAIN;\n\n  /**\n   * The address on the respective chain (EVM: checksummed, Solana: base58, etc.)\n   */\n  address: string;\n}\n\nexport type ViemSignerType = {\n  signTypedData: (args: {\n    account: any;\n    domain: any;\n    types: any;\n    primaryType: any;\n    message: any;\n  }) => Promise<`0x${string}`>;\n  getChainId: () => Promise<number>;\n  signMessage: (args: {\n    message: any;\n    account: any;\n    [key: string]: any;\n  }) => Promise<`0x${string}`>;\n  account: { [key: string]: any };\n  sendTransaction: (transaction: any) => Promise<any>;\n  provider?: any;\n};\n\nexport interface EthersV5SignerType {\n  _signTypedData: (\n    domain: TypedDataDomain,\n    types: Record<string, Array<any>>,\n    value: Record<string, any>\n  ) => Promise<string>;\n  getAddress: () => Promise<string>;\n  signMessage: (message: Uint8Array | string) => Promise<string>;\n  sendTransaction: (transaction: any) => Promise<any>;\n  provider?: any;\n}\n\nexport interface EthersV6SignerType {\n  getAddress: () => Promise<string>;\n  signMessage: (message: Uint8Array | string) => Promise<string>;\n  sendTransaction: (tx: any) => Promise<any>;\n  signTypedData: (\n    domain: TypedDataDomain,\n    types: Record<string, Array<any>>,\n    value: Record<string, any>\n  ) => Promise<string>;\n  provider?: any;\n}\n\n/**\n * A signer capable of signing messages for a specific chain.\n * Used to abstract away signing across multiple VM types.\n */\nexport interface UniversalSigner {\n  account: UniversalAccount;\n\n  /**\n   * Signs an arbitrary data, provided as binary data.\n   *\n   * If data is a **string**, you MUST UTF-8 encode it before calling this method.\n   * @param data - The message to sign, as a Uint8Array.\n   * @returns A Promise that resolves to the signature (as a Uint8Array).\n   *\n   * @example\n   * const encoded = new TextEncoder().encode(\"hello world\");\n   * const signature = await signer.signMessage(encoded);\n   */\n  signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n\n  /**\n   * Signs a typed data, provided as binary data.\n   * @dev !! Only Required for Evm Signers !!\n   *\n   * @param data - The message to sign, as a Uint8Array.\n   * @returns A Promise that resolves to the signature (as a Uint8Array).\n   */\n  signTypedData?: ({\n    domain,\n    types,\n    primaryType,\n    message,\n  }: {\n    domain: TypedDataDomain;\n    types: TypedData;\n    primaryType: string;\n    message: Record<string, any>;\n  }) => Promise<Uint8Array>;\n\n  /**\n   * Signs and sends a transaction (unsigned tx bytes).\n   * Used for sending on-chain transactions.\n   */\n  signAndSendTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n}\n\nexport interface UniversalSignerSkeleton {\n  signerId: string;\n  account: UniversalAccount;\n  signMessage: (data: Uint8Array) => Promise<Uint8Array>;\n  signAndSendTransaction: (unsignedTx: Uint8Array) => Promise<Uint8Array>;\n  signTypedData?: ({\n    domain,\n    types,\n    primaryType,\n    message,\n  }: {\n    domain: TypedDataDomain;\n    types: TypedData;\n    primaryType: string;\n    message: Record<string, any>;\n  }) => Promise<Uint8Array>;\n}\n\n/**\n * Response model for converting an Executor (UEA) address to its Origin account.\n */\nexport interface OriginAccountInfo {\n  /**\n   * Resolved Origin account when the executor address maps to a known UEA; otherwise null.\n   */\n  account: UniversalAccount | null;\n  /**\n   * Whether the provided executor address corresponds to a Universal Executor Account (UEA).\n   */\n  exists: boolean;\n}\n\n/**\n * Response model for converting an Origin account to its Executor (UEA) address.\n */\nexport interface ExecutorAccountInfo {\n  /**\n   * The computed or resolved UEA address on Push Chain.\n   */\n  address: `0x${string}`;\n  /**\n   * When computed with deployment check, indicates if the UEA is deployed on-chain.\n   */\n  deployed?: boolean;\n}\n",
  "packages/core/src/lib/utils.ts": "import {\n  convertOriginToExecutor,\n  fromChainAgnostic,\n  convertExecutorToOriginAccount,\n  toChainAgnostic,\n  toUniversal,\n} from './universal/account';\nimport {\n  construct,\n  toUniversal as toUniversalSigner,\n  toUniversalFromKeypair,\n} from './universal/signer';\nimport { CHAIN, PUSH_NETWORK } from './constants/enums';\nimport {\n  MOVEABLE_TOKENS,\n  PAYABLE_TOKENS,\n  type MoveableToken,\n} from './constants/tokens';\nimport { SYNTHETIC_PUSH_ERC20 } from './constants/chain';\nimport { UniversalAccount } from './universal/universal.types';\nimport type { PushChain } from './push-chain/push-chain';\nimport { ethers } from 'ethers';\n\n/**\n * @dev - THESE UTILS ARE EXPORTED TO SDK CONSUMER\n * @dev - Make sure each exported fn has good comments to help out sdk consumer\n */\n\n/**\n * Utility class for handling CAIP-10 chain-agnostic address formatting\n * and universal account conversions.\n */\nexport class Utils {\n  static account = {\n    /*\n     * Converts a UniversalAccount into a CAIP-10 style address string.\n     *\n     * Format: `namespace:chainId:address`\n     * Namespace is derived from the chain's VM type using VM_NAMESPACE.\n     *\n     * @param {UniversalAccount} account - The account to convert.\n     * @returns {string} A CAIP-10 formatted string.\n     *\n     * @example\n     * Utils.account.toChainAgnostic({\n     *   chain: CHAIN.ETHEREUM_SEPOLIA,\n     *   address: '0xabc'\n     * })\n     * //  'eip155:11155111:0xabc'\n     */\n    toChainAgnostic,\n\n    toUniversal,\n\n    /**\n     * Converts a CAIP-10 formatted string into a UniversalAccount.\n     *\n     * @param {string} caip - A CAIP-10 address string (e.g., 'eip155:1:0xabc...').\n     * @returns {UniversalAccount} The resolved account.\n     * @throws {Error} If the CAIP string is invalid or unsupported.\n     *\n     * @example\n     * Utils.account.fromChainAgnostic('eip155:11155111:0xabc...')\n     * //  { chain: CHAIN.ETHEREUM_SEPOLIA, address: '0xabc...' }\n     */\n    fromChainAgnostic,\n\n    convertOriginToExecutor,\n\n    convertExecutorToOriginAccount,\n  };\n\n  static signer = {\n    /**\n     * Converts various signer types (viem, ethers v6, Solana) into a UniversalSigner.\n     */\n    toUniversalFromKeypair,\n    /**\n     * Constructs a UniversalSignerSkeleton from raw signing functions.\n     */\n    construct,\n    /**\n     * Converts a UniversalSignerSkeleton to a UniversalSigner.\n     */\n    toUniversal: toUniversalSigner,\n  };\n\n  static chains = {\n    /**\n     * Returns the list of supported chains for a given Push network.\n     * Future-proofed to return an object with a `chains` array.\n     *\n     * @param {PUSH_NETWORK} network - The Push network environment.\n     * @returns {{ chains: CHAIN[] }} Object containing supported chains.\n     *\n     * @example\n     * Utils.chains.getSupportedChains(PushChain.CONSTANTS.PUSH_NETWORK.TESTNET)\n     * // => { chains: [CHAIN.ETHEREUM_SEPOLIA, CHAIN.SOLANA_DEVNET] }\n     *\n     * @example\n     * Utils.chains.getSupportedChains(PushChain.CONSTANTS.PUSH_NETWORK.MAINNET)\n     * // => { chains: [] }\n     */\n    getSupportedChains: (\n      network: PUSH_NETWORK\n    ): {\n      chains: CHAIN[];\n    } => {\n      // Current support: expose test/dev chains; mainnet returns empty until GA\n      const mapping: Record<PUSH_NETWORK, CHAIN[]> = {\n        [PUSH_NETWORK.MAINNET]: [],\n        [PUSH_NETWORK.TESTNET]: [\n          CHAIN.ETHEREUM_SEPOLIA,\n          CHAIN.ARBITRUM_SEPOLIA,\n          CHAIN.BASE_SEPOLIA,\n          CHAIN.SOLANA_DEVNET,\n        ],\n        [PUSH_NETWORK.TESTNET_DONUT]: [\n          CHAIN.ETHEREUM_SEPOLIA,\n          CHAIN.ARBITRUM_SEPOLIA,\n          CHAIN.BASE_SEPOLIA,\n          CHAIN.SOLANA_DEVNET,\n        ],\n        [PUSH_NETWORK.LOCALNET]: [\n          CHAIN.ETHEREUM_SEPOLIA,\n          CHAIN.ARBITRUM_SEPOLIA,\n          CHAIN.BASE_SEPOLIA,\n          CHAIN.SOLANA_DEVNET,\n        ],\n      };\n\n      return { chains: mapping[network] ?? [] };\n    },\n\n    getChainName: (chainNamespace: string): string | undefined => {\n      // Special case: prefer PUSH_TESTNET_DONUT over PUSH_TESTNET for 'eip155:42101'\n      if (chainNamespace === 'eip155:42101') {\n        return 'PUSH_TESTNET_DONUT';\n      }\n\n      const chainEntries = Object.entries(CHAIN);\n      const foundEntry = chainEntries.find(\n        (entry) => entry[1] === chainNamespace\n      );\n\n      if (!foundEntry) {\n        return undefined;\n      }\n\n      return foundEntry[0];\n    },\n\n    /**\n     * Returns the chain namespace (e.g., 'eip155:11155111') for a given chain name.\n     * Reverse of getChainName. If input is already a namespace, it is returned.\n     *\n     * @param {string} chainName - The CHAIN key name (e.g., 'ETHEREUM_SEPOLIA' or 'PUSH_TESTNET_DONUT')\n     *                             or an existing namespace (e.g., 'eip155:11155111').\n     * @returns {string | undefined} The chain namespace, or undefined if unsupported.\n     */\n    getChainNamespace: (chainName: string): string | undefined => {\n      // If already a valid namespace value, return as-is\n      const namespaceValues = Object.values(CHAIN) as string[];\n      if (namespaceValues.includes(chainName)) {\n        return chainName;\n      }\n\n      // Map enum key -> value\n      const namespace = (CHAIN as Record<string, string | number>)[chainName];\n      if (typeof namespace === 'string') {\n        return namespace;\n      }\n\n      return undefined;\n    },\n  };\n\n  static helpers = {\n    /**\n     * @deprecated Use PushChain.utils.chains.getChainNamespace(chainName) instead.\n     * Alias maintained for backwards compatibility. Logs a deprecation warning\n     * and delegates to Utils.chains.getChainNamespace.\n     */\n    getChainName: (chainName: string): string | undefined => {\n      // Emit deprecation warning on every call to surface migration need\n      // Note: Keeping message explicit for SDK consumers\n      console.warn(\n        '[DEPRECATED] PushChain.utils.helper.getChainName is deprecated. ' +\n          'Use PushChain.utils.chains.getChainNamespace(chainName) instead.'\n      );\n      return Utils.chains.getChainName(chainName);\n    },\n    encodeTxData({\n      abi,\n      functionName,\n      args = [],\n    }: {\n      abi: any[];\n      functionName: string;\n      args?: any[];\n    }): `0x${string}` {\n      // Validate inputs\n      if (!Array.isArray(abi)) {\n        throw new Error('ABI must be an array');\n      }\n\n      if (!Array.isArray(args)) {\n        throw new Error('Arguments must be an array');\n      }\n\n      // Find the function in the ABI\n      const functionAbi = abi.find((f: any) => f.name === functionName);\n      if (!functionAbi) {\n        throw new Error(`Function '${functionName}' not found in ABI`);\n      }\n\n      try {\n        // Create ethers Interface and encode the function data\n        const abiInterface = new ethers.Interface(abi);\n        const data = abiInterface.encodeFunctionData(functionName, args);\n        return data as `0x${string}`;\n      } catch (error) {\n        throw new Error(\n          `Failed to encode function '${functionName}': ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    },\n\n    /**\n     * Multiplies a string representation of a number by a given exponent of base 10 (10^exponent).\n     *\n     * This is commonly used for converting human-readable token amounts to their on-chain representation.\n     * For example, converting \"1.5\" ETH to wei (18 decimals) would be parseUnits(\"1.5\", 18).\n     *\n     * @param {string} value - The string representation of the number to multiply.\n     * @param {number | {decimals: number}} exponent - The exponent (number of decimal places) or an object with decimals property.\n     * @returns {bigint} The result as a bigint.\n     *\n     * @example\n     * Utils.helpers.parseUnits('420', 9)\n     * //  420000000000n\n     *\n     * @example\n     * Utils.helpers.parseUnits('1.5', 18)\n     * //  1500000000000000000n\n     *\n     * @example\n     * Utils.helpers.parseUnits('1.5', {decimals: 18})\n     * //  1500000000000000000n\n     */\n    parseUnits(value: string, exponent: number | { decimals: number }): bigint {\n      // Validate inputs\n      if (typeof value !== 'string') {\n        throw new Error('Value must be a string');\n      }\n\n      // Extract the actual exponent value from either number or object\n      let actualExponent: number;\n      if (typeof exponent === 'number') {\n        actualExponent = exponent;\n      } else if (\n        typeof exponent === 'object' &&\n        exponent !== null &&\n        'decimals' in exponent\n      ) {\n        actualExponent = exponent.decimals;\n      } else {\n        throw new Error(\n          'Exponent must be a number or an object with decimals property'\n        );\n      }\n\n      if (typeof actualExponent !== 'number') {\n        throw new Error('Exponent must be a number');\n      }\n\n      if (!Number.isInteger(actualExponent)) {\n        throw new Error('Exponent must be an integer');\n      }\n\n      if (actualExponent < 0) {\n        throw new Error('Exponent must be non-negative');\n      }\n\n      // Handle empty string\n      if (value.trim() === '') {\n        throw new Error('Value cannot be empty');\n      }\n\n      // Remove any whitespace\n      const trimmedValue = value.trim();\n\n      // Check for valid number format\n      if (!/^-?\\d*\\.?\\d*$/.test(trimmedValue)) {\n        throw new Error('Value must be a valid number string');\n      }\n\n      // Handle case where value is just a decimal point\n      if (\n        trimmedValue === '.' ||\n        trimmedValue === '-.' ||\n        trimmedValue === ''\n      ) {\n        throw new Error('Value must be a valid number string');\n      }\n\n      try {\n        // Split on decimal point to handle fractional values\n        const parts = trimmedValue.split('.');\n        const integerPart = parts[0] || '0';\n        const fractionalPart = parts[1] || '';\n\n        // Check if fractional part has more digits than the exponent allows\n        if (fractionalPart.length > actualExponent) {\n          throw new Error(\n            `Value has more decimal places (${fractionalPart.length}) than exponent allows (${actualExponent})`\n          );\n        }\n\n        // Pad fractional part with zeros to match exponent\n        const paddedFractionalPart = fractionalPart.padEnd(actualExponent, '0');\n\n        // Combine integer and fractional parts\n        const combinedValue = integerPart + paddedFractionalPart;\n\n        // Convert to bigint\n        return BigInt(combinedValue);\n      } catch (error) {\n        if (\n          error instanceof Error &&\n          error.message.includes('decimal places')\n        ) {\n          throw error;\n        }\n        throw new Error(\n          `Failed to parse value '${value}': ${\n            error instanceof Error ? error.message : 'Invalid number format'\n          }`\n        );\n      }\n    },\n\n    /**\n     * Formats a value from smallest units to human-readable string.\n     *\n     * Supports both EVM-style (like ethers/viem) and Push-style (options object) usage patterns.\n     * Always returns a string for UI safety.\n     *\n     * @param {bigint | string} value - The value in smallest units (e.g., \"1500000\" or 1500000000000000000n).\n     * @param {number | {decimals: number; precision?: number}} decimalsOrOptions - Token decimals or options object.\n     * @returns {string} Human-readable string (e.g., \"1.5\").\n     *\n     * @example\n     * // EVM-style usage\n     * Utils.helpers.formatUnits(1500000000000000000n, 18)\n     * //  \"1.5\"\n     *\n     * @example\n     * // Push-style usage\n     * Utils.helpers.formatUnits(\"1500000\", { decimals: 6 })\n     * //  \"1.5\"\n     *\n     * @example\n     * // With precision (truncate after 2 decimals)\n     * Utils.helpers.formatUnits(\"1234567\", { decimals: 6, precision: 2 })\n     * //  \"1.23\"\n     */\n    formatUnits(\n      value: bigint | string,\n      decimalsOrOptions: number | { decimals: number; precision?: number }\n    ): string {\n      // Validate inputs\n      if (typeof value !== 'bigint' && typeof value !== 'string') {\n        throw new Error('Value must be a bigint or string');\n      }\n\n      // Extract decimals and precision from the second parameter\n      let decimals: number;\n      let precision: number | undefined;\n\n      if (typeof decimalsOrOptions === 'number') {\n        // EVM-style: formatUnits(value, decimals)\n        decimals = decimalsOrOptions;\n      } else if (\n        typeof decimalsOrOptions === 'object' &&\n        decimalsOrOptions !== null &&\n        'decimals' in decimalsOrOptions\n      ) {\n        // Push-style: formatUnits(value, { decimals, precision? })\n        decimals = decimalsOrOptions.decimals;\n        precision = decimalsOrOptions.precision;\n      } else {\n        throw new Error(\n          'Second parameter must be a number (decimals) or an object with decimals property'\n        );\n      }\n\n      // Validate decimals\n      if (typeof decimals !== 'number') {\n        throw new Error('Decimals must be a number');\n      }\n\n      if (!Number.isInteger(decimals)) {\n        throw new Error('Decimals must be an integer');\n      }\n\n      if (decimals < 0) {\n        throw new Error('Decimals must be non-negative');\n      }\n\n      // Validate precision if provided\n      if (precision !== undefined) {\n        if (typeof precision !== 'number') {\n          throw new Error('Precision must be a number');\n        }\n\n        if (!Number.isInteger(precision)) {\n          throw new Error('Precision must be an integer');\n        }\n\n        if (precision < 0) {\n          throw new Error('Precision must be non-negative');\n        }\n      }\n\n      try {\n        // Convert string to bigint if needed\n        const bigintValue = typeof value === 'string' ? BigInt(value) : value;\n\n        // Use ethers to format the units\n        const formatted = ethers.formatUnits(bigintValue, decimals);\n\n        // Apply precision if specified\n        if (precision !== undefined) {\n          const num = parseFloat(formatted);\n          const factor = Math.pow(10, precision);\n          const truncated = Math.floor(num * factor) / factor;\n          return truncated.toString();\n        }\n\n        return formatted;\n      } catch (error) {\n        throw new Error(\n          `Failed to format units: ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    },\n  };\n\n  static conversion = {\n    /**\n     * Calculates the minimum amount out after applying slippage.\n     *\n     * Given an input amount and slippage in basis points, returns the minimum amount\n     * that should be received after accounting for slippage.\n     *\n     * @param {string} amount - The input amount in smallest units (e.g., \"100000000\" for 100 USDC with 6 decimals)\n     * @param {object} options - Configuration options\n     * @param {number} options.slippageBps - Slippage in basis points (100 = 1%, 50 = 0.5%)\n     * @returns {string} The minimum amount out in smallest units\n     *\n     * @example\n     * // Calculate minimum amount for 100 USDC with 1% slippage\n     * const amount = PushChain.utils.helpers.parseUnits(\"100\", 6); // \"100000000\"\n     * const minOut = PushChain.utils.conversion.slippageToMinAmount(amount, {\n     *   slippageBps: 100, // 1%\n     * });\n     * // => \"99000000\" (99 USDC in smallest units)\n     *\n     * @example\n     * // Simple case with whole numbers\n     * const minOut = PushChain.utils.conversion.slippageToMinAmount(\"100\", {\n     *   slippageBps: 100, // 1%\n     * });\n     * // => \"99\"\n     */\n    slippageToMinAmount(\n      amount: string,\n      options: {\n        slippageBps: number; // 100 = 1%\n      }\n    ): string {\n      // Validate inputs\n      if (typeof amount !== 'string') {\n        throw new Error('Amount must be a string');\n      }\n\n      if (typeof options.slippageBps !== 'number') {\n        throw new Error('slippageBps must be a number');\n      }\n\n      if (!Number.isInteger(options.slippageBps)) {\n        throw new Error('slippageBps must be an integer');\n      }\n\n      if (options.slippageBps < 0) {\n        throw new Error('slippageBps must be non-negative');\n      }\n\n      if (options.slippageBps > 10000) {\n        throw new Error('slippageBps cannot exceed 10000 (100%)');\n      }\n\n      // Handle empty string\n      if (amount.trim() === '') {\n        throw new Error('Amount cannot be empty');\n      }\n\n      try {\n        // Convert amount to BigInt for precise calculation\n        const amountBigInt = BigInt(amount);\n\n        // Calculate slippage factor: (10000 - slippageBps) / 10000\n        // For 1% slippage (100 bps): (10000 - 100) / 10000 = 0.99\n        const slippageFactor = BigInt(10000 - options.slippageBps);\n\n        // Calculate minimum amount: amount * slippageFactor / 10000\n        const minAmountBigInt = (amountBigInt * slippageFactor) / BigInt(10000);\n\n        return minAmountBigInt.toString();\n      } catch (error) {\n        throw new Error(\n          `Failed to calculate slippage: ${\n            error instanceof Error ? error.message : 'Invalid amount format'\n          }`\n        );\n      }\n    },\n  };\n\n  static tokens = {\n    /**\n     * Returns supported moveable tokens as a flat list with chain info.\n     * - If a specific chain or a PushChain client is passed, returns only that chain's tokens\n     * - Otherwise returns tokens across all chains\n     */\n    getMoveableTokens(chainOrClient?: CHAIN | PushChain): {\n      tokens: Array<{\n        chain: CHAIN;\n        symbol: string;\n        decimals: number;\n        address: string;\n        mechanism: 'approve' | 'permit2' | 'native';\n      }>;\n    } {\n      const chain: CHAIN | undefined =\n        Utils.resolveChainFromInput(chainOrClient);\n\n      if (chain) {\n        const list = MOVEABLE_TOKENS[chain] ?? [];\n        return {\n          tokens: list.map((t) => ({\n            chain,\n            symbol: t.symbol,\n            decimals: t.decimals,\n            address: t.address,\n            mechanism: t.mechanism,\n          })),\n        };\n      }\n\n      const tokens: Array<{\n        chain: CHAIN;\n        symbol: string;\n        decimals: number;\n        address: string;\n        mechanism: 'approve' | 'permit2' | 'native';\n      }> = [];\n\n      for (const [key, list] of Object.entries(MOVEABLE_TOKENS)) {\n        const k = key as CHAIN;\n        for (const t of list ?? []) {\n          tokens.push({\n            chain: k,\n            symbol: t.symbol,\n            decimals: t.decimals,\n            address: t.address,\n            mechanism: t.mechanism,\n          });\n        }\n      }\n\n      return { tokens };\n    },\n\n    /**\n     * Returns supported payable tokens as a flat list with chain info.\n     * - If a specific chain or a PushChain client is passed, returns only that chain's tokens\n     * - Otherwise returns tokens across all chains\n     */\n    getPayableTokens(chainOrClient?: CHAIN | PushChain): {\n      tokens: Array<{\n        chain: CHAIN;\n        symbol: string;\n        decimals: number;\n        address: string;\n        mechanism: 'approve' | 'permit2' | 'native';\n      }>;\n    } {\n      const chain: CHAIN | undefined =\n        Utils.resolveChainFromInput(chainOrClient);\n\n      if (chain) {\n        const list = PAYABLE_TOKENS[chain] ?? [];\n        return {\n          tokens: list.map((t) => ({\n            chain,\n            symbol: t.symbol,\n            decimals: t.decimals,\n            address: t.address,\n            mechanism: t.mechanism,\n          })),\n        };\n      }\n\n      const tokens: Array<{\n        chain: CHAIN;\n        symbol: string;\n        decimals: number;\n        address: string;\n        mechanism: 'approve' | 'permit2' | 'native';\n      }> = [];\n\n      for (const [key, list] of Object.entries(PAYABLE_TOKENS)) {\n        const k = key as CHAIN;\n        for (const t of list ?? []) {\n          tokens.push({\n            chain: k,\n            symbol: t.symbol,\n            decimals: t.decimals,\n            address: t.address,\n            mechanism: t.mechanism,\n          });\n        }\n      }\n\n      return { tokens };\n    },\n\n    /**\n     * Returns the Push Chain synthetic asset address for a given moveable token.\n     *\n     * @param {MoveableToken} token - A token from `pushChainClient.moveable.token.*`\n     * @returns {`0x${string}`} The synthetic asset address on Push Chain\n     * @throws {Error} If the token cannot be resolved to a supported synthetic asset\n     */\n    getPRC20Mapping(token: MoveableToken): `0x${string}` {\n      // Infer origin chain by matching symbol+address against the MOVEABLE_TOKENS registry\n      let originChain: CHAIN | undefined;\n      for (const [key, list] of Object.entries(MOVEABLE_TOKENS)) {\n        const k = key as CHAIN;\n        const found = (list ?? []).some(\n          (t) => t.symbol === token.symbol && t.address === token.address\n        );\n        if (found) {\n          originChain = k;\n          break;\n        }\n      }\n\n      if (!originChain) {\n        throw new Error('Unable to infer origin chain for token');\n      }\n\n      // Select Push network mapping (tests/use-cases use TESTNET_DONUT; identical to TESTNET here)\n      const network = PUSH_NETWORK.TESTNET_DONUT;\n      const map = SYNTHETIC_PUSH_ERC20[network];\n\n      // Map token  synthetic key by origin chain family\n      const isEthFamily =\n        originChain === CHAIN.ETHEREUM_MAINNET ||\n        originChain === CHAIN.ETHEREUM_SEPOLIA;\n      const isArbFamily = originChain === CHAIN.ARBITRUM_SEPOLIA;\n      const isBaseFamily = originChain === CHAIN.BASE_SEPOLIA;\n      const isBnbFamily = originChain === CHAIN.BNB_TESTNET;\n      const isSolFamily = originChain === CHAIN.SOLANA_DEVNET;\n\n      let key:\n        | 'pETH'\n        | 'pETH_ARB'\n        | 'pETH_BASE'\n        | 'pETH_BNB'\n        | 'pSOL'\n        | 'USDT_ETH'\n        | 'USDT_ARB'\n        | 'USDT_SOL'\n        | 'USDT_BNB'\n        | 'USDT_BASE';\n\n      switch (token.symbol) {\n        case 'ETH': {\n          if (isEthFamily) key = 'pETH';\n          else if (isArbFamily) key = 'pETH_ARB';\n          else if (isBaseFamily) key = 'pETH_BASE';\n          else if (isBnbFamily) key = 'pETH_BNB';\n          else\n            throw new Error(\n              'Unsupported ETH origin chain for synthetic mapping'\n            );\n          break;\n        }\n        case 'SOL': {\n          if (!isSolFamily)\n            throw new Error('SOL token provided but origin is not Solana');\n          key = 'pSOL';\n          break;\n        }\n        case 'USDT': {\n          if (isEthFamily) key = 'USDT_ETH';\n          else if (isArbFamily) key = 'USDT_ARB';\n          else if (isBaseFamily) key = 'USDT_BASE';\n          else if (isBnbFamily) key = 'USDT_BNB';\n          else if (isSolFamily) key = 'USDT_SOL';\n          else\n            throw new Error(\n              'Unsupported USDT origin chain for synthetic mapping'\n            );\n          break;\n        }\n        default:\n          throw new Error(`Unsupported token symbol: ${token.symbol}`);\n      }\n\n      return map[key];\n    },\n  };\n\n  /**\n   * Internal: resolves a CHAIN enum from either a CHAIN value or a PushChain client instance.\n   */\n  private static resolveChainFromInput(\n    chainOrClient?: CHAIN | PushChain\n  ): CHAIN | undefined {\n    if (!chainOrClient) return undefined;\n    if (typeof chainOrClient === 'string') return chainOrClient as CHAIN;\n    // PushChain client  get origin chain from signer account\n    try {\n      const originAccount = (chainOrClient as PushChain).universal?.origin as\n        | UniversalAccount\n        | undefined;\n      if (originAccount && originAccount.chain) return originAccount.chain;\n    } catch {\n      // ignore\n    }\n    return undefined;\n  }\n}\n",
  "packages/core/src/lib/vm-client/evm-client.spec.ts": "import { EvmClient } from './evm-client';\nimport {\n  createWalletClient,\n  http,\n  Hex,\n  parseAbi,\n  encodeFunctionData,\n} from 'viem';\nimport { generatePrivateKey, privateKeyToAccount } from 'viem/accounts';\nimport { UniversalSigner } from '../universal/universal.types';\nimport { CHAIN } from '../constants/enums';\nimport { CHAIN_INFO } from '../constants/chain';\nimport { sepolia } from 'viem/chains';\nimport { PushChain } from '../push-chain/push-chain';\n\nconst ABI = parseAbi([\n  'function greet() view returns (string)',\n  'function setGreeting(string _greeting)',\n]);\n\nconst CONTRACT = '0x2ba5873eF818BEE57645B7d674149041C44F42c6';\nconst RPC_URL = sepolia.rpcUrls.default.http[0];\nconst chain = CHAIN.ETHEREUM_SEPOLIA;\n\n// const CONTRACT = '0x87D792696Fa0810eBC5f6947F79ba50CbD267E72';\n// const RPC_URL = 'https://evm.pn1.dev.push.org';\n// const chain = CHAIN.PUSH_LOCALNET;\n\ndescribe('EvmClient', () => {\n  let evmClient: EvmClient;\n  let universalSigner: UniversalSigner;\n\n  beforeAll(() => {\n    evmClient = new EvmClient({ rpcUrls: CHAIN_INFO[chain].defaultRPC });\n  });\n\n  describe('getBalance', () => {\n    it('handles invalid address', async () => {\n      await expect(\n        evmClient.getBalance('0xInvalidAddress' as `0x${string}`)\n      ).rejects.toThrow();\n    });\n\n    it('returns zero balance for new address', async () => {\n      const newAddress = privateKeyToAccount(generatePrivateKey()).address;\n      const balance = await evmClient.getBalance(newAddress);\n      expect(balance).toBe(BigInt(0));\n    });\n  });\n\n  describe('readContract', () => {\n    it('reads contract value', async () => {\n      const result = await evmClient.readContract<string>({\n        abi: ABI,\n        address: CONTRACT,\n        functionName: 'greet',\n      });\n      console.log(`Current Greeting: ${result}`);\n      expect(typeof result).toBe('string');\n    });\n\n    it('throws error for invalid contract address', async () => {\n      await expect(\n        evmClient.readContract({\n          abi: ABI,\n          address: '0xInvalidAddress' as `0x${string}`,\n          functionName: 'greet',\n        })\n      ).rejects.toThrow();\n    });\n\n    it('throws error for non-existent function', async () => {\n      await expect(\n        evmClient.readContract({\n          abi: ABI,\n          address: CONTRACT,\n          functionName: 'nonExistentFunction',\n        })\n      ).rejects.toThrow();\n    });\n\n    it('handles empty args array', async () => {\n      const result = await evmClient.readContract<string>({\n        abi: ABI,\n        address: CONTRACT,\n        functionName: 'greet',\n        args: [],\n      });\n      expect(typeof result).toBe('string');\n    });\n  });\n\n  it.skip('writes contract value', async () => {\n    const PRIVATE_KEY = process.env['EVM_PRIVATE_KEY'] as Hex | undefined;\n    if (PRIVATE_KEY) {\n      const account = privateKeyToAccount(PRIVATE_KEY);\n      const walletClient = createWalletClient({\n        account,\n        transport: http(RPC_URL),\n      });\n      universalSigner = await PushChain.utils.signer.toUniversal(walletClient);\n    } else {\n      throw new Error('No Private key set');\n    }\n\n    const balance = await evmClient.getBalance(\n      universalSigner.account.address as `0x${string}`\n    );\n    if (balance === BigInt(0)) {\n      console.warn('Skipping Test - Account has no balance');\n      return;\n    }\n\n    const newGreeting = `Gm Gm ${Date.now()}`;\n\n    const txHash = await evmClient.writeContract({\n      abi: ABI,\n      address: CONTRACT,\n      functionName: 'setGreeting',\n      args: [newGreeting],\n      signer: universalSigner,\n    });\n    console.log('Tx Hash:', txHash);\n    expect(txHash).toMatch(/^0x/);\n  });\n\n  describe('estimateGas', () => {\n    it('estimates gas for a simple transfer', async () => {\n      const gas = await evmClient.estimateGas({\n        to: privateKeyToAccount(generatePrivateKey()).address,\n        value: BigInt(1e18),\n        data: '0x' as Hex,\n      });\n      console.log(gas);\n      expect(typeof gas).toBe('bigint');\n      expect(gas).toBeGreaterThan(0);\n    });\n    it('estimates gas for a contract call', async () => {\n      const calldata = encodeFunctionData({\n        abi: ABI,\n        functionName: 'setGreeting',\n        args: ['Hello Push!'],\n      });\n\n      // estimate for setGreeting\n      const gas = await evmClient.estimateGas({\n        to: CONTRACT,\n        value: BigInt(0),\n        data: calldata,\n      });\n      console.log(gas);\n      expect(typeof gas).toBe('bigint');\n      expect(gas).toBeGreaterThan(0);\n    });\n\n    it('estimates gas from UEA - contract call', async () => {\n      const gas = await evmClient.estimateGas({\n        from: '0xF5184CE4b1e3eC540401f3987DDDf5ab069d05F6',\n        to: '0x2FE70447492307108Bdc7Ff6BaB33Ff37Dacc479',\n        value: BigInt(0),\n        data: '0x2ba2ed980000000000000000000000000000000000000000000000000000000000000312',\n      });\n      console.log(gas);\n      expect(typeof gas).toBe('bigint');\n      expect(gas).toBeGreaterThan(0);\n    });\n\n    it('estimates gas from UEA - transfer call', async () => {\n      const gas = await evmClient.estimateGas({\n        from: '0xF5184CE4b1e3eC540401f3987DDDf5ab069d05F6',\n        to: '0x35B84d6848D16415177c64D64504663b998A6ab4',\n        value: BigInt(0),\n        data: '0x',\n      });\n      console.log(gas);\n      expect(typeof gas).toBe('bigint');\n      expect(gas).toBeGreaterThan(0);\n    });\n\n    it('throws error for invalid from address', async () => {\n      await expect(\n        evmClient.estimateGas({\n          from: '0xInvalidAddress' as `0x${string}`,\n          to: privateKeyToAccount(generatePrivateKey()).address,\n          value: BigInt(0),\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('getGasPrice', () => {\n    it('gets the current gas price', async () => {\n      const gasPrice = await evmClient.getGasPrice();\n      expect(typeof gasPrice).toBe('bigint');\n      expect(gasPrice).toBeGreaterThan(0);\n    });\n  });\n});\n",
  "packages/core/src/lib/vm-client/evm-client.ts": "import { UniversalSigner } from '../universal/universal.types';\nimport {\n  ClientOptions,\n  ReadContractParams,\n  TxResponse,\n  WriteContractParams,\n} from './vm-client.types';\nimport {\n  bytesToHex,\n  createPublicClient,\n  encodeFunctionData,\n  hexToBytes,\n  http,\n  parseEther,\n  PublicClient,\n  serializeTransaction,\n  Hex,\n  Abi,\n  fallback,\n  TransactionReceipt,\n} from 'viem';\n\n/**\n * EVM client for reading and writing to Ethereum-compatible chains\n *\n * @example\n * // Initialize with an RPC URL\n * const evmClient = new EvmClient({\n *   rpcUrl: 'https://eth-sepolia.g.alchemy.com/v2/your-api-key'\n * });\n */\nexport class EvmClient {\n  public publicClient: PublicClient;\n\n  constructor({ rpcUrls }: ClientOptions) {\n    const transports = rpcUrls.map((rpcUrl) => http(rpcUrl));\n    this.publicClient = createPublicClient({\n      transport: fallback(transports),\n    });\n  }\n\n  /**\n   * Returns the balance (in wei) of an EVM address.\n   *\n   * @param address - The EVM address to check balance for\n   * @returns Balance as a bigint in wei\n   *\n   * @example\n   * // Get balance of an address\n   * const balance = await evmClient.getBalance('0x123...');\n   * console.log(`Balance: ${balance} wei`);\n   *\n   * @example\n   * // Check if an address has zero balance\n   * const newAddress = privateKeyToAccount(generatePrivateKey()).address;\n   * const balance = await evmClient.getBalance(newAddress);\n   * if (balance === BigInt(0)) {\n   *   console.log('Address has no funds');\n   * }\n   */\n  async getBalance(address: `0x${string}`): Promise<bigint> {\n    return this.publicClient.getBalance({ address });\n  }\n\n  /**\n   * Performs a read-only call to a smart contract.\n   *\n   * @param params - Parameters including ABI, contract address, function name, and args\n   * @returns The result of the contract call with the specified type\n   *\n   * @example\n   * // Read a greeting value from a contract\n   * const greeting = await evmClient.readContract<string>({\n   *   abi: parseAbi(['function greet() view returns (string)']),\n   *   address: '0x2ba5873eF818BEE57645B7d674149041C44F42c6',\n   *   functionName: 'greet',\n   * });\n   * console.log(`Current greeting: ${greeting}`);\n   *\n   * @example\n   * // Reading with arguments\n   * const balance = await evmClient.readContract<bigint>({\n   *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n   *   address: '0xTokenAddress',\n   *   functionName: 'balanceOf',\n   *   args: ['0xUserAddress'],\n   * });\n   */\n  async readContract<T = unknown>({\n    abi,\n    address,\n    functionName,\n    args = [],\n  }: ReadContractParams): Promise<T> {\n    return this.publicClient.readContract({\n      abi: abi as Abi,\n      address: address as `0x${string}`,\n      functionName,\n      args,\n    }) as Promise<T>;\n  }\n\n  /**\n   * Returns the ERC-20 token balance of an owner address.\n   *\n   * This is a convenience wrapper around readContract using the minimal\n   * ERC-20 ABI: balanceOf(address) -> uint256.\n   */\n  async getErc20Balance({\n    tokenAddress,\n    ownerAddress,\n  }: {\n    tokenAddress: `0x${string}`;\n    ownerAddress: `0x${string}`;\n  }): Promise<bigint> {\n    const { parseAbi } = await import('viem');\n    const erc20Abi = parseAbi([\n      'function balanceOf(address) view returns (uint256)',\n    ]);\n    return this.readContract<bigint>({\n      abi: erc20Abi as unknown as Abi,\n      address: tokenAddress,\n      functionName: 'balanceOf',\n      args: [ownerAddress],\n    });\n  }\n\n  /**\n   * Writes a transaction to a smart contract using a UniversalSigner.\n   * This function handles contract interaction by encoding function data\n   * and sending the transaction through sendTransaction.\n   *\n   * @param params - Parameters including ABI, contract address, function name, args, value and signer\n   * @returns Transaction hash as a hex string\n   *\n   * @example\n   * // Set a new greeting on a contract\n   * const txHash = await evmClient.writeContract({\n   *   abi: parseAbi(['function setGreeting(string _greeting)']),\n   *   address: '0x2ba5873eF818BEE57645B7d674149041C44F42c6',\n   *   functionName: 'setGreeting',\n   *   args: ['Hello from Push SDK!'],\n   *   signer: universalSigner,\n   * });\n   * console.log(`Transaction sent: ${txHash}`);\n   *\n   * @example\n   * // Sending ether with a contract interaction\n   * const txHash = await evmClient.writeContract({\n   *   abi: parseAbi(['function deposit() payable']),\n   *   address: '0xContractAddress',\n   *   functionName: 'deposit',\n   *   value: parseEther('0.1'), // Send 0.1 ETH\n   *   signer: universalSigner,\n   * });\n   */\n  async writeContract({\n    abi,\n    address,\n    functionName,\n    args = [],\n    value = parseEther('0'),\n    signer,\n  }: WriteContractParams): Promise<Hex> {\n    const data = encodeFunctionData({\n      abi: abi as Abi,\n      functionName,\n      args,\n    });\n\n    return this.sendTransaction({\n      to: address as `0x${string}`,\n      data,\n      value,\n      signer,\n    });\n  }\n\n  /**\n   * Sends a raw EVM transaction using a UniversalSigner.\n   * This handles the full transaction flow:\n   * 1. Gets nonce, estimates gas, and gets current fee data\n   * 2. Serializes and signs the transaction\n   * 3. Broadcasts the signed transaction to the network\n   *\n   * @param params - Transaction parameters including destination, data, value and signer\n   * @returns Transaction hash as a hex string\n   *\n   * @example\n   * // Send a simple ETH transfer\n   * const txHash = await evmClient.sendTransaction({\n   *   to: '0xRecipientAddress',\n   *   data: '0x', // empty data for a simple transfer\n   *   value: parseEther('0.01'),\n   *   signer: universalSigner,\n   * });\n   * console.log(`ETH transfer sent: ${txHash}`);\n   */\n  async sendTransaction({\n    to,\n    data,\n    value = parseEther('0'),\n    signer,\n  }: {\n    to: `0x${string}`;\n    data: Hex;\n    value?: bigint;\n    signer: UniversalSigner;\n  }): Promise<Hex> {\n    const [nonce, gas, feePerGas] = await Promise.all([\n      this.publicClient.getTransactionCount({\n        address: signer.account.address as `0x${string}`,\n      }),\n      // Use fixed gas for simple transfers, estimate for contract interactions\n      data === '0x'\n        ? Promise.resolve(BigInt(21000))\n        : this.publicClient.estimateGas({\n            account: signer.account.address as `0x${string}`,\n            to,\n            data,\n            value,\n          }),\n      this.publicClient.estimateFeesPerGas(),\n    ]);\n\n    const chainId = await this.publicClient.getChainId();\n\n    const unsignedTx = serializeTransaction({\n      chainId,\n      type: 'eip1559',\n      to,\n      data,\n      gas,\n      nonce,\n      maxFeePerGas: feePerGas.maxFeePerGas,\n      maxPriorityFeePerGas: feePerGas.maxPriorityFeePerGas,\n      value,\n    });\n\n    if (!signer.signAndSendTransaction) {\n      throw new Error('signer.signAndSendTransaction is undefined');\n    }\n\n    const txHashBytes = await signer.signAndSendTransaction(\n      hexToBytes(unsignedTx)\n    );\n\n    return bytesToHex(txHashBytes);\n  }\n\n  /**\n   * Estimates the gas required for a transaction.\n   *\n   * @param params - Parameters including from/to addresses, value and optional data\n   * @returns Estimated gas as a bigint\n   *\n   * @example\n   * // Estimate gas for a simple transfer\n   * const gasEstimate = await evmClient.estimateGas({\n   *   from: '0xSenderAddress',\n   *   to: '0xRecipientAddress',\n   *   value: parseEther('0.01'),\n   * });\n   * console.log(`Estimated gas: ${gasEstimate}`);\n   *\n   * @example\n   * // Estimate gas for a contract interaction\n   * const data = encodeFunctionData({\n   *   abi: parseAbi(['function setGreeting(string)']),\n   *   functionName: 'setGreeting',\n   *   args: ['New greeting'],\n   * });\n   *\n   * const gasEstimate = await evmClient.estimateGas({\n   *   from: universalSigner.account.address as `0x${string}`,\n   *   to: '0xContractAddress',\n   *   data,\n   *   value: BigInt(0),\n   * });\n   */\n  async estimateGas({\n    from,\n    to,\n    value,\n    data,\n  }: {\n    from?: `0x${string}`;\n    to: `0x${string}`;\n    value?: bigint;\n    data?: `0x${string}`;\n  }): Promise<bigint> {\n    return this.publicClient.estimateGas({\n      account: from || undefined,\n      to,\n      value,\n      data,\n    });\n  }\n\n  /**\n   * Gets the current gas price on the network.\n   * This is primarily used for legacy transactions, but can be useful\n   * for gas cost estimation in EIP-1559 transactions as well.\n   *\n   * @returns Current gas price in wei as a bigint\n   *\n   * @example\n   * // Get current gas price for cost estimation\n   * const gasPrice = await evmClient.getGasPrice();\n   * console.log(`Current gas price: ${gasPrice} wei`);\n   *\n   * @example\n   * // Calculate total cost of a transaction\n   * const gasPrice = await evmClient.getGasPrice();\n   * const gasEstimate = await evmClient.estimateGas({...});\n   * const totalCost = gasPrice * gasEstimate;\n   * console.log(`Estimated transaction cost: ${totalCost} wei`);\n   */\n  async getGasPrice(): Promise<bigint> {\n    return this.publicClient.getGasPrice();\n  }\n\n  /**\n   * Fetches the full transaction response by hash.\n   *\n   * @param txHash - The transaction hash to query\n   * @returns The transaction object or null if not found\n   *\n   * @example\n   * const tx = await evmClient.getTransaction('0xabc...');\n   * console.log(tx?.from, tx?.to, tx?.value);\n   */\n  async getTransaction(txHash: `0x${string}`): Promise<TxResponse> {\n    const tx = await this.publicClient.getTransaction({ hash: txHash });\n    if (!tx) throw new Error('No transaction found!');\n\n    const wait = async (confirmations = 1): Promise<TransactionReceipt> => {\n      const receipt = await this.publicClient.waitForTransactionReceipt({\n        hash: txHash,\n        confirmations,\n      });\n      return receipt;\n    };\n\n    return {\n      ...tx,\n      wait,\n    };\n  }\n\n  /**\n   * Waits for a transaction to achieve the desired number of confirmations.\n   *\n   * @param txHash         - Transaction hash\n   * @param confirmations  - Number of confirmations to wait for (default: 3)\n   * @param pollIntervalMs - How often to check (default: 1000 ms)\n   * @param timeoutMs      - Maximum time to wait before error (default: 60000 ms)\n   */\n  async waitForConfirmations({\n    txHash,\n    confirmations = 3,\n    pollIntervalMs = 1000,\n    timeoutMs = 30000,\n  }: {\n    txHash: `0x${string}`;\n    confirmations?: number;\n    pollIntervalMs?: number;\n    timeoutMs?: number;\n  }): Promise<void> {\n    // first, wait for the tx to land in a block\n    const receipt = await this.publicClient.waitForTransactionReceipt({\n      hash: txHash,\n    });\n\n    const targetBlock = receipt.blockNumber + BigInt(confirmations);\n    const startTime = Date.now();\n\n    // poll until we hit the target block or timeout\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const currentBlock = await this.publicClient.getBlockNumber();\n      if (currentBlock >= targetBlock) {\n        return;\n      }\n\n      if (Date.now() - startTime > timeoutMs) {\n        throw new Error(\n          `Timeout: transaction ${txHash} not confirmed with ${confirmations} confirmations ` +\n            `within ${timeoutMs} ms`\n        );\n      }\n\n      await new Promise((r) => setTimeout(r, pollIntervalMs));\n    }\n  }\n}\n",
  "packages/core/src/lib/vm-client/svm-client.spec.ts": "import { SvmClient } from './svm-client';\nimport { Keypair, PublicKey, SystemProgram } from '@solana/web3.js';\nimport { UniversalSigner } from '../universal/universal.types';\nimport { CHAIN, LIBRARY } from '../constants/enums';\nimport * as dotenv from 'dotenv';\nimport { PushChain } from '../push-chain/push-chain';\n\n// Load environment variables\ndotenv.config();\n\n// Add type declaration for bn.js\ndeclare module 'bn.js';\n\nconst PROGRAM_ID = 'ETGtqwDKEm1Z9gq6FdvYUfyDuUZr7g4UdPSmyNLVGriX';\nconst chain = CHAIN.SOLANA_DEVNET;\nconst RPC_URL = process.env['SOLANA_RPC_URL'];\n\nif (!RPC_URL) {\n  throw new Error('SOLANA_RPC_URL environment variable is not set');\n}\n\n// Solana IDL for the counter program deployed on devnet\nconst IDL = {\n  address: PROGRAM_ID,\n  metadata: {\n    name: 'counter_program',\n    version: '0.1.0',\n    spec: '0.1.0',\n    description: 'Created with Anchor',\n  },\n  instructions: [\n    {\n      name: 'increment',\n      docs: ['Increment the counter by 1'],\n      discriminator: [11, 18, 104, 9, 104, 174, 59, 33],\n      accounts: [\n        {\n          name: 'counter',\n          writable: true,\n        },\n      ],\n      args: [],\n    },\n    {\n      name: 'initialize',\n      docs: [\n        'Create the counter account (with 8 byte discriminator + 8 byte u64)',\n      ],\n      discriminator: [175, 175, 109, 31, 13, 152, 155, 237],\n      accounts: [\n        {\n          name: 'counter',\n          writable: true,\n          signer: true,\n        },\n        {\n          name: 'user',\n          writable: true,\n          signer: true,\n        },\n        {\n          name: 'system_program',\n          address: '11111111111111111111111111111111',\n        },\n      ],\n      args: [],\n    },\n  ],\n  accounts: [\n    {\n      name: 'Counter',\n      discriminator: [255, 176, 4, 245, 188, 253, 124, 25],\n    },\n  ],\n  types: [\n    {\n      name: 'Counter',\n      docs: ['The onchain data structure'],\n      type: {\n        kind: 'struct',\n        fields: [\n          {\n            name: 'value',\n            type: 'u64',\n          },\n        ],\n      },\n    },\n  ],\n};\n\ndescribe('SvmClient', () => {\n  let svmClient: SvmClient;\n  let universalSigner: UniversalSigner;\n  let testAccount: Keypair;\n\n  beforeAll(async () => {\n    svmClient = new SvmClient({ rpcUrls: [RPC_URL] });\n\n    const privateKeyHex = process.env['SOLANA_PRIVATE_KEY'];\n    if (!privateKeyHex) {\n      throw new Error('SOLANA_PRIVATE_KEY environment variable is not set');\n    }\n    const privateKey = Uint8Array.from(Buffer.from(privateKeyHex, 'hex'));\n\n    // Generate a keypair from the private key in .env\n    testAccount = Keypair.fromSecretKey(privateKey);\n\n    // Create the object first with any required properties\n    universalSigner = await PushChain.utils.signer.toUniversalFromKeypair(\n      testAccount,\n      { chain: chain, library: LIBRARY.SOLANA_WEB3JS }\n    );\n  });\n\n  describe('getBalance', () => {\n    it('gets balance', async () => {\n      const balance = await svmClient.getBalance(\n        universalSigner.account.address\n      );\n      expect(typeof balance).toBe('bigint');\n    });\n\n    it('returns non-zero balance for address that has SOL', async () => {\n      const solanaAddressThatHasSOLOnDevnet =\n        '8e7ekBeWmMdU6sJqnCwhm3P2bHBpNwZZ6RNiWJyrMyYz';\n      const balance = await svmClient.getBalance(\n        solanaAddressThatHasSOLOnDevnet\n      );\n      expect(balance).toBeGreaterThan(BigInt(0));\n    });\n\n    it('handles invalid address', async () => {\n      await expect(svmClient.getBalance('invalidAddress')).rejects.toThrow();\n    });\n\n    it('returns zero balance for new address', async () => {\n      const newKeypair = Keypair.generate();\n      const balance = await svmClient.getBalance(\n        newKeypair.publicKey.toBase58()\n      );\n      expect(balance).toBe(BigInt(0));\n    });\n  });\n\n  describe('readContract', () => {\n    it('reads contract value', async () => {\n      // Assuming a deployed program and account\n      const result = await svmClient.readContract({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'counter',\n        args: ['G3MUQYPgvn28KcaXKDTwHsTx89eA1fz4K1g8MjLiym1Q'],\n      });\n      expect(result).toBeDefined();\n    });\n\n    it('throws error for invalid program address', async () => {\n      await expect(\n        svmClient.readContract({\n          abi: IDL,\n          address: 'invalidAddress',\n          functionName: 'counter',\n        })\n      ).rejects.toThrow();\n    });\n\n    it('throws error for non-existent account type', async () => {\n      await expect(\n        svmClient.readContract({\n          abi: IDL,\n          address: PROGRAM_ID,\n          functionName: 'NonExistentAccount',\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('writeContract', () => {\n    it('writes contract value', async () => {\n      const balance = await svmClient.getBalance(\n        universalSigner.account.address\n      );\n      if (balance === BigInt(0)) {\n        console.warn('Skipping Test - Account has insufficient balance');\n        throw new Error('Not enough balance');\n      }\n\n      // Create a new keypair for the counter account\n      const counterAccount = Keypair.generate();\n\n      const txSignature = await svmClient.writeContract({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'initialize',\n        signer: universalSigner,\n        // Pass dynamic accounts\n        accounts: {\n          counter: counterAccount.publicKey,\n          user: new PublicKey(universalSigner.account.address),\n          systemProgram: SystemProgram.programId,\n        },\n        // Pass keypairs that need to sign\n        extraSigners: [counterAccount],\n      });\n      console.log('Transaction Signature: ', txSignature);\n\n      // Wait for the transaction to be confirmed\n      await svmClient.confirmTransaction(txSignature);\n      console.log('Transaction confirmed');\n\n      expect(txSignature).toMatch(/^[A-Za-z0-9]+$/);\n    });\n\n    it('increments counter and verifies value increased', async () => {\n      const balance = await svmClient.getBalance(\n        universalSigner.account.address\n      );\n      if (balance === BigInt(0)) {\n        console.warn('Skipping Test - Account has insufficient balance');\n        throw new Error('Not enough balance');\n      }\n\n      // Create a new keypair for the counter account\n      const counterAccount = Keypair.generate();\n\n      // 1. Initialize the counter first\n      const initTxSignature = await svmClient.writeContract({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'initialize',\n        signer: universalSigner,\n        accounts: {\n          counter: counterAccount.publicKey,\n          user: new PublicKey(universalSigner.account.address),\n          systemProgram: SystemProgram.programId,\n        },\n        extraSigners: [counterAccount],\n      });\n\n      console.log('Initialize Transaction:', initTxSignature);\n\n      // Wait for the initialization transaction to be confirmed\n      await svmClient.confirmTransaction(initTxSignature);\n      console.log('Initialize transaction confirmed');\n\n      // 2. Read the initial value\n      const initialCounter = await svmClient.readContract<{ value: number }>({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'counter',\n        args: [counterAccount.publicKey.toBase58()],\n      });\n      console.log('Initial value:', initialCounter.value);\n\n      // 3. Call increment\n      const incrementTxSignature = await svmClient.writeContract({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'increment',\n        signer: universalSigner,\n        accounts: {\n          counter: counterAccount.publicKey,\n        },\n        extraSigners: [],\n      });\n\n      console.log('Increment Transaction:', incrementTxSignature);\n\n      // Wait for the increment transaction to be confirmed\n      await svmClient.confirmTransaction(incrementTxSignature);\n      console.log('Increment transaction confirmed');\n\n      // 4. Read the value again and verify it increased\n      const updatedCounter = await svmClient.readContract<{ value: bigint }>({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'counter',\n        args: [counterAccount.publicKey.toBase58()],\n      });\n\n      expect(updatedCounter.value.toString()).toBe('1');\n      console.log('Updated value:', updatedCounter.value);\n    });\n\n    it('throws error for invalid program address', async () => {\n      await expect(\n        svmClient.writeContract({\n          abi: IDL,\n          address: 'invalidAddress',\n          functionName: 'initialize',\n          args: [],\n          signer: universalSigner,\n        })\n      ).rejects.toThrow();\n    });\n\n    it('throws error for missing signer.signTransaction', async () => {\n      const invalidSigner = {\n        ...universalSigner,\n        signAndSendTransaction: undefined,\n      };\n      await expect(\n        svmClient.writeContract({\n          abi: IDL,\n          address: PROGRAM_ID,\n          functionName: 'initialize',\n          args: [],\n          signer: invalidSigner as unknown as UniversalSigner,\n        })\n      ).rejects.toThrow('signer.signTransaction is undefined');\n    });\n\n    it('throws error for invalid account configuration', async () => {\n      const counterAccount = Keypair.generate();\n      await expect(\n        svmClient.writeContract({\n          abi: IDL,\n          address: PROGRAM_ID,\n          functionName: 'initialize',\n          signer: universalSigner,\n          accounts: {\n            // Missing required 'user' account\n            counter: counterAccount.publicKey,\n            systemProgram: SystemProgram.programId,\n          },\n          extraSigners: [counterAccount],\n        })\n      ).rejects.toThrow();\n    });\n\n    it('throws error for invalid signer configuration', async () => {\n      const counterAccount = Keypair.generate();\n      await expect(\n        svmClient.writeContract({\n          abi: IDL,\n          address: PROGRAM_ID,\n          functionName: 'initialize',\n          signer: universalSigner,\n          accounts: {\n            counter: counterAccount.publicKey,\n            user: new PublicKey(universalSigner.account.address),\n            systemProgram: SystemProgram.programId,\n          },\n          // Missing required counter account signer\n          extraSigners: [],\n        })\n      ).rejects.toThrow();\n    });\n\n    it('handles multiple instructions in sequence', async () => {\n      const balance = await svmClient.getBalance(\n        universalSigner.account.address\n      );\n      if (balance === BigInt(0)) {\n        console.warn('Skipping Test - Account has insufficient balance');\n        throw new Error('Not enough balance');\n      }\n\n      const counterAccount = Keypair.generate();\n\n      // Initialize counter\n      const initTxSignature = await svmClient.writeContract({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'initialize',\n        signer: universalSigner,\n        accounts: {\n          counter: counterAccount.publicKey,\n          user: new PublicKey(universalSigner.account.address),\n          systemProgram: SystemProgram.programId,\n        },\n        extraSigners: [counterAccount],\n      });\n      await svmClient.confirmTransaction(initTxSignature);\n\n      // Increment counter twice\n      for (let i = 0; i < 2; i++) {\n        const incrementTxSignature = await svmClient.writeContract({\n          abi: IDL,\n          address: PROGRAM_ID,\n          functionName: 'increment',\n          signer: universalSigner,\n          accounts: {\n            counter: counterAccount.publicKey,\n          },\n          extraSigners: [],\n        });\n        await svmClient.confirmTransaction(incrementTxSignature);\n      }\n\n      // Verify final value\n      const finalCounter = await svmClient.readContract<{ value: bigint }>({\n        abi: IDL,\n        address: PROGRAM_ID,\n        functionName: 'counter',\n        args: [counterAccount.publicKey.toBase58()],\n      });\n\n      expect(finalCounter.value.toString()).toBe('2');\n    });\n  });\n\n  describe('estimateGas', () => {\n    it('estimates fee for a simple transfer', async () => {\n      const instruction = SystemProgram.transfer({\n        fromPubkey: new PublicKey(universalSigner.account.address),\n        toPubkey: new PublicKey(universalSigner.account.address),\n        lamports: 1,\n      });\n      const gas = await svmClient.estimateGas({\n        instructions: [instruction],\n        signer: universalSigner,\n      });\n      expect(typeof gas).toBe('bigint');\n      expect(gas).toBeGreaterThan(BigInt(0));\n    });\n\n    it('handles empty instructions array', async () => {\n      const gas = await svmClient.estimateGas({\n        instructions: [],\n        signer: universalSigner,\n      });\n      expect(typeof gas).toBe('bigint');\n      // even with no instructions, fee is non-negative\n      expect(gas).toBeGreaterThanOrEqual(BigInt(0));\n    });\n  });\n});\n",
  "packages/core/src/lib/vm-client/svm-client.ts": "import {\n  Connection,\n  Keypair,\n  PublicKey,\n  Transaction,\n  TransactionInstruction,\n  VersionedTransaction,\n} from '@solana/web3.js';\nimport {\n  ClientOptions,\n  ReadContractParams,\n  WriteContractParams,\n} from './vm-client.types';\nimport { AnchorProvider, Program, BN } from '@coral-xyz/anchor';\nimport { UniversalSigner } from '../universal/universal.types';\nimport type { Wallet } from '@coral-xyz/anchor';\nimport { utils } from '@coral-xyz/anchor';\n/**\n * Solana-compatible VM client for reading and writing SVM-based chains.\n */\nexport class SvmClient {\n  private readonly connections: Connection[];\n  private currentConnectionIndex = 0;\n\n  constructor({ rpcUrls }: ClientOptions) {\n    if (!rpcUrls || rpcUrls.length === 0) {\n      throw new Error('At least one RPC URL must be provided');\n    }\n\n    this.connections = rpcUrls.map((url) => new Connection(url, 'confirmed'));\n  }\n\n  /**\n   * Executes a function with automatic fallback to next RPC endpoint on failure\n   */\n  private async executeWithFallback<T>(\n    operation: (connection: Connection) => Promise<T>,\n    operationName = 'operation'\n  ): Promise<T> {\n    let lastError: Error | null = null;\n\n    // Try each connection starting from current index\n    for (let attempt = 0; attempt < this.connections.length; attempt++) {\n      const connectionIndex =\n        (this.currentConnectionIndex + attempt) % this.connections.length;\n      const connection = this.connections[connectionIndex];\n\n      try {\n        const result = await operation(connection);\n        // Success - update current connection index if we switched\n        if (connectionIndex !== this.currentConnectionIndex) {\n          //console.log(`Switched to RPC endpoint ${connectionIndex + 1}: ${this.rpcUrls[connectionIndex]}`);\n          this.currentConnectionIndex = connectionIndex;\n        }\n        return result;\n      } catch (error) {\n        lastError = error as Error;\n        //console.warn(`RPC endpoint ${connectionIndex + 1} failed for ${operationName}:`, error);\n\n        // If this was our last attempt, throw the error\n        if (attempt === this.connections.length - 1) {\n          break;\n        }\n\n        // Wait a bit before trying next endpoint\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n    }\n\n    throw new Error(\n      `All RPC endpoints failed for ${operationName}. Last error: ${lastError?.message}`\n    );\n  }\n\n  /** Build an AnchorProvider; if a signer is passed we wrap it, otherwise we give a no-op wallet. */\n  private createProvider(\n    connection: Connection,\n    signer?: UniversalSigner\n  ): AnchorProvider {\n    let wallet: Wallet;\n\n    if (signer) {\n      const feePayerPk = new PublicKey(signer.account.address);\n      wallet = {\n        publicKey: feePayerPk,\n        payer: signer.account as any,\n        signTransaction: async <T extends Transaction | VersionedTransaction>(\n          tx: T\n        ): Promise<T> => tx,\n        signAllTransactions: async <\n          T extends Transaction | VersionedTransaction\n        >(\n          txs: T[]\n        ): Promise<T[]> => txs,\n      };\n    } else {\n      // dummy keypair + no-op sign\n      const kp = Keypair.generate();\n      wallet = {\n        publicKey: kp.publicKey,\n        payer: kp,\n        signTransaction: async <T extends Transaction | VersionedTransaction>(\n          tx: T\n        ): Promise<T> => tx,\n        signAllTransactions: async <\n          T extends Transaction | VersionedTransaction\n        >(\n          txs: T[]\n        ): Promise<T[]> => txs,\n      };\n    }\n\n    return new AnchorProvider(connection, wallet, {\n      preflightCommitment: 'confirmed',\n    });\n  }\n\n  /**\n   * Returns the balance (in lamports) of a Solana address.\n   */\n  async getBalance(address: string): Promise<bigint> {\n    const pubkey = new PublicKey(address);\n    const lamports = await this.executeWithFallback(\n      (connection) => connection.getBalance(pubkey),\n      'getBalance'\n    );\n    return BigInt(lamports);\n  }\n  /**\n   * Reads a full program account using Anchor IDL.\n   * `functionName` must match the account layout name in the IDL.\n   */\n  async readContract<T = unknown>({\n    abi,\n    functionName,\n    args = [],\n  }: ReadContractParams): Promise<T> {\n    return this.executeWithFallback(async (connection) => {\n      const provider = this.createProvider(connection);\n      // Anchor v0.31 constructor no longer takes programId\n      // Use the IDL's embedded metadata.address instead\n      const program = new Program<typeof abi>(abi, provider);\n\n      const pubkey = new PublicKey(args[0]);\n      // Cast account namespace to any to allow dynamic string\n      const accountNamespace = program.account as any;\n      const account = await accountNamespace[functionName].fetch(pubkey);\n      return account as T;\n    }, 'readContract');\n  }\n\n  /**\n   * Sends a Solana transaction using a smart contract instruction.\n   */\n  async writeContract({\n    abi,\n    signer,\n    functionName,\n    args = [],\n    accounts = {},\n    extraSigners = [],\n  }: WriteContractParams): Promise<string> {\n    // 1. Grab or build your RPC connection however your class manages it\n    const connection = this.connections[this.currentConnectionIndex];\n\n    // 2. Create an AnchorProvider\n    const provider = this.createProvider(connection);\n\n    // 3. Instantiate the program (Anchor v0.31 will infer programId from IDL.metadata.address)\n    const program = new Program<typeof abi>(abi, provider);\n\n    // 4. Deep-convert arguments into Anchor-friendly types\n    //    - BigInt -> BN\n    //    - hex strings (0x...) -> Buffer\n    //    - Uint8Array -> Buffer\n    //    - UniversalPayload object normalization (to/data/vType)\n    const anchorify = (value: unknown): any => {\n      // Preserve BN, Buffer, PublicKey, null/undefined\n      if (\n        value === null ||\n        value === undefined ||\n        value instanceof BN ||\n        Buffer.isBuffer(value) ||\n        value instanceof PublicKey\n      )\n        return value;\n\n      // BigInt -> BN\n      if (typeof value === 'bigint') return new BN(value.toString());\n\n      // Hex string -> Buffer\n      if (typeof value === 'string' && value.startsWith('0x')) {\n        const hex = value.slice(2);\n        if (hex.length === 0) return Buffer.alloc(0);\n        // If odd length, left-pad a 0\n        const normalized = hex.length % 2 === 1 ? `0${hex}` : hex;\n        return Buffer.from(normalized, 'hex');\n      }\n\n      // Uint8Array -> Buffer\n      if (value instanceof Uint8Array) return Buffer.from(value);\n\n      // Array -> map recursively\n      if (Array.isArray(value)) return value.map((v) => anchorify(v));\n\n      // Plain object -> recurse and normalize UniversalPayload shape\n      if (typeof value === 'object') {\n        const obj = value as Record<string, any>;\n        const out: Record<string, any> = {};\n        for (const [k, v] of Object.entries(obj)) {\n          out[k] = anchorify(v);\n        }\n\n        // Heuristic: normalize UniversalPayload fields expected by Anchor IDL\n        const hasUniversalPayloadKeys =\n          'to' in out &&\n          'value' in out &&\n          'data' in out &&\n          'gasLimit' in out &&\n          'maxFeePerGas' in out &&\n          'maxPriorityFeePerGas' in out &&\n          'nonce' in out &&\n          'deadline' in out &&\n          'vType' in out;\n\n        if (hasUniversalPayloadKeys) {\n          // to: address(20 bytes) -> Buffer(20)\n          if (typeof obj['to'] === 'string' && obj['to'].startsWith('0x')) {\n            const hex = obj['to'].slice(2).padStart(40, '0');\n            out['to'] = Buffer.from(hex, 'hex');\n          }\n          // data: bytes -> Buffer\n          if (typeof obj['data'] === 'string' && obj['data'].startsWith('0x')) {\n            const hex = obj['data'].slice(2);\n            out['data'] = hex.length\n              ? Buffer.from(hex, 'hex')\n              : Buffer.alloc(0);\n          }\n          // numeric fields (often provided as decimal strings from protobuf/JSON) -> BN\n          const numericStringToBn = (val: unknown): BN | unknown => {\n            if (typeof val === 'bigint') return new BN(val.toString());\n            if (typeof val === 'string' && /^[0-9]+$/.test(val))\n              return new BN(val);\n            return val;\n          };\n          out['value'] = numericStringToBn(out['value']);\n          out['gasLimit'] = numericStringToBn(out['gasLimit']);\n          out['maxFeePerGas'] = numericStringToBn(out['maxFeePerGas']);\n          out['maxPriorityFeePerGas'] = numericStringToBn(\n            out['maxPriorityFeePerGas']\n          );\n          out['nonce'] = numericStringToBn(out['nonce']);\n          out['deadline'] = numericStringToBn(out['deadline']);\n          // vType: enum -> Anchor enum object\n          if (typeof obj['vType'] === 'number') {\n            out['vType'] =\n              obj['vType'] === 0\n                ? { signedVerification: {} }\n                : { universalTxVerification: {} };\n          } else if (typeof obj['vType'] === 'string') {\n            const vt = obj['vType'].toLowerCase();\n            if (vt.includes('signed'))\n              out['vType'] = { signedVerification: {} };\n            else out['vType'] = { universalTxVerification: {} };\n          }\n        }\n\n        return out;\n      }\n\n      return value;\n    };\n\n    const convertedArgs = anchorify(args);\n\n    // 5. Build the method call\n    let builder =\n      Array.isArray(convertedArgs) && convertedArgs.length > 0\n        ? (program.methods[functionName](...convertedArgs) as any)\n        : (program.methods[functionName]() as any);\n\n    if (Object.keys(accounts).length > 0) {\n      builder = builder.accounts(accounts);\n    }\n\n    // 6. Get the actual instruction\n    const instruction = await builder.instruction();\n\n    // 7. Send it and return the tx signature\n    return this.sendTransaction({\n      instruction,\n      signer,\n      extraSigners,\n    });\n  }\n\n  /**\n   * Sends a set of instructions as a manually-signed Solana transaction.\n   */\n  async sendTransaction({\n    instruction,\n    signer,\n    extraSigners = [],\n  }: {\n    instruction: TransactionInstruction;\n    signer: UniversalSigner;\n    extraSigners?: Keypair[];\n  }): Promise<string> {\n    const connection = this.connections[this.currentConnectionIndex];\n    const feePayer = new PublicKey(signer.account.address);\n\n    const { blockhash, lastValidBlockHeight } =\n      await connection.getLatestBlockhash('finalized');\n\n    const tx = new Transaction({\n      feePayer,\n      blockhash,\n      lastValidBlockHeight,\n    }).add(instruction);\n\n    if (extraSigners.length > 0) {\n      tx.partialSign(...extraSigners);\n    }\n\n    const txBytes = tx.serialize({\n      requireAllSignatures: false,\n      verifySignatures: false,\n    });\n\n    if (!signer.signAndSendTransaction) {\n      throw new Error('signer.signTransaction is undefined');\n    }\n\n    const txHashBytes = await signer.signAndSendTransaction(\n      new Uint8Array(txBytes)\n    );\n\n    return utils.bytes.bs58.encode(txHashBytes); // Clean, readable tx hash\n  }\n\n  /**\n   * Waits for a transaction to be confirmed on the blockchain.\n   */\n  async confirmTransaction(signature: string, timeout = 30000): Promise<void> {\n    const startTime = Date.now();\n\n    return this.executeWithFallback(async (connection) => {\n      while (Date.now() - startTime < timeout) {\n        const status = await connection.getSignatureStatus(signature);\n        if (status?.value) {\n          if (status.value.err) {\n            throw new Error(\n              `Transaction failed: ${JSON.stringify(status.value.err)}`\n            );\n          }\n          if (\n            status.value.confirmationStatus === 'confirmed' ||\n            status.value.confirmationStatus === 'finalized'\n          ) {\n            return;\n          }\n        }\n        await new Promise((r) => setTimeout(r, 500));\n      }\n      throw new Error(`Transaction confirmation timeout after ${timeout}ms`);\n    }, 'confirmTransaction');\n  }\n\n  /**\n   * Estimates the fee (in lamports) to send a transaction with the given instructions.\n   */\n  async estimateGas({\n    instructions,\n    signer,\n  }: {\n    instructions: TransactionInstruction[];\n    signer: UniversalSigner;\n  }): Promise<bigint> {\n    return this.executeWithFallback(async (connection) => {\n      const feePayer = new PublicKey(signer.account.address);\n      const { blockhash, lastValidBlockHeight } =\n        await connection.getLatestBlockhash();\n      const tx = new Transaction({ blockhash, lastValidBlockHeight, feePayer });\n      if (instructions.length) tx.add(...instructions);\n      const message = tx.compileMessage();\n      const feeResp = await connection.getFeeForMessage(message);\n      if (!feeResp?.value) throw new Error('Failed to estimate fee');\n      return BigInt(feeResp.value);\n    }, 'estimateGas');\n  }\n\n  /**\n   * Sleeps for the given number of milliseconds.\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Waits for a Solana transaction to reach the desired confirmations.\n   *\n   * @param txSignature   - The transaction signature to monitor\n   * @param confirmations - Desired confirmation count (default: 6)\n   * @param timeoutMs     - Max wait time in milliseconds (default: 90_000)\n   * @param pollIntervalMs- How often to poll in milliseconds (default: 500)\n   */\n  async waitForConfirmations({\n    txSignature,\n    confirmations = 3,\n    timeoutMs = 30000,\n    pollIntervalMs = 500,\n  }: {\n    txSignature: string;\n    confirmations?: number;\n    timeoutMs?: number;\n    pollIntervalMs?: number;\n  }): Promise<void> {\n    const connection = this.connections[this.currentConnectionIndex];\n\n    const deadline = Date.now() + timeoutMs;\n    while (Date.now() < deadline) {\n      // fetch status\n      const { value } = await connection.getSignatureStatuses([txSignature]);\n      const status = value[0];\n\n      if (status) {\n        // Transaction is confirmed if either:\n        // 1. It has enough confirmations, OR\n        // 2. It succeeded (err === null) and has a confirmation status\n        //    (handles case where RPC returns null for confirmations on finalized txs)\n        const hasEnoughConfirmations =\n          status.confirmations != null && status.confirmations >= confirmations;\n        const isFinalized =\n          status.err === null &&\n          (status.confirmationStatus === 'finalized' ||\n            status.confirmations === null);\n\n        if (hasEnoughConfirmations || isFinalized) {\n          return;\n        }\n      }\n\n      // wait before retrying\n      await this.sleep(pollIntervalMs);\n    }\n\n    throw new Error(\n      `Timeout: transaction ${txSignature} not confirmed with ` +\n        `${confirmations} confirmations within ${timeoutMs} ms`\n    );\n  }\n}\n",
  "packages/core/src/lib/vm-client/vm-client.types.ts": "import { UniversalSigner } from '../universal/universal.types';\nimport { Abi, Transaction, TransactionReceipt } from 'viem';\nimport { Keypair, PublicKey } from '@solana/web3.js';\n\n/**\n * Common options used by all VM clients (EVM, SVM, etc.)\n */\nexport interface ClientOptions {\n  rpcUrls: string[];\n}\n\n/**\n * Parameters for reading from a smart contract (read-only call).\n */\nexport interface ReadContractParams {\n  /**\n   * EVM contract address\n   * SVM program id\n   */\n  address: string;\n  /**\n   * EVM abi\n   * SVM idl\n   */\n  abi: Abi | any;\n  /**\n   * EVM contract fn name\n   * SVM PDA var name\n   */\n  functionName: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  /**\n   * EVM fn vars\n   * SVM - undefined\n   */\n  args?: any[];\n}\n\n/**\n * Parameters for writing to a smart contract (requires signature).\n */\nexport interface WriteContractParams extends ReadContractParams {\n  value?: bigint; // value in ether\n  signer: UniversalSigner;\n  /**\n   * **For Solana only** Dynamic accounts to pass to the solana program instruction\n   */\n  accounts?: Record<string, PublicKey>;\n  /**\n   * **For Solana only** Keypairs that should sign the transaction\n   */\n  extraSigners?: Keypair[];\n}\n\nexport type TxResponse = Transaction & {\n  wait: (confirmations?: number) => Promise<TransactionReceipt>;\n};\n",
  "packages/ui-kit/jest.config.ts": "/* eslint-disable */\nexport default {\n  displayName: 'ui-kit',\n  preset: '../../jest.preset.js',\n  testEnvironment: 'node',\n  transform: {\n    '^.+\\\\.[tj]s$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.spec.json' }],\n  },\n  moduleFileExtensions: ['ts', 'js', 'html'],\n  coverageDirectory: '../../coverage/packages/ui-kit',\n};\n",
  "packages/ui-kit/src/index.ts": "import './lib/polyfills';\n\nexport * from './lib';\n\n// Test change to trigger GitHub Action 8\n",
  "packages/ui-kit/src/lib/components/LoginModal/index.tsx": "import React, { FC, useEffect, useRef } from 'react';\nimport { ExecuteParams } from '@pushchain/core/src/lib/orchestrator/orchestrator.types';\nimport styled from 'styled-components';\nimport { CrossIcon, Spinner } from '../../components/common';\nimport { APP_TO_WALLET_ACTION, PushUI, WALLET_CONFIG_URL, WALLET_TO_APP_ACTION } from '../../constants';\nimport {\n  ModalAppDetails,\n  ModalProps,\n  ProviderConfigProps,\n  UniversalAccount,\n} from '../../types';\nimport { useSmartModalPosition } from './useSmartModalPosition';\nimport { usePushChainClient } from '../../hooks/usePushChainClient';\n\ntype LoginModalProps = {\n  iframeRef: React.MutableRefObject<HTMLIFrameElement | null>;\n  themeMode?:\n    | typeof PushUI.CONSTANTS.THEME.LIGHT\n    | typeof PushUI.CONSTANTS.THEME.DARK;\n  isWalletVisible: boolean;\n  isIframeLoading: boolean;\n  setIframeLoading: (isIframeLoading: boolean) => void;\n  sendWalletConfig: () => void;\n  modalAppData: ModalAppDetails | undefined;\n  config: ProviderConfigProps;\n  universalAccount: UniversalAccount | null;\n  isWalletMinimised: boolean;\n  setMinimiseWallet: (isWalletMinimised: boolean) => void;\n  handleUserLogOutEvent: () => void;\n  toggleButtonRef: React.RefObject<HTMLButtonElement>;\n  sendMessageToPushWallet: (message: any) => void;\n  isReadOnly: boolean;\n};\n\nconst LoginModal: FC<LoginModalProps> = ({\n  iframeRef,\n  isWalletVisible,\n  isIframeLoading,\n  themeMode = PushUI.CONSTANTS.THEME.DARK,\n  modalAppData,\n  setIframeLoading,\n  sendWalletConfig,\n  universalAccount,\n  isWalletMinimised,\n  setMinimiseWallet,\n  handleUserLogOutEvent,\n  config,\n  toggleButtonRef,\n  sendMessageToPushWallet,\n  isReadOnly\n}) => {\n  const { modal } = config;\n  const { pushChainClient } = usePushChainClient(config?.uid || 'default');\n\n  const { top, left } = useSmartModalPosition(\n    toggleButtonRef,\n    450,\n    675,\n    config.uid\n  );\n\n  const handleSendTransaction = async (data: ExecuteParams) => {\n    if (!pushChainClient) return;\n\n    const res = await pushChainClient.universal.sendTransaction({\n      ...data,\n      value: data.value ? BigInt(data.value) : data.value\n    });\n\n    sendMessageToPushWallet({\n      type: APP_TO_WALLET_ACTION.PUSH_SEND_TRANSACTION_RESPONSE,\n      data: res.hash,\n    });\n  }\n\n  useEffect(() => {\n    const pushMessageHandler = (event: MessageEvent) => {\n      if (iframeRef.current?.contentWindow !== event.source || !pushChainClient) return;\n\n      switch (event.data.type) {\n        case WALLET_TO_APP_ACTION.PUSH_SEND_TRANSACTION:\n          handleSendTransaction(event.data.data);\n          break;\n        default:\n          console.warn('Unknown message type:', event.data.type);\n      }\n    };\n\n    window.addEventListener('message', pushMessageHandler);\n\n    return () => window.removeEventListener('message', pushMessageHandler);\n  }, [pushChainClient]);\n\n  return (\n    <>\n      {!isWalletMinimised &&\n        universalAccount &&\n        config.modal?.connectedLayout ===\n          PushUI.CONSTANTS.CONNECTED.LAYOUT.HOVER &&\n        config.modal?.connectedInteraction ===\n          PushUI.CONSTANTS.CONNECTED.INTERACTION.BLUR && (\n          <BlurBackground\n            onClick={() => setMinimiseWallet(!isWalletMinimised)}\n          />\n        )}\n      {isWalletVisible ? (\n        <FrameContainer\n          $isWalletMinimised={isWalletMinimised}\n          $universalAccount={universalAccount}\n          $accountMenuVariant={modal?.connectedLayout}\n          $modalDefaults={modal}\n          $style={{ top, left }}\n        >\n          {isIframeLoading && !isReadOnly && (\n            <FrameLoadingContainer>\n              <CloseButtonContainer\n                onClick={() => {\n                  handleUserLogOutEvent();\n                }}\n              >\n                <CrossIcon\n                  height=\"20px\"\n                  width=\"20px\"\n                  color={\n                    themeMode === PushUI.CONSTANTS.THEME.LIGHT ? '#000' : '#FFF'\n                  }\n                />\n              </CloseButtonContainer>\n              <LoadingTextContainer>\n                <LoadingText>Loading...</LoadingText>\n                <Spinner color=\"var(--pw-int-brand-primary-color)\" />\n              </LoadingTextContainer>\n            </FrameLoadingContainer>\n          )}\n\n          <FrameSubContainer\n            $isWalletMinimised={isWalletMinimised}\n            $isIframeLoading={isIframeLoading}\n          >\n            {/* <AccountContainer $universalAccount={universalaccount}>\n              {universalAccount ? (\n                <DashButtonContainer onClick={() => setMinimiseWallet(true)}>\n                  <CrossIcon\n                    height=\"20px\"\n                    width=\"20px\"\n                    color=\"var(--pw-int-text-primary-color)\"\n                  />\n                </DashButtonContainer>\n              ) : (\n                <CloseButtonContainer\n                  onClick={() => {\n                    handleUserLogOutEvent();\n                  }}\n                >\n                  <CrossIcon\n                    height=\"20px\"\n                    width=\"20px\"\n                    color=\"var(--pw-int-text-primary-color)\"\n                  />\n                </CloseButtonContainer>\n              )}\n            </AccountContainer> */}\n\n            <SplitContainer>\n              {modal?.appPreview &&\n                modalAppData &&\n                modal?.loginLayout === PushUI.CONSTANTS.LOGIN.LAYOUT.SPLIT && (\n                  <AppPreviewContainer $universalAccount={universalAccount}>\n                    <AppContainer>\n                      {modalAppData?.logoURL && (\n                        <ImageContainer>\n                          <Image\n                            src={modalAppData?.logoURL}\n                            alt={modalAppData.title}\n                          />\n                        </ImageContainer>\n                      )}\n\n                      <TextContainer\n                        $themeMode={\n                          themeMode ? themeMode : PushUI.CONSTANTS.THEME.DARK\n                        }\n                        $textColor={\n                          themeMode === PushUI.CONSTANTS.THEME.LIGHT\n                            ? '#F5F6F8'\n                            : '#17181b'\n                        }\n                      >\n                        <Heading>{modalAppData.title}</Heading>\n                        <Description>{modalAppData?.description}</Description>\n                      </TextContainer>\n                    </AppContainer>\n                  </AppPreviewContainer>\n                )}\n\n              <MainFrameContainer>\n                <iframe\n                  src={`\n                    ${WALLET_CONFIG_URL[config.network]}/auth?app=${window.location.origin}&version=3\n                  `}\n                  allow=\"clipboard-write; clipboard-read; publickey-credentials-create; publickey-credentials-get; display-capture; *\"\n                  ref={iframeRef}\n                  style={{\n                    border: 'none',\n                    width: '100%',\n                    height: universalAccount\n                      ? modal?.connectedLayout ===\n                        PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n                        ? '100vh'\n                        : '675px'\n                      : '100vh',\n                    borderRadius: universalAccount ? '10px' : '0px',\n                  }}\n                  onLoad={() => {\n                    setTimeout(() => {\n                      setIframeLoading(false);\n                      sendWalletConfig();\n                    }, 100);\n                  }}\n                />\n              </MainFrameContainer>\n            </SplitContainer>\n          </FrameSubContainer>\n        </FrameContainer>\n      ) : null}\n    </>\n  );\n};\n\nexport { LoginModal };\n\nconst BlurBackground = styled.div`\n  position: fixed;\n  top: 0px;\n  bottom: 0px;\n  left: 0px;\n  right: 0px;\n  backdrop-filter: blur(8px);\n  z-index: 99;\n`;\n\nconst FrameContainer = styled.div<{\n  $universalAccount: UniversalAccount | null;\n  $isWalletMinimised: boolean;\n  $accountMenuVariant: ModalProps['connectedLayout'];\n  $modalDefaults?: ModalProps;\n  $style?: Record<'top' | 'left', number>;\n}>`\n  position: fixed;\n  top: ${({ $style }) => `${$style?.top}px`};\n  left: ${({ $style }) => `${$style?.left}px`};\n  display: flex;\n  flex-direction: column;\n  background-image: url(${({ $modalDefaults }) => $modalDefaults?.bgImage});\n  background-size: cover;\n  background-color: ${({$universalAccount, $accountMenuVariant}) => \n    $universalAccount && $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.HOVER ?\n    'transparent' :\n    'var(--pw-int-bg-primary-color)'\n  };\n  border-radius: ${({ $universalAccount }) =>\n    $universalAccount ? '10px' : 'unset'};\n  z-index: 999;\n\n  width: ${({ $universalAccount, $isWalletMinimised, $accountMenuVariant }) =>\n    $isWalletMinimised\n      ? '0px'\n      : $universalAccount\n      ? $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n        ? '100%'\n        : '450px'\n      : '100vw'};\n  height: ${({ $universalAccount, $isWalletMinimised, $accountMenuVariant }) =>\n    $isWalletMinimised\n      ? '0px'\n      : $universalAccount\n      ? $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n        ? '100vw'\n        : '675px'\n      : '100vh'};\n  right: ${({ $universalAccount, $accountMenuVariant }) =>\n    $universalAccount\n      ? $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n        ? '0'\n        : '10px'\n      : '0'};\n  top: ${({ $universalAccount, $accountMenuVariant }) =>\n    $universalAccount\n      ? $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n        ? '0'\n        : '70px'\n      : '0'};\n\n  @media (max-width: 425px) {\n    width: ${({ $universalAccount, $isWalletMinimised }) =>\n      $isWalletMinimised ? '0px' : $universalAccount ? '100%' : '100%'};\n    right: ${({ $universalAccount }) => ($universalAccount ? '2%' : '0')};\n    top: ${({ $universalAccount, $accountMenuVariant }) =>\n      $universalAccount\n        ? $accountMenuVariant === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n          ? '0'\n          : '8%'\n        : '0'};\n  }\n`;\n\nconst CloseButtonContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  cursor: pointer;\n  padding: 8px 16px;\n`;\n\nconst LoadingTextContainer = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 16px;\n  width: 100%;\n  height: 100%;\n`;\n\nconst LoadingText = styled.p`\n  font-size: 18px;\n  font-weight: 500;\n  line-height: 27px;\n  color: inherit;\n  font-family: var(--pw-int-font-family);\n  margin: 0px;\n  width: auto;\n`;\n\nconst FrameLoadingContainer = styled.div`\n  height: 100%;\n  width: 100%;\n  flex-direction: column;\n  display: flex;\n  padding: var(--spacing-xxs) var(--spacing-xxs);\n  color: var(--pw-int-text-primary-color);\n  background-color: var(--pw-int-bg-primary-color);\n  box-sizing: border-box;\n`;\n\nconst FrameSubContainer = styled.div<{\n  $isWalletMinimised: boolean;\n  $isIframeLoading: boolean;\n}>`\n  display: ${({ $isWalletMinimised, $isIframeLoading }) =>\n    $isWalletMinimised || $isIframeLoading ? 'none' : 'flex'};\n  width: 100%;\n  height: 100%;\n  flex-direction: column;\n`;\n\nconst AccountContainer = styled.div<{\n  $universalAccount: UniversalAccount | null;\n}>`\n  width: 100%;\n  display: flex;\n  align-items: center;\n  position: absolute;\n  top: 8px;\n  right: 8px;\n  justify-content: flex-end;\n  // padding: var(--spacing-xxs) var(--spacing-xxs);\n  border-top-right-radius: ${({ $universalAccount }) =>\n    $universalAccount ? '10px' : '0px'};\n  border-top-left-radius: ${({ $universalAccount }) =>\n    $universalAccount ? '10px' : '0px'};\n  background-color: transparent;\n`;\n\nconst SplitContainer = styled.div`\n  display: flex;\n`;\n\nconst AppPreviewContainer = styled.div<{\n  $universalAccount: UniversalAccount | null;\n}>`\n  display: ${({ $universalAccount }) => ($universalAccount ? 'none' : 'flex')};\n  align-items: center;\n  justify-content: center;\n  flex: 1;\n  padding: 100px 10px 10px 10px;\n  background-color: transparent;\n\n  @media (max-width: 1024px) {\n    display: none;\n  }\n`;\n\nconst AppContainer = styled.div`\n  width: 300px;\n  padding: 10px;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  gap: 16px;\n  align-self: stretch;\n  height: 700px;\n  justify-content: center;\n`;\n\nconst MainFrameContainer = styled.div`\n  flex: 1;\n`;\nconst ImageContainer = styled.div`\n  width: 64px;\n  height: 64px;\n`;\n\nconst Image = styled.img`\n  width: inherit;\n  height: inherit;\n  border-radius: 16px;\n  border: 1px solid var(--stroke-secondary, #313338);\n`;\nconst TextContainer = styled.div<{\n  $themeMode:\n    | typeof PushUI.CONSTANTS.THEME.LIGHT\n    | typeof PushUI.CONSTANTS.THEME.DARK;\n  $textColor: string;\n}>`\n  font-family: var(--pw-int-font-family);\n  src: url('./assets/fonts/FKGroteskNeue-Regular.woff2') format('woff2'),\n    url('./assets/fonts/FKGroteskNeue-Regular.woff') format('woff');\n  font-style: normal;\n  font-size: 16px;\n  font-weight: 400;\n  line-height: 22px;\n  text-align: left;\n  color: ${({ $themeMode, $textColor }) =>\n    $themeMode === PushUI.CONSTANTS.THEME.LIGHT\n      ? $textColor\n        ? $textColor\n        : '#17181b'\n      : $textColor\n      ? $textColor\n      : '#F5F6F8'};\n`;\n\nconst Heading = styled.h1`\n  font-size: var(--pw-int-text-heading-xsmall-size);\n  font-weight: 500;\n  line-height: 27px;\n  color: var(--pw-int-text-primary-color);\n`;\n\nconst Description = styled.p`\n  font-size: var(--pw-int-text-body-large-size);\n  line-height: 22px;\n  font-weight: 400;\n  color: var(--pw-int-text-secondary-color);\n`;\n",
  "packages/ui-kit/src/lib/components/LoginModal/useSmartModalPosition.ts": "import { useEffect, useState } from 'react';\nimport { usePushWalletContext } from '../../hooks/usePushWallet';\nimport { PushUI } from '../../constants';\n\ntype Position = { top: number; left: number };\n\nexport function useSmartModalPosition(\n  triggerRef: React.RefObject<HTMLElement>,\n  modalWidth = 450,\n  modalHeight = 675,\n  uid?: string,\n): Position {\n  const [position, setPosition] = useState<Position>({ top: 0, left: 0 });\n\n  const { isWalletMinimised, universalAccount, config } = usePushWalletContext(uid);\n\n  useEffect(() => {\n    const calculatePosition = () => {\n      if (!triggerRef.current) return;\n\n      if (config.modal?.connectedLayout === PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL) {\n        setPosition({ top: 0, left: 0 });\n        return;\n      }\n\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n\n      const spaceBelow = viewportHeight - triggerRect.bottom;\n      const spaceAbove = triggerRect.top;\n      const spaceRight = viewportWidth - triggerRect.left;\n      const spaceLeft = triggerRect.right;\n\n      const top =\n        spaceBelow >= modalHeight\n          ? triggerRect.bottom - 16\n          : spaceAbove >= modalHeight\n          ? triggerRect.top - modalHeight + 16\n          : Math.max(viewportHeight - modalHeight, 0);\n\n      const left =\n        spaceRight >= modalWidth\n          ? triggerRect.left - 35\n          : spaceLeft >= modalWidth\n          ? triggerRect.right - modalWidth + 35\n          : Math.max(viewportWidth - modalWidth, 0);\n\n      setPosition({ top, left });\n    };\n\n    if (!isWalletMinimised && universalAccount) {\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n    }\n\n    calculatePosition();\n    window.addEventListener('resize', calculatePosition);\n    return () => {\n      window.removeEventListener('resize', calculatePosition);\n      document.body.style.overflow = '';\n    };\n  }, [triggerRef, modalWidth, modalHeight, isWalletMinimised, config]);\n\n  useEffect(() => {\n    if (!universalAccount) {\n        setPosition({top: 0, left: 0});\n    }\n  }, [universalAccount])\n\n  return position;\n}\n",
  "packages/ui-kit/src/lib/components/PushUniversalAccountButton/ConnectWalletButton.tsx": "import React, { FC } from 'react';\nimport styled from 'styled-components';\nimport { usePushWalletContext } from '../../hooks/usePushWallet';\nimport { Button, Spinner } from '../common';\nimport { PushUI } from '../../constants';\n\nexport type ConnectPushWalletButtonProps = {\n  uid?: string;\n  connectButtonText?: string;\n  loadingComponent?: React.ReactNode;\n};\n\nconst ConnectWalletButton: FC<ConnectPushWalletButtonProps> = ({\n  uid,\n  connectButtonText,\n  loadingComponent,\n}) => {\n  const { connectionStatus, handleConnectToPushWallet } =\n    usePushWalletContext(uid);\n\n  const isConnectButtonDisbaled =\n    connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTED ||\n    connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.AUTHENTICATING ||\n    connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTING;\n\n  const isLoading =\n    connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.CONNECTING ||\n    connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.AUTHENTICATING;\n\n  const capitalize = (word: string): string => {\n    if (!word) return '';\n    return word.charAt(0).toUpperCase() + word.slice(1);\n  }\n\n  const handleConnectWalletButton = () => handleConnectToPushWallet();\n\n  return (\n    <Button\n      bgColor=\"var(--pwauth-btn-connect-bg-color)\"\n      textColor=\"var(--pwauth-btn-connect-text-color)\"\n      borderRadius=\"var(--pwauth-btn-connect-border-radius)\"\n      onClick={handleConnectWalletButton}\n      disabled={isConnectButtonDisbaled || isLoading}\n    >\n      {connectionStatus === PushUI.CONSTANTS.CONNECTION.STATUS.NOT_CONNECTED\n        ? connectButtonText\n        : isLoading\n          ? loadingComponent\n            ? loadingComponent\n            : <>\n                {capitalize(connectionStatus)}\n                <SpinnerContainer>\n                  <Spinner />\n                </SpinnerContainer>\n              </>\n          : capitalize(connectionStatus)}\n    </Button>\n  );\n};\n\nexport { ConnectWalletButton };\n\nconst SpinnerContainer = styled.div`\n  padding: 0px 4px;\n`;\n",
  "packages/ui-kit/src/lib/components/PushUniversalAccountButton/TogglePushWalletButton.tsx": "import React from 'react';\nimport { CHAIN } from '@pushchain/core/src/lib/constants/enums';\nimport { usePushWalletContext } from '../../hooks/usePushWallet';\nimport { UniversalAccount } from '../../types';\nimport { Button, PushLogo, PushMonotone } from '../common';\nimport { centerMaskString, getChainId } from '../../helpers';\nimport { CHAIN_LOGO } from '../../constants';\n\ntype TogglePushWalletButtonProps = {\n  uid?: string;\n  universalAccount: UniversalAccount;\n};\nconst TogglePushWalletButton: React.FC<TogglePushWalletButtonProps> = ({\n  uid,\n  universalAccount,\n}) => {\n  const { setMinimiseWallet, isWalletMinimised, toggleButtonRef } =\n    usePushWalletContext(uid);\n  const { chain, address } = universalAccount;\n\n  function getChainIcon(chain: CHAIN) {\n    const chainId = getChainId(chain);\n    if (!chainId) {\n      return <PushMonotone />;\n    }\n    const IconComponent = CHAIN_LOGO[chainId];\n    if (IconComponent) {\n      return <IconComponent />;\n    } else {\n      return <PushMonotone />;\n    }\n  }\n\n  const maskedAddress = centerMaskString(address);\n\n  return (\n    <>\n      <Button\n        onClick={() => setMinimiseWallet(!isWalletMinimised)}\n        bgColor=\"var(--pwauth-btn-connected-bg-color)\"\n        textColor=\"var(--pwauth-btn-connected-text-color)\"\n        borderRadius=\"var(--pwauth-btn-connect-border-radius)\"\n        gap='8px'\n        padding='12px'\n        ref={toggleButtonRef}\n      >\n        {getChainIcon(chain)}\n        {maskedAddress}\n      </Button>\n    </>\n  );\n};\n\nexport { TogglePushWalletButton };\n",
  "packages/ui-kit/src/lib/components/PushUniversalAccountButton/index.tsx": "/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport React, { FC, useEffect, useMemo } from 'react';\nimport { usePushWalletContext } from '../../hooks/usePushWallet';\nimport { ConnectWalletButton } from './ConnectWalletButton';\nimport { TogglePushWalletButton } from './TogglePushWalletButton';\nimport {\n  createGlobalStyle,\n  DefaultTheme,\n  ThemeProvider,\n} from 'styled-components';\nimport { ButtonThemeOverrides, ThemeOverrides } from '../../styles/token';\nimport { mapButtonCoreToInt } from '../../utils/theme';\nimport { AppMetadata } from '../../types';\n\ntype PushUniversalAccountButtonProps = {\n  uid?: string;\n  connectButtonText?: string;\n  loadingComponent?: React.ReactNode;\n  modalAppOverride?: AppMetadata;\n  loginAppOverride?: AppMetadata;\n  themeOverrides?: ButtonThemeOverrides;\n};\n\ninterface CustomTheme extends DefaultTheme {\n  themeOverrides: ThemeOverrides;\n  themeMode: string;\n}\n\nconst GlobalStyle = createGlobalStyle<{ uid: string }>`\n  [data-pw-wrapper='${(props) => props.uid}']{\n    ${(props) => {\n      const { themeOverrides, themeMode } = props.theme as CustomTheme;\n      const isLightMode = themeMode === 'light';\n      const { dark, light, ...globalOverrides } = themeOverrides;\n      const newTokens = {\n        ...mapButtonCoreToInt(globalOverrides),\n        ...mapButtonCoreToInt((isLightMode ? light : dark) ?? {}),\n      };\n      return Object.entries(newTokens)\n        .map(([key, value]) => `${key}: ${value};`)\n        .join('\\n');\n    }}\n  }\n`;\n\nconst PushUniversalAccountButton: FC<PushUniversalAccountButtonProps> = ({\n  uid = 'default',\n  connectButtonText = 'Connect Account',\n  loadingComponent,\n  modalAppOverride,\n  loginAppOverride,\n  themeOverrides: ButtonThemeOverrides,\n}) => {\n  const {\n    universalAccount,\n    themeOverrides,\n    themeMode,\n    updateModalAppData,\n    updateWalletAppData,\n  } = usePushWalletContext(uid);\n\n  useEffect(() => {\n    if (modalAppOverride) updateModalAppData(modalAppOverride);\n    if (loginAppOverride) updateWalletAppData(loginAppOverride);\n  }, []);\n\n  const Component = () => {\n    if (universalAccount) {\n      // Merge props with buttonDefaults, giving priority to direct props\n      const toggleButtonProps = {\n        uid: uid,\n        universalAccount: universalAccount,\n      };\n\n      return <TogglePushWalletButton {...toggleButtonProps} />;\n    } else {\n      // Merge props with buttonDefaults, giving priority to direct props\n      const connectButtonProps = {\n        uid: uid,\n        connectButtonText,\n        loadingComponent,\n      };\n\n      return <ConnectWalletButton {...connectButtonProps} />;\n    }\n  };\n\n  return (\n    <ThemeProvider\n      theme={{\n        themeMode,\n        themeOverrides: { ...themeOverrides, ...ButtonThemeOverrides },\n      }}\n    >\n      <GlobalStyle uid={uid} />\n      <Component />\n    </ThemeProvider>\n  );\n};\n\nexport { PushUniversalAccountButton };\n",
  "packages/ui-kit/src/lib/components/PushWalletToast/index.tsx": "import React, { FC } from 'react';\nimport { PROGRESS_HOOK, ProgressEvent } from '@pushchain/core/src/lib/progress-hook/progress-hook.types';\nimport styled from 'styled-components';\nimport { CrossIcon, Spinner, TickIcon, WarningIcon } from \"../../components/common\";\n\ntype PushWalletToastProps = {\n    progress: ProgressEvent | null;\n    setProgress: React.Dispatch<React.SetStateAction<ProgressEvent | null>>;\n}\n\nconst PushWalletToast: FC<PushWalletToastProps> = ({ progress, setProgress }) => {\n    const handleViewOnScan = (txnHash: string) => {\n        if (txnHash) {\n            window.open(`https://donut.push.network/tx/${txnHash}`, '_blank');\n        }\n    };\n\n    if (!progress) return <></>\n    return (\n        <ToastContainer>\n            <IconContainer>\n                {\n                    progress.level === 'SUCCESS' ? <TickIcon /> :\n                    progress.level === 'ERROR' ? <WarningIcon /> :\n                    <Spinner color='var(--pw-int-brand-primary-color)' />\n                }\n            </IconContainer>\n            <ContentContainer>\n                <TitleText>{progress.title}</TitleText>\n                {\n                    progress.id === PROGRESS_HOOK.SEND_TX_99_01 &&\n                    progress.response && \n                    (\n                        <LinkText\n                            onClick={() => handleViewOnScan((progress.response as Array<Record<string, any>>)[0]['hash'])}\n                        >\n                            View in Explorer\n                        </LinkText>\n                    )\n                }\n            </ContentContainer>\n            <CloseContainer onClick={() => setProgress(null)}>\n                <CrossIcon height='18px' width='18px' color='#000000' />\n            </CloseContainer>\n        </ToastContainer>\n    );\n};\n\nexport { PushWalletToast };\n\nconst ToastContainer = styled.div`\n    position: fixed;\n    bottom: 40px;\n    right: 30px;\n    display:flex;\n    flex-direction:row;\n    gap:8px;\n    align-items: flex-start;\n    border:1px solid #EAEBF2;\n    padding:16px;\n    border-radius:16px;\n    background-color:#fff;\n    z-index:9999;\n    width:320px;\n    max-width: 100%;\n`\n\nconst ContentContainer = styled.div`\n    display: flex;\n    flex-direction: column;\n`\n\nconst TitleText = styled.h4`\n    font-size:14px;\n    font-weight:500;\n    line-height:21px;\n    margin:0;\n    font-family:var(--pw-int-font-family);\n    color:#17181B;\n`\n\nconst LinkText = styled.span`\n    font-size:14px;\n    font-weight:400;\n    line-height:21px;\n    cursor: pointer;\n    color: #0056D0;\n    font-family:var(--pw-int-font-family);\n`\n\nconst IconContainer = styled.div`\n    height: 21px;\n    width: 18px;\n    display: flex;\n    align-items: center;\n`\n\nconst CloseContainer = styled.div`\n    display: flex;\n    margin-left: auto;\n    align-items: center;\n    cursor: pointer;\n    height: 21px;\n`",
  "packages/ui-kit/src/lib/components/common/Button.tsx": "import React, { HTMLAttributes, ReactNode, forwardRef } from 'react';\nimport styled from 'styled-components';\n\nexport type TransformedHTMLAttributes<T> = Omit<\n  HTMLAttributes<T>,\n  'style' | 'color'\n>;\n\nexport type ButtonProps = {\n  /* Child react nodes rendered by Box */\n  children?: ReactNode;\n  /* Background color of the button */\n  bgColor?: React.CSSProperties['backgroundColor'];\n  /* Text color of the button */\n  textColor?: React.CSSProperties['color'];\n  /* Border Radius of the button */\n  borderRadius?: React.CSSProperties['borderRadius'];\n  /* Spacing between the elements of the button */\n  gap?: React.CSSProperties['gap'];\n  padding?: React.CSSProperties['padding'];\n  /* Sets button as disabled */\n  disabled?: boolean;\n} & TransformedHTMLAttributes<HTMLButtonElement>;\n\nconst StyledButton = styled.button<{\n  $bgColor?: ButtonProps['bgColor'];\n  $textColor?: ButtonProps['textColor'];\n  $borderRadius?: ButtonProps['borderRadius'];\n  $gap?: ButtonProps['gap'];\n  $padding?: ButtonProps['padding'];\n  $disabled?: ButtonProps['disabled'];\n}>`\n  /* Common Button CSS */\n\n  align-items: center;\n  cursor: ${({ $disabled }) => ($disabled ? 'not-allowed' : 'pointer')};\n  background: ${({ $bgColor }) => ($bgColor ? $bgColor : '#d548ec')};\n  color: ${({ $textColor }) =>\n    $textColor ? $textColor : 'rgba(255, 255, 255, 1)'};\n  display: flex;\n  font-family: var(--pw-int-font-family);\n  justify-content: center;\n  white-space: nowrap;\n  flex-shrink: 0;\n  font-size: 16px;\n  font-style: normal;\n  font-weight: 500;\n  line-height: 16px;\n  padding: ${({ $padding }) =>\n    $padding ? $padding : '16px 24px'};\n  min-width: 100px;\n  width: inherit;\n  height: 48px;\n  gap: ${({ $gap }) =>\n    $gap ? $gap : '4px'};\n  border: none;\n  border-radius: ${({ $borderRadius }) =>\n    $borderRadius ? $borderRadius : '12px'};\n  white-space: nowrap;\n`;\n\nconst Button = forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ disabled, bgColor, textColor, borderRadius, gap, padding, children, ...props }, ref) => (\n    <StyledButton\n      {...(disabled ? { 'aria-disabled': true } : {})}\n      role=\"button\"\n      ref={ref}\n      $bgColor={bgColor}\n      $textColor={textColor}\n      $borderRadius={borderRadius}\n      $gap={gap}\n      $padding={padding}\n      $disabled={disabled}\n      {...props}\n    >\n      {children}\n    </StyledButton>\n  )\n);\n\nButton.displayName = 'Button';\n\nexport { Button };\n",
  "packages/ui-kit/src/lib/components/common/Spinner.tsx": "import React, { FC } from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport { Ellipse } from './icons';\n\n// Keyframes for the spinning animation\nconst spin = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\n// Styled container for the Spinner\nconst Container = styled.div<{\n  color?: string;\n}>`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation: ${spin} 1s linear infinite;\n  width: 18px;\n  height: 18px;\n  color: ${({ color }) => color || 'var(--pwauth-btn-connect-text-color)'};\n`;\n\ntype SpinnerProps = {\n  color?: string;\n}\n\n\n// Spinner functional component\nconst Spinner: FC<SpinnerProps> = ({ color }) => {\n  return (\n    <Container color={color} >\n      <Ellipse />\n    </Container>\n  );\n};\n\nexport default Spinner;\n",
  "packages/ui-kit/src/lib/components/common/icons/ArbitrumMonotone.tsx": "import React from 'react';\n\nconst ArbitrumMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clip-path=\"url(#clip0_8547_11033)\">\n                <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"#313338\"/>\n                <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.02206 6.4834L9.44362 3.92956C9.61165 3.83254 9.80225 3.78223 9.99629 3.78223C10.1903 3.78223 10.381 3.8333 10.549 3.93032L14.9757 6.48939C15.1435 6.58639 15.2828 6.7258 15.3797 6.89359C15.4766 7.06144 15.5277 7.25176 15.5278 7.44557L15.5306 12.5588C15.5307 12.753 15.4796 12.9437 15.3826 13.1118C15.2856 13.2799 15.146 13.4195 14.9779 13.5165L10.5564 16.0696C10.3883 16.1666 10.1977 16.2177 10.0036 16.2177C9.80959 16.2177 9.61899 16.1666 9.45096 16.0696L5.02425 13.5106C4.85647 13.4136 4.71714 13.2742 4.62023 13.1064C4.52333 12.9385 4.47225 12.7482 4.47213 12.5544L4.46936 7.44107C4.46929 7.24698 4.52033 7.05628 4.61735 6.88816C4.71437 6.72004 4.85396 6.58044 5.02206 6.4834ZM7.99995 14.168C7.97838 14.194 7.96364 14.2249 7.95686 14.2579C7.9817 14.2923 8.01585 14.3188 8.05526 14.3345C8.62735 14.6613 9.19839 14.9896 9.76841 15.3193C9.8304 15.3593 9.90262 15.3806 9.97641 15.3806C10.0502 15.3806 10.1224 15.3593 10.1844 15.3193C10.5714 15.095 10.9582 14.8704 11.3448 14.6454C11.4687 14.5854 11.586 14.5125 11.6946 14.428C11.7122 14.386 11.691 14.3537 11.6706 14.3225C11.6678 14.3182 11.665 14.3138 11.6623 14.3095C11.5758 14.1708 11.4876 14.0332 11.3995 13.8956C11.372 13.8528 11.3446 13.81 11.3172 13.7671C11.1769 13.5475 11.0371 13.3275 10.8974 13.1075C10.625 12.6788 10.3527 12.2501 10.0762 11.824C10.0581 11.8012 10.0477 11.7733 10.0463 11.7442C10.0449 11.7151 10.0527 11.6863 10.0686 11.6619C10.2379 11.3781 10.4057 11.0934 10.5735 10.8087C10.7135 10.5711 10.8536 10.3335 10.9945 10.0964C11.0375 10.0245 11.0447 10.025 11.0904 10.0964C11.309 10.4385 11.5264 10.7816 11.7438 11.1245C11.8805 11.3403 12.0171 11.5559 12.1541 11.7713C12.2684 11.9513 12.3826 12.1315 12.4967 12.3116C12.7266 12.6746 12.9566 13.0376 13.1885 13.3994C13.193 13.4063 13.1972 13.4135 13.2015 13.4208C13.2219 13.4554 13.2428 13.4908 13.2877 13.502C13.3883 13.4667 13.4833 13.4172 13.5697 13.3548C13.5806 13.349 13.5921 13.3438 13.6035 13.3385C13.6473 13.3184 13.6919 13.2979 13.716 13.2501C13.7151 13.2069 13.6993 13.1653 13.6711 13.1325C13.5194 12.8879 13.3679 12.6431 13.2166 12.398L12.0956 10.5847C11.877 10.2301 11.6579 9.87582 11.4385 9.52172C11.4192 9.5001 11.4072 9.47287 11.4043 9.44402C11.4013 9.41512 11.4076 9.38608 11.4222 9.36101C11.6884 8.90994 11.9547 8.45892 12.2212 8.00804C12.2624 7.93799 12.2699 7.93895 12.3111 8.00417C12.4266 8.18709 12.544 8.36903 12.6613 8.55095C12.7232 8.64707 12.7852 8.74318 12.8469 8.83943C13.3781 9.66321 13.9076 10.4881 14.4352 11.314C14.4513 11.3392 14.4672 11.3644 14.4831 11.3897C14.5326 11.4681 14.582 11.5466 14.6357 11.622C14.6383 11.6258 14.641 11.6302 14.6438 11.6348C14.6589 11.6599 14.6773 11.6905 14.7172 11.6519C14.7271 11.6197 14.7308 11.5858 14.728 11.5521C14.7291 10.1853 14.7291 8.81832 14.728 7.45139C14.7324 7.37267 14.7141 7.29432 14.6754 7.22564C14.6366 7.15693 14.5791 7.10079 14.5094 7.06378C14.4862 7.0508 14.4634 7.03721 14.4405 7.02361C14.4212 7.01215 14.402 7.00069 14.3825 6.98958C13.787 6.6482 13.1918 6.30627 12.5969 5.9637C12.3723 5.83444 12.1475 5.70551 11.9226 5.57658C11.3579 5.2527 10.793 4.92878 10.2318 4.5994C10.1515 4.54554 10.057 4.51678 9.96032 4.51678C9.86367 4.51678 9.76919 4.54554 9.68891 4.5994C9.36314 4.79296 9.03477 4.98212 8.70638 5.17129C8.6046 5.22992 8.50281 5.28855 8.40111 5.34731C8.07769 5.53416 7.75463 5.72166 7.43158 5.90915C6.7925 6.28006 6.15342 6.65097 5.51155 7.01686C5.41343 7.06304 5.33134 7.13762 5.27603 7.2309C5.22071 7.32423 5.19469 7.43198 5.20129 7.54024C5.2074 8.47384 5.20657 9.40749 5.20574 10.3411C5.20546 10.6641 5.20517 10.9871 5.20517 11.31C5.2032 11.3468 5.20407 11.3836 5.2078 11.4202C5.20848 11.4245 5.20885 11.4291 5.20923 11.4338C5.21098 11.4557 5.21288 11.4793 5.24762 11.4793C5.25164 11.4733 5.25571 11.4673 5.25978 11.4613C5.26775 11.4496 5.27571 11.4379 5.28335 11.426C6.01958 10.2898 6.75299 9.15195 7.48367 8.01228C7.62991 7.77986 7.84878 7.60214 8.10632 7.50678C8.38908 7.40382 8.68888 7.35552 8.9897 7.36442C9.14399 7.36578 9.29843 7.37097 9.45289 7.37616C9.51279 7.37817 9.57269 7.38019 9.63259 7.38198C9.63497 7.38207 9.63748 7.38194 9.64005 7.38181C9.65211 7.38119 9.66538 7.38051 9.67245 7.40202L5.67341 13.8158C5.71601 13.8403 5.75801 13.8644 5.79955 13.8882C5.90249 13.9471 6.00261 14.0044 6.10194 14.0631C6.1342 14.0818 6.15227 14.077 6.16812 14.0463C6.17336 14.0364 6.17927 14.0267 6.18519 14.0171C6.1873 14.0137 6.18941 14.0103 6.19149 14.0068C7.09012 12.5246 7.98866 11.0423 8.88711 9.55993C9.31121 8.86072 9.73481 8.16128 10.1579 7.46171C10.1666 7.43936 10.1819 7.42023 10.2019 7.40686C10.2218 7.3935 10.2453 7.38658 10.2693 7.387C10.6803 7.38751 11.0912 7.38571 11.5019 7.38392C11.652 7.38327 11.8021 7.38261 11.9521 7.38207C11.9537 7.38207 11.9554 7.38198 11.957 7.3819C11.967 7.38138 11.9781 7.3808 11.9879 7.39806C11.9831 7.40662 11.9782 7.41557 11.9732 7.42476C11.9619 7.44531 11.9499 7.46707 11.9373 7.48844C10.6246 9.71488 9.31218 11.9414 7.99995 14.168Z\" fill=\"#B0B3B9\"/>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_8547_11033\">\n                    <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"white\"/>\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default ArbitrumMonotone;\n\n",
  "packages/ui-kit/src/lib/components/common/icons/AvalancheMonotone.tsx": "import React from 'react';\n\nconst AvalancheMonotone = () => {\n    return (\n        <svg\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n        >\n            <g clipPath=\"url(#clip0_18252_20797)\">\n                <path\n                    d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                    fill=\"#EAEBF2\"\n                />\n                <path\n                    d=\"M12.9653 10.5519C13.1419 10.2512 13.5804 10.2512 13.7551 10.5519L15.6315 13.7575C15.808 14.0583 15.5868 14.4328 15.2356 14.4328H11.4828C11.1316 14.4328 10.9124 14.0583 11.087 13.7575L12.9634 10.5519H12.9653Z\"\n                    fill=\"#202124\"\n                />\n                <path\n                    d=\"M11.832 8.41742C12.0027 8.11859 12.0027 7.74991 11.832 7.44915L10.2932 4.76555C10.1205 4.46479 9.68976 4.46479 9.51705 4.76555L4.36719 13.7555C4.19449 14.0562 4.40988 14.4327 4.75527 14.4327H7.83083C8.17429 14.4327 8.49058 14.2484 8.66133 13.9496L11.8301 8.41742H11.832Z\"\n                    fill=\"#202124\"\n                />\n            </g>\n            <defs>\n                <clipPath id=\"clip0_18252_20797\">\n                    <path\n                        d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                        fill=\"white\"\n                    />\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default AvalancheMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/BaseMonotone.tsx": "import React from 'react';\n\nconst BaseMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clip-path=\"url(#clip0_30855_6334)\">\n                <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"#313338\"/>\n                <g clip-path=\"url(#clip1_30855_6334)\">\n                    <path d=\"M9.99032 15.5C13.0334 15.5 15.5 13.0378 15.5 10C15.5 6.96224 13.0334 4.5 9.99032 4.5C7.10348 4.5 4.7354 6.71672 4.5 9.53756H11.7824V10.4624H4.5C4.7354 13.2833 7.10348 15.5 9.99032 15.5Z\" fill=\"#B0B3B9\"/>\n                </g>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_30855_6334\">\n                    <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"white\"/>\n                </clipPath>\n                <clipPath id=\"clip1_30855_6334\">\n                    <rect width=\"11\" height=\"11\" fill=\"white\" transform=\"translate(4.5 4.5)\"/>\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default BaseMonotone;\n\n\n",
  "packages/ui-kit/src/lib/components/common/icons/BnbMonotone.tsx": "import React from 'react';\n\nconst BnbMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clip-path=\"url(#clip0_8547_11030)\">\n                <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"#313338\"/>\n                <path d=\"M7.56919 9.00324L9.99996 6.57247L12.4319 9.00427L13.8462 7.58992L9.99996 3.74377L6.15498 7.5888L7.56919 9.00324ZM3.74182 10.0019L5.15621 8.58734L6.57052 10.0016L5.15611 11.416L3.74182 10.0019ZM7.56919 11.0008L9.99996 13.4314L12.4319 10.9996L13.8469 12.4132L13.8462 12.414L9.99996 16.2601L6.15498 12.4151L6.15297 12.4131L7.56919 11.0008ZM13.4294 10.0025L14.8438 8.58814L16.2581 10.0024L14.8438 11.4168L13.4294 10.0025Z\" fill=\"#B0B3B9\"/>\n                <path d=\"M11.6051 10.0017H11.6058L10.0006 8.39648L8.81418 9.58258L8.67788 9.71894L8.39673 10.0001L8.39453 10.0023L8.39673 10.0046L10.0006 11.6087L11.6059 10.0034L11.6067 10.0025L11.6051 10.0017Z\" fill=\"#B0B3B9\"/>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_8547_11030\">\n                    <path d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\" fill=\"white\"/>\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default BnbMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/CrossIcon.tsx": "import React from 'react';\n\nconst CrossIcon = ({\n    height,\n    width,\n    color\n}: {\n    height: string;\n    width: string;\n    color: string;\n}) => {\n    return (\n        <svg\n            width={width}\n            height={height}\n            viewBox=\"0 0 32 32\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <path\n                d=\"M25.3552 7.51471L8.38466 24.4853\"\n                stroke={color}\n                strokeWidth=\"2\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n            ></path>\n            <path\n                d=\"M25.3552 24.4853L8.38466 7.51473\"\n                stroke={color}\n                strokeWidth=\"2\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n            ></path>\n        </svg>\n    );\n};\n\nexport default CrossIcon;\n",
  "packages/ui-kit/src/lib/components/common/icons/DashIcon.tsx": "import React from 'react';\n\nconst DashIcon = () => {\n  return (\n    <svg\n      width=\"inherit\"\n      height=\"inherit\"\n      viewBox=\"0 0 32 32\"\n      fill=\"none\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <path\n        d=\"M4 16H28\"\n        stroke=\"currentColor\"\n        strokeWidth=\"2\"\n        strokeLinecap=\"round\"\n      />\n    </svg>\n  );\n};\n\nexport default DashIcon;\n",
  "packages/ui-kit/src/lib/components/common/icons/EllipseIcon.tsx": "import React from 'react';\n\nconst EllipseIcon = () => {\n    return (\n        <svg\n            viewBox=\"0 0 1024 1024\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"inherit\"\n            height=\"inherit\"\n            fill=\"currentColor\"\n        >\n            <path d=\"M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z\"></path>\n        </svg>\n    );\n};\n\nexport default EllipseIcon;\n",
  "packages/ui-kit/src/lib/components/common/icons/EthereumMonotone.tsx": "import React from 'react';\n\nconst EthereumMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <path\n                d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                fill=\"#313338\"\n            />\n            <path\n                d=\"M5.76962 9.82823L9.99885 3.39282V12.12L5.76962 9.82823Z\"\n                fill=\"#B0B3B9\"\n            />\n            <path\n                d=\"M9.99885 3.39282L14.2287 9.82823L9.99885 12.12V3.39282Z\"\n                fill=\"#B0B3B9\"\n            />\n            <path\n                d=\"M9.99842 13.4332V16.6072L5.76917 11.1414L9.99842 13.4332Z\"\n                fill=\"#B0B3B9\"\n            />\n            <path\n                d=\"M9.99842 16.6072V13.4332L14.2308 11.1414L9.99842 16.6072Z\"\n                fill=\"#B0B3B9\"\n            />\n        </svg>\n    );\n};\n\nexport default EthereumMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/OptimismMonotone.tsx": "import React from 'react';\n\nconst OptimismMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clipPath=\"url(#clip0_8547_11031)\">\n                <path\n                    d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                    fill=\"#EAEBF2\"\n                />\n                <path\n                    d=\"M6.20647 13.2977C5.4798 13.2977 4.88446 13.1267 4.42038 12.7847C3.96239 12.4366 3.7334 11.942 3.7334 11.3008C3.7334 11.1664 3.74868 11.0015 3.77919 10.8061C3.85861 10.3664 3.97157 9.83814 4.11811 9.22134C4.53333 7.54198 5.60504 6.70227 7.33315 6.70227C7.8033 6.70227 8.22466 6.78165 8.59714 6.94041C8.96967 7.09309 9.26272 7.32515 9.47645 7.63663C9.69017 7.94194 9.79707 8.30839 9.79707 8.73583C9.79707 8.86409 9.7818 9.02591 9.75126 9.22134C9.65967 9.76484 9.54974 10.2931 9.42148 10.8061C9.20776 11.6427 8.83834 12.2687 8.31319 12.6839C7.78803 13.0931 7.08582 13.2977 6.20647 13.2977ZM6.33473 11.9786C6.67671 11.9786 6.9667 11.8778 7.20489 11.6763C7.44915 11.4748 7.62319 11.1664 7.72698 10.7511C7.86741 10.1771 7.97431 9.67627 8.04757 9.24883C8.07198 9.12056 8.08419 8.98929 8.08419 8.8549C8.08419 8.29919 7.79415 8.02132 7.21408 8.02132C6.87205 8.02132 6.579 8.1221 6.33473 8.32361C6.09659 8.52517 5.92558 8.83359 5.82183 9.24883C5.71185 9.65798 5.60193 10.1588 5.49205 10.7511C5.46759 10.8732 5.45538 11.0015 5.45538 11.1358C5.45538 11.6977 5.74853 11.9786 6.33473 11.9786Z\"\n                    fill=\"#202124\"\n                />\n                <path\n                    d=\"M10.2212 13.2052C10.1541 13.2052 10.1022 13.1838 10.0656 13.141C10.035 13.0921 10.0259 13.0372 10.0381 12.9762L11.3021 7.02195C11.3143 6.95478 11.3479 6.89977 11.4028 6.85701C11.4578 6.81431 11.5158 6.79291 11.5769 6.79291H14.0133C14.6911 6.79291 15.2346 6.93338 15.6437 7.21427C16.059 7.49525 16.2666 7.9013 16.2666 8.43263C16.2666 8.58526 16.2483 8.74407 16.2116 8.90895C16.059 9.61126 15.7506 10.1303 15.2866 10.4662C14.8286 10.8021 14.1996 10.97 13.3996 10.97H12.1631L11.7418 12.9762C11.7295 13.0433 11.6959 13.0983 11.641 13.141C11.5861 13.1838 11.528 13.2052 11.467 13.2052H10.2212ZM13.4638 9.70591C13.7202 9.70591 13.9431 9.63567 14.1324 9.4952C14.3278 9.35473 14.456 9.15322 14.5171 8.89062C14.5354 8.78678 14.5446 8.69519 14.5446 8.61581C14.5446 8.43871 14.4927 8.30437 14.3889 8.21278C14.285 8.11502 14.108 8.06623 13.8576 8.06623H12.7584L12.4104 9.70591H13.4638Z\"\n                    fill=\"#202124\"\n                />\n            </g>\n            <defs>\n                <clipPath id=\"clip0_8547_11031\">\n                    <path\n                        d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                        fill=\"white\"\n                    />\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default OptimismMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/PolygonMonotone.tsx": "import React from 'react';\n\nconst PolygonMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clipPath=\"url(#clip0_8547_11032)\">\n                <path\n                    d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                    fill=\"#EAEBF2\"\n                />\n                <path\n                    d=\"M12.9228 8.05636C12.7151 7.93768 12.4481 7.93768 12.2107 8.05636L10.549 9.03563L9.42137 9.65875L7.78934 10.638C7.5816 10.7567 7.31455 10.7567 7.07717 10.638L5.80121 9.86649C5.59347 9.7478 5.4451 9.51038 5.4451 9.24332V7.75967C5.4451 7.52225 5.56379 7.28487 5.80121 7.1365L7.07717 6.39465C7.28486 6.27597 7.55192 6.27597 7.78934 6.39465L9.06531 7.16619C9.273 7.28487 9.42137 7.52225 9.42137 7.78931V8.76853L10.549 8.11573V7.10682C10.549 6.86945 10.4303 6.63207 10.1929 6.4837L7.81898 5.08902C7.61129 4.97033 7.34423 4.97033 7.10681 5.08902L4.67359 6.51334C4.4362 6.63207 4.3175 6.86945 4.3175 7.10682V9.89617C4.3175 10.1335 4.4362 10.3709 4.67359 10.5193L7.07717 11.9139C7.28486 12.0326 7.55192 12.0326 7.78934 11.9139L9.42137 10.9644L10.549 10.3116L12.181 9.36201C12.3887 9.24332 12.6558 9.24332 12.8932 9.36201L14.1692 10.1039C14.3769 10.2225 14.5252 10.46 14.5252 10.727V12.2107C14.5252 12.4481 14.4065 12.6855 14.1692 12.8338L12.9228 13.5757C12.7151 13.6944 12.4481 13.6944 12.2107 13.5757L10.9347 12.8338C10.727 12.7152 10.5786 12.4777 10.5786 12.2107V11.2611L9.45105 11.9139V12.8932C9.45105 13.1306 9.56974 13.368 9.80711 13.5163L12.2107 14.911C12.4184 15.0297 12.6855 15.0297 12.9228 14.911L15.3264 13.5163C15.5341 13.3976 15.6825 13.1603 15.6825 12.8932V10.0742C15.6825 9.83681 15.5638 9.59943 15.3264 9.45106L12.9228 8.05636Z\"\n                    fill=\"#202124\"\n                />\n            </g>\n            <defs>\n                <clipPath id=\"clip0_8547_11032\">\n                    <path\n                        d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                        fill=\"white\"\n                    />\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default PolygonMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/PushLogo.tsx": "import React from 'react';\n\nconst PushLogo = () => {\n    return (\n        <svg\n            width='24px'\n            height='24px'\n            viewBox=\"0 0 18 18\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <path\n                d=\"M9.00053 18C10.034 18 10.9206 17.3814 11.314 16.4948C11.4097 16.2787 11.2505 16.0362 11.0138 16.0362H6.98642C6.75053 16.0362 6.5897 16.2787 6.6862 16.4948C7.08044 17.3814 7.96708 18 8.9997 18\"\n                fill=\"url(#paint0_linear_2966_8287)\"\n            />\n            <path\n                d=\"M15.1797 13.5973C14.5248 13.5973 13.9937 13.067 13.9937 12.4113V8.10264C13.9937 5.76768 12.3911 3.808 10.2261 3.26118C10.1469 2.64589 9.62151 2.16917 8.98395 2.16917C8.3464 2.16917 7.81772 2.65001 7.74101 3.2686C5.79783 3.77254 4.3157 5.41715 4.04847 7.44529C4.04435 7.47498 4.04022 7.50467 4.03692 7.53436C4.03197 7.57478 4.02785 7.61437 4.02455 7.65478C4.02125 7.69519 4.01795 7.73561 4.01548 7.77602C4.013 7.80984 4.01053 7.84283 4.00888 7.87747C4.00558 7.9451 4.00393 8.01438 4.00393 8.08367V12.4113C4.00393 13.0637 3.47772 13.5924 2.82697 13.5973C2.51603 13.5998 2.25952 13.839 2.25952 14.1507V14.1557C2.25952 14.4642 2.50943 14.7141 2.8179 14.7141H15.1764C15.4849 14.7141 15.7348 14.4642 15.7348 14.1557C15.7364 13.8481 15.4865 13.5981 15.1781 13.5981L15.1797 13.5973Z\"\n                fill=\"url(#paint1_linear_2966_8287)\"\n            />\n            <path\n                d=\"M12.5784 2.41001C13.9682 2.70775 15.0296 3.90451 15.1608 5.31983C15.1756 5.47654 15.3117 5.59448 15.4726 5.57881C15.5484 5.57139 15.6177 5.5351 15.6664 5.47654C15.715 5.41716 15.7381 5.34293 15.7307 5.26705C15.654 4.44062 15.3208 3.67605 14.7665 3.05416C14.2164 2.43888 13.5013 2.02154 12.698 1.84916C12.6774 1.84503 12.6576 1.84256 12.6378 1.84256C12.5058 1.84256 12.3862 1.93494 12.3582 2.06937C12.3252 2.22361 12.4233 2.37619 12.5784 2.40918V2.41001Z\"\n                fill=\"url(#paint2_linear_2966_8287)\"\n            />\n            <path\n                d=\"M12.8992 0.567448C15.0617 1.03097 16.7146 2.89333 16.9183 5.09549C16.9332 5.2522 17.0692 5.36932 17.2301 5.35447C17.306 5.34705 17.3752 5.31076 17.4239 5.2522C17.4726 5.19281 17.4957 5.11858 17.4882 5.0427C17.3761 3.82533 16.8837 2.69703 16.0671 1.78317C15.2564 0.875091 14.2023 0.261454 13.0196 0.00742221C12.999 0.00329831 12.9792 0.000823975 12.9594 0.000823975C12.8274 0.000823975 12.7078 0.0931994 12.6798 0.227639C12.6459 0.381872 12.7441 0.534457 12.8992 0.567448Z\"\n                fill=\"url(#paint3_linear_2966_8287)\"\n            />\n            <path\n                d=\"M5.42097 2.41001C5.57521 2.37702 5.67418 2.22361 5.64119 2.06937C5.61232 1.93494 5.49355 1.84256 5.36159 1.84256C5.3418 1.84256 5.322 1.84503 5.30138 1.84916C4.49805 2.02154 3.78296 2.43805 3.23283 3.05416C2.67858 3.6744 2.34454 4.43979 2.26867 5.26705C2.26124 5.34293 2.28516 5.41716 2.333 5.47654C2.38084 5.53592 2.45094 5.57222 2.52682 5.57881C2.68765 5.59366 2.82374 5.47654 2.83859 5.31983C2.96973 3.90533 4.03204 2.7094 5.42097 2.41083V2.41001Z\"\n                fill=\"url(#paint4_linear_2966_8287)\"\n            />\n            <path\n                d=\"M5.10008 0.567449C5.25431 0.534458 5.35329 0.381048 5.3203 0.226815C5.29143 0.0923754 5.17266 0 5.0407 0C5.02008 0 5.00111 0.00247433 4.98049 0.00659824C3.79693 0.260631 2.74368 0.874267 1.93293 1.78235C1.11557 2.69703 0.624824 3.82451 0.511829 5.04188C0.504406 5.11776 0.528325 5.19199 0.576162 5.25138C0.624824 5.31076 0.694106 5.34705 0.769985 5.35365C0.929993 5.36849 1.06691 5.25138 1.08175 5.09467C1.28547 2.89333 2.93833 1.0318 5.10008 0.567449Z\"\n                fill=\"url(#paint5_linear_2966_8287)\"\n            />\n            <defs>\n                <linearGradient\n                    id=\"paint0_linear_2966_8287\"\n                    x1=\"11.7075\"\n                    y1=\"11.7746\"\n                    x2=\"8.41081\"\n                    y2=\"17.3781\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n                <linearGradient\n                    id=\"paint1_linear_2966_8287\"\n                    x1=\"15.2721\"\n                    y1=\"3.58366\"\n                    x2=\"5.37636\"\n                    y2=\"15.9842\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n                <linearGradient\n                    id=\"paint2_linear_2966_8287\"\n                    x1=\"18.8871\"\n                    y1=\"0.496518\"\n                    x2=\"2.00142\"\n                    y2=\"11.7045\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n                <linearGradient\n                    id=\"paint3_linear_2966_8287\"\n                    x1=\"18.7287\"\n                    y1=\"0.258155\"\n                    x2=\"1.84297\"\n                    y2=\"11.4661\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n                <linearGradient\n                    id=\"paint4_linear_2966_8287\"\n                    x1=\"15.734\"\n                    y1=\"-4.25421\"\n                    x2=\"-1.1517\"\n                    y2=\"6.95455\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n                <linearGradient\n                    id=\"paint5_linear_2966_8287\"\n                    x1=\"14.9042\"\n                    y1=\"-5.50293\"\n                    x2=\"-1.97323\"\n                    y2=\"5.70088\"\n                    gradientUnits=\"userSpaceOnUse\"\n                >\n                    <stop stopColor=\"#FF94A6\" />\n                    <stop offset=\"0.17\" stopColor=\"#EA6AC0\" />\n                    <stop offset=\"0.33\" stopColor=\"#DA4AD5\" />\n                    <stop offset=\"0.42\" stopColor=\"#D53EDD\" />\n                    <stop offset=\"0.53\" stopColor=\"#CB3EDD\" />\n                    <stop offset=\"0.72\" stopColor=\"#B341E0\" />\n                    <stop offset=\"0.95\" stopColor=\"#8B45E4\" />\n                    <stop offset=\"1\" stopColor=\"#8247E5\" />\n                </linearGradient>\n            </defs>\n        </svg>\n    );\n};\n\nexport default PushLogo;\n",
  "packages/ui-kit/src/lib/components/common/icons/PushMonotone.tsx": "import React from 'react';\n\nconst PushMonotone = () => {\n    return (\n        <svg\n            width=\"24px\"\n            height=\"24px\"\n            viewBox=\"0 0 20 20\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <g clipPath=\"url(#clip0_8547_11034)\">\n                <path\n                    d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                    fill=\"#313338\"\n                />\n                <g clipPath=\"url(#clip1_8547_11034)\">\n                    <path\n                        d=\"M6.4752 15C6.21291 15 6 14.774 6 14.497V8.1796C6 7.90195 6.21291 7.67658 6.4752 7.67658H7.96392C8.26682 7.67658 8.51266 7.41636 8.51266 7.09572V5.50302C8.51266 5.22595 8.72556 5 8.98786 5H13.2877C13.6806 5 14.0005 5.33864 14.0005 5.75453V9.53938C14.0005 9.81645 13.7876 10.0424 13.5253 10.0424H12.0366C11.7337 10.0424 11.4879 10.3026 11.4879 10.6233V12.1991C11.4879 12.4762 11.275 12.7021 11.0127 12.7021H9.06139C8.75849 12.7021 8.51266 12.9624 8.51266 13.283V14.4976C8.51266 14.7746 8.29975 15.0006 8.03745 15.0006H6.4752V15ZM9.06139 7.65973C8.75849 7.65973 8.51266 7.91996 8.51266 8.24059V9.46155C8.51266 9.78218 8.75849 10.0424 9.06139 10.0424H10.9392C11.2421 10.0424 11.4879 9.78218 11.4879 9.46155V8.24059C11.4879 7.91996 11.2421 7.65973 10.9392 7.65973H9.06139Z\"\n                        fill=\"#B0B3B9\"\n                    />\n                </g>\n            </g>\n            <defs>\n                <clipPath id=\"clip0_8547_11034\">\n                    <path\n                        d=\"M0 8C0 3.58172 3.58172 0 8 0H12C16.4183 0 20 3.58172 20 8V12C20 16.4183 16.4183 20 12 20H8C3.58172 20 0 16.4183 0 12V8Z\"\n                        fill=\"white\"\n                    />\n                </clipPath>\n                <clipPath id=\"clip1_8547_11034\">\n                    <rect width=\"8\" height=\"10\" fill=\"white\" transform=\"translate(6 5)\"/>\n                </clipPath>\n            </defs>\n        </svg>\n    );\n};\n\nexport default PushMonotone;\n\n",
  "packages/ui-kit/src/lib/components/common/icons/SolanaMonotone.tsx": "import React from 'react';\n\nconst SolanaMonotone = () => {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24px\"\n      height=\"24px\"\n      viewBox=\"0 0 21 20\"\n      fill=\"none\"\n    >\n      <g clipPath=\"url(#clip0_10481_13051)\">\n        <path\n          d=\"M0.5 8C0.5 3.58172 4.08172 0 8.5 0H12.5C16.9183 0 20.5 3.58172 20.5 8V12C20.5 16.4183 16.9183 20 12.5 20H8.5C4.08172 20 0.5 16.4183 0.5 12V8Z\"\n          fill=\"#313338\"\n        />\n        <path\n          d=\"M15.7312 12.6567L13.986 14.4801C13.9481 14.5197 13.9022 14.5513 13.8512 14.5729C13.8002 14.5944 13.7451 14.6056 13.6895 14.6055H5.41647C5.377 14.6055 5.33838 14.5943 5.30537 14.5732C5.27236 14.5521 5.24639 14.5221 5.23066 14.4868C5.21492 14.4516 5.21011 14.4126 5.2168 14.3747C5.2235 14.3368 5.24141 14.3016 5.26834 14.2735L7.01485 12.4501C7.05269 12.4106 7.09844 12.3791 7.14928 12.3575C7.20013 12.336 7.25497 12.3248 7.31044 12.3247H15.583C15.6225 12.3247 15.6611 12.3359 15.6942 12.357C15.7271 12.3781 15.7531 12.4081 15.7689 12.4434C15.7846 12.4787 15.7894 12.5176 15.7827 12.5555C15.776 12.5934 15.7581 12.6286 15.7312 12.6567ZM13.986 8.98502C13.9481 8.94542 13.9022 8.91384 13.8512 8.89225C13.8002 8.87068 13.7451 8.85956 13.6895 8.85959H5.41647C5.377 8.85959 5.33838 8.87082 5.30537 8.89191C5.27236 8.913 5.24639 8.94302 5.23066 8.97828C5.21492 9.01356 5.21011 9.05254 5.2168 9.09044C5.2235 9.12833 5.24141 9.1635 5.26834 9.19162L7.01485 11.015C7.05269 11.0545 7.09844 11.086 7.14928 11.1076C7.20013 11.1291 7.25497 11.1403 7.31044 11.1404H15.583C15.6225 11.1404 15.6611 11.1292 15.6942 11.1081C15.7271 11.087 15.7531 11.057 15.7689 11.0217C15.7846 10.9864 15.7894 10.9475 15.7827 10.9096C15.776 10.8717 15.7581 10.8365 15.7312 10.8084L13.986 8.98502ZM5.41647 7.67531H13.6895C13.7451 7.67533 13.8002 7.66421 13.8512 7.64263C13.9022 7.62104 13.9481 7.58947 13.986 7.54986L15.7312 5.72651C15.7581 5.69839 15.776 5.66322 15.7827 5.62532C15.7894 5.58742 15.7846 5.54844 15.7689 5.51318C15.7531 5.47791 15.7271 5.44788 15.6942 5.4268C15.6611 5.40571 15.6225 5.39447 15.583 5.39447H7.31044C7.25497 5.39456 7.20013 5.40574 7.14928 5.42732C7.09844 5.4489 7.05269 5.48041 7.01485 5.51992L5.26879 7.34327C5.24189 7.37135 5.22398 7.40649 5.21727 7.44434C5.21056 7.4822 5.21534 7.52115 5.23102 7.5564C5.2467 7.59165 5.2726 7.62167 5.30554 7.6428C5.33848 7.66392 5.37703 7.67521 5.41647 7.67531Z\"\n          fill=\"#B0B3B9\"\n        />\n      </g>\n      <defs>\n        <clipPath id=\"clip0_10481_13051\">\n          <path\n            d=\"M0.5 8C0.5 3.58172 4.08172 0 8.5 0H12.5C16.9183 0 20.5 3.58172 20.5 8V12C20.5 16.4183 16.9183 20 12.5 20H8.5C4.08172 20 0.5 16.4183 0.5 12V8Z\"\n            fill=\"#B0B3B9\"\n          />\n        </clipPath>\n      </defs>\n    </svg>\n  );\n};\n\nexport default SolanaMonotone;\n",
  "packages/ui-kit/src/lib/components/common/icons/TickIcon.tsx": "import React from 'react';\n\nconst TickIcon = () => {\n    return (\n        <svg\n            width=\"18px\"\n            height=\"18px\"\n            viewBox=\"0 0 18 18\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <path\n                fillRule=\"evenodd\"\n                clipRule=\"evenodd\"\n                d=\"M0 9C0 6.61305 0.948212 4.32387 2.63604 2.63604C4.32387 0.948212 6.61305 0 9 0C11.3869 0 13.6761 0.948212 15.364 2.63604C17.0518 4.32387 18 6.61305 18 9C18 11.3869 17.0518 13.6761 15.364 15.364C13.6761 17.0518 11.3869 18 9 18C6.61305 18 4.32387 17.0518 2.63604 15.364C0.948212 13.6761 0 11.3869 0 9ZM8.4864 12.852L13.668 6.3744L12.732 5.6256L8.3136 11.1468L5.184 8.5392L4.416 9.4608L8.4864 12.8532V12.852Z\"\n                fill=\"#00C296\"\n            />\n        </svg>\n    );\n};\n\nexport default TickIcon;\n",
  "packages/ui-kit/src/lib/components/common/icons/WarningIcon.tsx": "import React from 'react';\n\nconst WarningIcon = () => {\n    return (\n        <svg\n            width=\"18\"\n            height=\"18\"\n            viewBox=\"0 0 18 18\" \n            fill=\"none\" \n            xmlns=\"http://www.w3.org/2000/svg\"\n        >\n            <path\n                d=\"M9 0C7.21997 0 5.47991 0.527841 3.99987 1.51677C2.51983 2.50571 1.36628 3.91131 0.685088 5.55585C0.00389956 7.20038 -0.17433 9.00998 0.172936 10.7558C0.520203 12.5016 1.37737 14.1053 2.63604 15.364C3.89471 16.6226 5.49836 17.4798 7.24419 17.8271C8.99002 18.1743 10.7996 17.9961 12.4442 17.3149C14.0887 16.6337 15.4943 15.4802 16.4832 14.0001C17.4722 12.5201 18 10.78 18 9C17.9975 6.61382 17.0485 4.3261 15.3612 2.63882C13.6739 0.95154 11.3862 0.00251984 9 0ZM8.30769 4.84615C8.30769 4.66254 8.38063 4.48645 8.51047 4.35662C8.6403 4.22678 8.81639 4.15385 9 4.15385C9.18361 4.15385 9.3597 4.22678 9.48954 4.35662C9.61937 4.48645 9.69231 4.66254 9.69231 4.84615V9.69231C9.69231 9.87592 9.61937 10.052 9.48954 10.1818C9.3597 10.3117 9.18361 10.3846 9 10.3846C8.81639 10.3846 8.6403 10.3117 8.51047 10.1818C8.38063 10.052 8.30769 9.87592 8.30769 9.69231V4.84615ZM9 13.8462C8.79461 13.8462 8.59384 13.7852 8.42306 13.6711C8.25229 13.557 8.11919 13.3948 8.04059 13.2051C7.96199 13.0153 7.94142 12.8065 7.98149 12.6051C8.02156 12.4037 8.12047 12.2186 8.2657 12.0734C8.41093 11.9282 8.59597 11.8293 8.79741 11.7892C8.99885 11.7491 9.20765 11.7697 9.3974 11.8483C9.58716 11.9269 9.74934 12.06 9.86345 12.2308C9.97756 12.4015 10.0385 12.6023 10.0385 12.8077C10.0385 13.0831 9.92905 13.3472 9.7343 13.542C9.53956 13.7367 9.27542 13.8462 9 13.8462Z\"\n                fill=\"#D53B3B\"\n            />\n        </svg>\n    );\n};\n\nexport default WarningIcon;\n",
  "packages/ui-kit/src/lib/components/common/icons/index.ts": "export { default as DashIcon } from './DashIcon';\nexport { default as CrossIcon } from './CrossIcon';\nexport { default as Ellipse } from './EllipseIcon';\nexport { default as PushLogo } from './PushLogo';\n\n// Chains Logo\nexport { default as PushMonotone } from './PushMonotone';\nexport { default as EthereumMonotone } from './EthereumMonotone';\nexport { default as ArbitrumMonotone } from './ArbitrumMonotone';\nexport { default as AvalancheMonotone } from './AvalancheMonotone';\nexport { default as BnbMonotone } from './BnbMonotone';\nexport { default as OptimismMonotone } from './OptimismMonotone';\nexport { default as PolygonMonotone } from './PolygonMonotone';\nexport { default as SolanaMonotone } from './SolanaMonotone';\nexport { default as TickIcon } from './TickIcon';\nexport { default as WarningIcon } from './WarningIcon';",
  "packages/ui-kit/src/lib/components/common/index.ts": "export { default as Spinner } from \"./Spinner\";\nexport * from \"./icons\";\nexport * from \"./Button\"",
  "packages/ui-kit/src/lib/constants/environment.ts": "import { PUSH_NETWORK } from '@pushchain/core/src/lib/constants/enums';\n\nexport type ConfigType = {\n  WALLET_URL: {\n    [PUSH_NETWORK.MAINNET]: string;\n    [PUSH_NETWORK.TESTNET]: string;\n    [PUSH_NETWORK.TESTNET_DONUT]: string;\n    [PUSH_NETWORK.LOCALNET]: string;\n  };\n};\n\nexport const WALLET_CONFIG_URL = {\n  [PUSH_NETWORK.MAINNET]: 'https://wallet.push.org',\n  [PUSH_NETWORK.TESTNET]: 'https://wallet.push.org',\n  [PUSH_NETWORK.TESTNET_DONUT]: 'https://wallet.push.org',\n  [PUSH_NETWORK.LOCALNET]: 'http://localhost:5173',\n};\n",
  "packages/ui-kit/src/lib/constants/index.ts": "import { PushChain } from '@pushchain/core';\nimport {\n  ArbitrumMonotone,\n  AvalancheMonotone,\n  BnbMonotone,\n  EthereumMonotone,\n  OptimismMonotone,\n  PolygonMonotone,\n  PushMonotone,\n  SolanaMonotone,\n} from '../components/common';\nimport { ConnectionStatus } from '../types';\nimport BaseMonotone from '../components/common/icons/BaseMonotone';\n\nexport const PushUI = {\n  CONSTANTS: {\n    PUSH_NETWORK: PushChain.CONSTANTS.PUSH_NETWORK,\n    CHAIN: {\n      PUSH: 'pushWallet',\n      ETHEREUM: 'ethereum',\n      SOLANA: 'solana',\n      BASE: 'base',\n      ARBITRUM: 'arbitrum',\n      BINANCE: 'binance',\n      WALLET_CONNECT: 'walletConnect'\n    },\n    THEME: { LIGHT: 'light', DARK: 'dark' },\n    LOGIN: { LAYOUT: { SPLIT: 'split', SIMPLE: 'simple' } },\n    CONNECTED: {\n      LAYOUT: { FULL: 'full', HOVER: 'hover' },\n      INTERACTION: { INTERACTIVE: 'interactive', BLUR: 'blur' },\n    },\n    CONNECTION: { STATUS: ConnectionStatus },\n    CHAIN_CONFIG: PushChain.CONSTANTS.CHAIN,\n  },\n};\n\n// events send by wallet to the dapp\nexport enum WALLET_TO_APP_ACTION {\n  CONNECT_EXTERNAL_WALLET = 'connectWallet',\n\n  APP_CONNECTION_SUCCESS = 'appConnectionSuccess',\n  APP_CONNECTION_REJECTED = 'appConnectionRejected',\n  APP_CONNECTION_CANCELLED = 'appConnectionCancelled',\n\n  IS_LOGGED_IN = 'isLoggedIn',\n  IS_LOGGED_OUT = 'loggedOut',\n\n  SIGN_MESSAGE = 'signatureMessage',\n  SIGN_TRANSACTION = 'signatureTransaction',\n  SIGN_TYPED_DATA = 'signatureTypedData',\n  ERROR = 'error',\n\n  PUSH_SEND_TRANSACTION = 'pushSendTransaction',\n\n  CLOSE_IFRAME = 'closeIFrame',\n}\n\n// events send by dapp to the wallet\nexport enum APP_TO_WALLET_ACTION {\n  NEW_CONNECTION_REQUEST = 'newConnectionRequest',\n  SIGN_MESSAGE = 'signMessage',\n  SIGN_TRANSACTION = 'signTransaction',\n  SIGN_TYPED_DATA = 'signTypedData',\n  LOG_OUT = 'logOut',\n\n  CONNECTION_STATUS = 'connectionStatus',\n  WALLET_CONFIG = 'walletConfig',\n\n  PUSH_SEND_TRANSACTION_RESPONSE = 'pushSendTransactionResponse',\n  READ_ONLY_CONNECTION_STATUS = 'readOnlyConnectionStatus',\n  RECONNECT_WALLET = 'ReconnectWallet',\n}\n\nexport const CHAIN_LOGO: Record<string, React.FC | React.ComponentType> = {\n  1: EthereumMonotone,\n  11155111: EthereumMonotone,\n  137: PolygonMonotone,\n  80002: PolygonMonotone,\n  97: BnbMonotone,\n  56: BnbMonotone,\n  42161: ArbitrumMonotone,\n  421614: ArbitrumMonotone,\n  84532: BaseMonotone,\n  11155420: OptimismMonotone,\n  10: OptimismMonotone,\n  2442: PolygonMonotone,\n  1101: PolygonMonotone,\n  43114: AvalancheMonotone,\n  43113: AvalancheMonotone,\n  '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp': SolanaMonotone, // mainnet\n  '4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z': SolanaMonotone, // testnet\n  EtWTRABZaYq6iMfeYKouRu166VU2xqa1: SolanaMonotone, // devnet\n  9: PushMonotone,\n  9000: PushMonotone,\n  devnet: PushMonotone,\n};\n\nexport * from './environment';\n",
  "packages/ui-kit/src/lib/context/WalletContext.tsx": "import React, {\n  createContext,\n  FC,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport { PushChain } from '@pushchain/core';\nimport {\n  PROGRESS_HOOK,\n  ProgressEvent,\n} from '@pushchain/core/src/lib/progress-hook/progress-hook.types';\nimport {\n  ChainType,\n  ConnectionStatus,\n  IWalletProvider,\n  ModalAppDetails,\n  PushWalletProviderProps,\n  UniversalAccount,\n  WalletEventRespoonse,\n  WalletInfo,\n  WalletAppDetails,\n  ThemeMode,\n  ITypedData,\n} from '../types';\nimport {\n  APP_TO_WALLET_ACTION,\n  PushUI,\n  WALLET_CONFIG_URL,\n  WALLET_TO_APP_ACTION,\n} from '../constants';\nimport { walletRegistry } from '../providers/walletProviders/WalletProviderRegistry';\nimport { PushWalletToast } from '../components/PushWalletToast';\nimport { LoginModal } from '../components/LoginModal';\nimport { getWalletContext } from './WalletContextMap';\nimport { ThemeOverrides } from '../styles/token';\n\nexport type WalletContextType = {\n  universalAccount: UniversalAccount | null;\n  connectionStatus: ConnectionStatus;\n\n  isWalletMinimised: boolean;\n  setMinimiseWallet: (isWalletMinimised: boolean) => void;\n\n  handleConnectToPushWallet: () => void;\n  handleUserLogOutEvent: () => void;\n  handleSignMessage: (data: Uint8Array) => Promise<Uint8Array>;\n  handleSignAndSendTransaction: (data: Uint8Array) => Promise<Uint8Array>;\n  handleSignTypedData: (data: ITypedData) => Promise<Uint8Array>;\n  handleExternalWalletConnection: (data: {\n    chain: ChainType;\n    provider: IWalletProvider[\"name\"];\n  }) => Promise<void>;\n\n  config: PushWalletProviderProps['config'];\n  app?: PushWalletProviderProps['app'];\n\n  modalAppData: ModalAppDetails | undefined;\n  updateModalAppData: (newData: Partial<ModalAppDetails>) => void;\n\n  walletAppData: WalletAppDetails | undefined;\n  updateWalletAppData: (newData: Partial<WalletAppDetails>) => void;\n\n  themeMode: ThemeMode;\n  themeOverrides: ThemeOverrides;\n\n  toggleButtonRef: React.RefObject<HTMLButtonElement>;\n  setProgress: React.Dispatch<React.SetStateAction<ProgressEvent | null>>;\n\n  isReadOnly: boolean;\n  setIsReadOnly: React.Dispatch<React.SetStateAction<boolean>>;\n  requestPushWalletConnection: () => Promise<{ chain: ChainType; provider: IWalletProvider[\"name\"] }>;\n};\n\nexport const WalletContext = createContext<WalletContextType | null>(null);\n\nexport const WalletContextProvider: FC<PushWalletProviderProps> = ({\n  children,\n  config,\n  app,\n  themeMode = PushUI.CONSTANTS.THEME.DARK,\n  themeOverrides,\n}) => {\n  const [universalAccount, setUniversalAccount] =\n    useState<WalletContextType['universalAccount']>(null);\n\n  const iframeRef = useRef<HTMLIFrameElement | null>(null);\n  const [isWalletVisible, setWalletVisibility] = useState(false); // to display the iframe as connect button is clicked\n\n  const [isWalletMinimised, setMinimiseWallet] = useState(false); // to display/hide minimized wallet modal\n\n  const [isIframeLoading, setIframeLoading] = useState(true);\n\n  const [isReadOnly, setIsReadOnly] = useState(false);\n\n  const [connectionStatus, setConnectionStatus] = useState<\n    WalletContextType['connectionStatus']\n  >(ConnectionStatus.NOT_CONNECTED);\n\n  const [externalWallet, setExternalWallet] = useState<WalletInfo | null>(null); // to connect with external wallet\n\n  const [progress, setProgress] = useState<ProgressEvent | null>(null);\n\n  const signatureResolverRef = useRef<{\n    success?: (data: WalletEventRespoonse) => void;\n    error?: (data: WalletEventRespoonse) => void;\n  } | null>(null);\n\n  const [modalAppData, setModalAppData] = useState<ModalAppDetails | undefined>(\n    app\n      ? {\n          title: app?.title,\n          logoURL: app?.logoUrl,\n          description: app?.description,\n        }\n      : undefined\n  );\n\n  const [walletAppData, setWalletAppData] = useState<\n    WalletAppDetails | undefined\n  >(\n    app\n      ? {\n          title: app?.title,\n          logoURL: app?.logoUrl,\n          description: app?.description,\n        }\n      : undefined\n  );\n\n  const toggleButtonRef = useRef<HTMLButtonElement>(null);\n\n  const updateModalAppData = (newData: Partial<ModalAppDetails>) => {\n    setModalAppData((prevData) => ({\n      ...prevData,\n      ...newData,\n    }));\n  };\n\n  const updateWalletAppData = (newData: Partial<WalletAppDetails>) => {\n    setWalletAppData((prevData) => ({\n      ...prevData,\n      ...newData,\n    }));\n  };\n\n  const handleConnectToPushWallet = () => {\n    setWalletVisibility(true);\n    setConnectionStatus(ConnectionStatus.CONNECTING);\n  };\n\n  // sending wallet config to the Push wallet\n  const sendWalletConfig = () => {\n    const walletConfig = {\n      loginDefaults: config.login,\n      themeMode,\n      appMetadata: walletAppData,\n      themeOverrides: themeOverrides || {},\n    };\n\n    sendMessageToPushWallet({\n      type: APP_TO_WALLET_ACTION.WALLET_CONFIG,\n      data: {\n        ...walletConfig,\n      },\n    });\n  };\n\n  const handleUserLogOutEvent = () => {\n    if (externalWallet) {\n      const providerReceived = walletRegistry.getProvider(\n        externalWallet.providerName\n      );\n      providerReceived?.disconnect();\n    }\n    setConnectionStatus(ConnectionStatus.NOT_CONNECTED);\n    setUniversalAccount(null);\n    setMinimiseWallet(false);\n    setWalletVisibility(false);\n    setIframeLoading(true);\n    setExternalWallet(null);\n    setIsReadOnly(false);\n    localStorage.removeItem(\"walletInfo\");\n  };\n\n  // sending events to wallet from dapp\n  const sendMessageToPushWallet = (message: any) => {\n    if (iframeRef?.current?.contentWindow) {\n      try {\n        iframeRef.current.contentWindow.postMessage(\n          message,\n          WALLET_CONFIG_URL[config.network]\n        );\n      } catch (error) {\n        console.error('Error sending message to push wallet tab:', error);\n      }\n    }\n  };\n\n  // response when the wallet sends logged in action\n  const handleIsLoggedInAction = () => {\n    handleNewConnectionRequest();\n    // setExternalWallet(null);\n  };\n\n  // sending a new connection request as soon as wallet gets connected\n  const handleNewConnectionRequest = () => {\n    setConnectionStatus(ConnectionStatus.AUTHENTICATING);\n    sendMessageToPushWallet({\n      type: APP_TO_WALLET_ACTION.NEW_CONNECTION_REQUEST,\n    });\n  };\n\n  const handleAppConnectionSuccess = (response: WalletEventRespoonse) => {\n    setConnectionStatus(ConnectionStatus.CONNECTED);\n    setMinimiseWallet(true);\n    // setIsReadOnly(false);\n    if (response.account) {\n      setUniversalAccount(response.account);\n    }\n    localStorage.setItem(\n      \"walletInfo\",\n      JSON.stringify(response.account)\n    );\n  };\n\n  const handleAppConnectionRejection = () => {\n    setConnectionStatus(ConnectionStatus.RETRY);\n    setUniversalAccount(null);\n  };\n\n  // Connect external wallet\n  const handleExternalWalletConnection = async (data: {\n    chain: ChainType;\n    provider: IWalletProvider['name'];\n  }) => {\n    try {\n      const providerReceived = walletRegistry.getProvider(data.provider);\n\n      if (!providerReceived) {\n        return;\n      }\n\n      const walletInfo = await providerReceived.connect(data.chain);\n\n      setConnectionStatus(ConnectionStatus.CONNECTED);\n      setMinimiseWallet(true);\n\n      const result = PushChain.utils.account.fromChainAgnostic(\n        walletInfo.caipAddress\n      );\n\n      setUniversalAccount(result);\n\n      const connectedWallet: WalletInfo = {\n        address: walletInfo.caipAddress,\n        providerName: data.provider,\n        chainType: data.chain,\n      };\n\n      localStorage.setItem(\n        \"walletInfo\",\n        JSON.stringify(connectedWallet)\n      );\n\n      setExternalWallet(connectedWallet);\n\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.CONNECTION_STATUS,\n        data: {\n          status: 'successful',\n          ...connectedWallet,\n        },\n      });\n    } catch (error) {\n      console.log('Failed to connect to provider', error);\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.CONNECTION_STATUS,\n        data: {\n          status: 'rejected',\n        },\n      });\n      throw new Error('Failed to connect to provider');\n    }\n  };\n\n  // handles external wallet signature request\n  const handleExternalWalletSignRequest = async (\n    data: Uint8Array\n  ): Promise<Uint8Array> => {\n    if (!externalWallet) {\n      throw new Error('No External wallet connected');\n    }\n\n    try {\n      const providerReceived = walletRegistry.getProvider(\n        externalWallet.providerName\n      );\n\n      if (!providerReceived) {\n        throw new Error('Provider not found');\n      }\n\n      const signature = await providerReceived.signMessage(data);\n\n      return signature;\n    } catch (error) {\n      console.log('Error in generating signature', error);\n      throw new Error('Signature request failed');\n    }\n  };\n\n  const handleExternalWalletSignTransactionRequest = async (\n    data: Uint8Array\n  ): Promise<Uint8Array> => {\n    if (!externalWallet) {\n      throw new Error('No External wallet connected');\n    }\n\n    try {\n      const providerReceived = walletRegistry.getProvider(\n        externalWallet.providerName\n      );\n\n      if (!providerReceived) {\n        throw new Error('Provider not found');\n      }\n\n      const signature = await providerReceived.signAndSendTransaction(data);\n\n      return signature;\n    } catch (error) {\n      console.log('Error in generating signature', error);\n      throw new Error('Signature request failed');\n    }\n  };\n\n  const handleExternalWalletSignTypedDataRequest = async (\n    data: ITypedData\n  ): Promise<Uint8Array> => {\n    if (!externalWallet) {\n      throw new Error('No External wallet connected');\n    }\n\n    try {\n      const providerReceived = walletRegistry.getProvider(\n        externalWallet.providerName\n      );\n\n      if (!providerReceived) {\n        throw new Error('Provider not found');\n      }\n\n      const signature = await providerReceived.signTypedData(data);\n\n      return signature;\n    } catch (error) {\n      console.log('Error in generating signature', error);\n      throw new Error('Signature request failed');\n    }\n  };\n\n  // handles Push wallet signature request\n  const handleSendSignRequestToPushWallet = (\n    data: Uint8Array\n  ): Promise<Uint8Array> => {\n    return new Promise((resolve, reject) => {\n      if (signatureResolverRef.current) {\n        reject(new Error('Another sign request is already in progress'));\n        return;\n      }\n\n      signatureResolverRef.current = {\n        success: (response: WalletEventRespoonse) => {\n          resolve(response.signature!);\n          signatureResolverRef.current = null; // Clean up\n        },\n        error: (response: WalletEventRespoonse) => {\n          signatureResolverRef.current = null; // Clean up\n          reject(new Error('Signature request failed'));\n        },\n      };\n\n      // Send the sign request to the wallet tab\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.SIGN_MESSAGE,\n        data,\n      });\n    });\n  };\n\n  const handleSendSignTransactionRequestToPushWallet = (\n    data: Uint8Array\n  ): Promise<Uint8Array> => {\n    return new Promise((resolve, reject) => {\n      if (signatureResolverRef.current) {\n        reject(new Error('Another sign request is already in progress'));\n        return;\n      }\n\n      signatureResolverRef.current = {\n        success: (response: WalletEventRespoonse) => {\n          resolve(response.signature!);\n          signatureResolverRef.current = null; // Clean up\n        },\n        error: (response: WalletEventRespoonse) => {\n          signatureResolverRef.current = null; // Clean up\n          reject(new Error('Signature request failed'));\n        },\n      };\n\n      // Send the sign request to the wallet tab\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.SIGN_TRANSACTION,\n        data,\n      });\n    });\n  };\n\n  const handleSendSignTypedDataRequestToPushWallet = (\n    data: ITypedData\n  ): Promise<Uint8Array> => {\n    return new Promise((resolve, reject) => {\n      if (signatureResolverRef.current) {\n        reject(new Error('Another sign request is already in progress'));\n        return;\n      }\n\n      signatureResolverRef.current = {\n        success: (response: WalletEventRespoonse) => {\n          resolve(response.signature!);\n          signatureResolverRef.current = null; // Clean up\n        },\n        error: (response: WalletEventRespoonse) => {\n          signatureResolverRef.current = null; // Clean up\n          reject(new Error('Signature request failed'));\n        },\n      };\n\n      // Send the sign request to the wallet tab\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.SIGN_TYPED_DATA,\n        data,\n      });\n    });\n  };\n\n  // sending Message sign request to wallet based on which wallet is connected (external or pushwallet)\n  const handleSignMessage = async (data: Uint8Array): Promise<Uint8Array> => {\n    let signature;\n    if (externalWallet) {\n      signature = await handleExternalWalletSignRequest(data);\n    } else {\n      signature = await handleSendSignRequestToPushWallet(data);\n    }\n\n    return signature;\n  };\n\n  const handleSignAndSendTransaction = async (\n    data: Uint8Array\n  ): Promise<Uint8Array> => {\n    let signature;\n    if (externalWallet) {\n      signature = await handleExternalWalletSignTransactionRequest(data);\n    } else {\n      signature = await handleSendSignTransactionRequestToPushWallet(data);\n    }\n\n    return signature;\n  };\n\n  const handleSignTypedData = async (data: ITypedData): Promise<Uint8Array> => {\n    let signature;\n    if (externalWallet) {\n      signature = await handleExternalWalletSignTypedDataRequest(data);\n    } else {\n      signature = await handleSendSignTypedDataRequestToPushWallet(data);\n    }\n\n    return signature;\n  };\n\n  const getAuthWindowConfig = () => {\n    // Calculate the screen width and height\n    const screenWidth = window.screen.width;\n    const screenHeight = window.screen.height;\n\n    const width = 500;\n    const height = 600;\n\n    // Calculate the position to center the window\n    const left = (screenWidth - width) / 2;\n    const top = (screenHeight - height) / 2;\n\n    // Open a new window with the calculated position\n    const windowFeatures = `width=${width},height=${height},left=${left},top=${top},resizable,scrollbars`;\n\n    return windowFeatures;\n  };\n\n  const requestPushWalletConnection = () => {\n    setMinimiseWallet(false);\n    sendMessageToPushWallet({\n      type: APP_TO_WALLET_ACTION.RECONNECT_WALLET,\n    });\n  \n    // Wait for a response from the Push Wallet iframe\n    return new Promise<{ chain: ChainType; provider: IWalletProvider[\"name\"] }>((resolve, reject) => {\n      const handleMessage = (event: MessageEvent) => {\n        if (event.data.type === WALLET_TO_APP_ACTION.APP_CONNECTION_SUCCESS) {\n          window.removeEventListener('message', handleMessage);\n          if (event.data.error) {\n            reject(new Error(event.data.error));\n          } else {\n            resolve(event.data);\n          }\n        }\n        if (event.data.type === WALLET_TO_APP_ACTION.APP_CONNECTION_CANCELLED) {\n          window.removeEventListener('message', handleMessage);\n          reject(new Error('Push Wallet connection failed'));\n          setMinimiseWallet(true);\n        }\n      };\n  \n      window.addEventListener('message', handleMessage);\n  \n      setTimeout(() => {\n        window.removeEventListener('message', handleMessage);\n        reject(new Error('Push Wallet connection timed out'));\n        setMinimiseWallet(true);\n      }, 100000);\n    });\n  }\n\n  useEffect(() => {\n    const walletInfo = localStorage.getItem(\"walletInfo\");\n    const walletData = walletInfo ? JSON.parse(walletInfo) : null;\n    if (!walletData) return;\n    if (walletData.providerName) {\n      setUniversalAccount(PushChain.utils.account.fromChainAgnostic(\n        walletData.address\n      ));\n      setExternalWallet(walletData);\n    } else {\n      setUniversalAccount(walletData);\n    }\n    setIsReadOnly(true);\n    setMinimiseWallet(true);\n    setWalletVisibility(true);\n    setConnectionStatus(ConnectionStatus.CONNECTED);\n  }, []);\n\n  useEffect(() => {\n    if (isIframeLoading) return;\n    if (!isReadOnly) return;\n    if (externalWallet) {\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.READ_ONLY_CONNECTION_STATUS,\n        data: {\n          status: 'successful',\n          ...externalWallet,\n        },\n      });\n    } else if (universalAccount) {\n      sendMessageToPushWallet({\n        type: APP_TO_WALLET_ACTION.READ_ONLY_CONNECTION_STATUS,\n        data: {\n          status: 'successful',\n          ...universalAccount,\n        },\n      });\n    }\n  }, [isIframeLoading])\n\n  useEffect(() => {\n    const messageHandler = (event: MessageEvent) => {\n      if (iframeRef.current?.contentWindow !== event.source) return;\n\n      switch (event.data.type) {\n        case WALLET_TO_APP_ACTION.CONNECT_EXTERNAL_WALLET:\n          handleExternalWalletConnection(event.data.data);\n          break;\n        case WALLET_TO_APP_ACTION.IS_LOGGED_IN:\n          handleIsLoggedInAction();\n          break;\n        case WALLET_TO_APP_ACTION.APP_CONNECTION_SUCCESS:\n          handleAppConnectionSuccess(event.data.data);\n          break;\n        case WALLET_TO_APP_ACTION.APP_CONNECTION_REJECTED:\n          handleAppConnectionRejection();\n          break;\n        case WALLET_TO_APP_ACTION.SIGN_MESSAGE:\n          if (signatureResolverRef.current) {\n            signatureResolverRef?.current?.success?.(event.data.data);\n          }\n          break;\n        case WALLET_TO_APP_ACTION.SIGN_TRANSACTION:\n          if (signatureResolverRef.current) {\n            signatureResolverRef?.current?.success?.(event.data.data);\n          }\n          break;\n        case WALLET_TO_APP_ACTION.SIGN_TYPED_DATA:\n          if (signatureResolverRef.current) {\n            signatureResolverRef?.current?.success?.(event.data.data);\n          }\n          break;\n        case WALLET_TO_APP_ACTION.IS_LOGGED_OUT:\n          handleUserLogOutEvent();\n          break;\n        case WALLET_TO_APP_ACTION.ERROR:\n          signatureResolverRef?.current?.error?.(event.data.data);\n          break;\n        case WALLET_TO_APP_ACTION.CLOSE_IFRAME:\n          if (universalAccount) setMinimiseWallet(true);\n          else handleUserLogOutEvent();\n          break;\n        default:\n          console.warn('Unknown message type:', event.data.type);\n      }\n    };\n\n    window.addEventListener('message', messageHandler);\n\n    return () => window.removeEventListener('message', messageHandler);\n  }, [universalAccount]);\n\n  const WalletContext = getWalletContext(config?.uid || 'default');\n\n  return (\n    <WalletContext.Provider\n      value={{\n        app,\n        config,\n        connectionStatus,\n        universalAccount,\n        isWalletMinimised,\n        modalAppData,\n        themeMode,\n        themeOverrides: {},\n        updateModalAppData,\n        walletAppData,\n        updateWalletAppData,\n        setMinimiseWallet,\n        handleConnectToPushWallet,\n        handleUserLogOutEvent,\n        handleSignMessage,\n        handleSignAndSendTransaction,\n        handleSignTypedData,\n        toggleButtonRef,\n        setProgress,\n        isReadOnly,\n        setIsReadOnly,\n        handleExternalWalletConnection,\n        requestPushWalletConnection,\n      }}\n    >\n      <LoginModal\n        iframeRef={iframeRef}\n        themeMode={themeMode}\n        modalAppData={modalAppData}\n        isWalletVisible={isWalletVisible}\n        isIframeLoading={isIframeLoading}\n        setIframeLoading={setIframeLoading}\n        sendWalletConfig={sendWalletConfig}\n        config={config}\n        universalAccount={universalAccount}\n        isWalletMinimised={isWalletMinimised}\n        setMinimiseWallet={setMinimiseWallet}\n        handleUserLogOutEvent={handleUserLogOutEvent}\n        toggleButtonRef={toggleButtonRef}\n        sendMessageToPushWallet={sendMessageToPushWallet}\n        isReadOnly={isReadOnly}\n      />\n      {progress && (\n        <PushWalletToast progress={progress} setProgress={setProgress} />\n      )}\n      {children}\n    </WalletContext.Provider>\n  );\n};\n",
  "packages/ui-kit/src/lib/context/WalletContextMap.ts": "import { createContext } from 'react';\nimport { WalletContextType } from './WalletContext';\n\nconst WalletContextMap = new Map<\n  string,\n  React.Context<WalletContextType | null>\n>();\n\nexport const getWalletContext = (uid = 'default') => {\n  let ctx = WalletContextMap.get(uid);\n\n  if (!ctx) {\n    ctx = createContext<WalletContextType | null>(null);\n    WalletContextMap.set(uid, ctx);\n  }\n\n  return ctx;\n};\n",
  "packages/ui-kit/src/lib/helpers/index.ts": "export * from \"./wallet.helpers\"",
  "packages/ui-kit/src/lib/helpers/txnAuthGuard.ts": "import { PushChain } from \"@pushchain/core\";\nimport { UniversalSigner } from \"@pushchain/core/src/lib/universal/universal.types\";\nimport { ChainType, IWalletProvider } from \"../types\";\n\nexport function createGuardedPushChain(\n  baseClient: PushChain,\n\thandleExternalWalletConnection: (data: {\n    chain: ChainType;\n    provider: IWalletProvider[\"name\"];\n\t}) => Promise<void>,\n\trequestPushWalletConnection: () => Promise<{\n    chain: ChainType;\n    provider: IWalletProvider[\"name\"];\n\t}>,\n\tuniversalSigner: UniversalSigner,\n\tintializeProps: any,\n\tcallback?: () => void,\n): PushChain {\n  const clientRef: { current: PushChain } = { current: baseClient };\n\n  let promoting: Promise<void> | null = null;\n\n  const promoteIfNeeded = async () => {\n    if (!clientRef.current.isReadMode) return;\n\n    if (!promoting) {\n      promoting = (async () => {\n        const walletInfo = localStorage.getItem(\"walletInfo\");\n    \t\tconst walletData = walletInfo ? JSON.parse(walletInfo) : null;\n\n\t\t\t\tif (!walletData) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (walletData.providerName) {\n\t\t\t\t\tawait handleExternalWalletConnection({\n\t\t\t\t\t\tchain: walletData.chainType,\n\t\t\t\t\t\tprovider: walletData.providerName\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait requestPushWalletConnection();\n\t\t\t\t}\n\n\t\t\t\tconst pushChainClient = await clientRef.current.reinitialize(universalSigner, intializeProps);\n\n\t\t\t\tcallback?.();\n\n\t\t\t\tclientRef.current = pushChainClient;\n\t\t\t\t\n      })().finally(() => {\n        promoting = null;\n      });\n    }\n    await promoting;\n  };\n\n  const wrapWrite = <A extends unknown[], R>(\n    getter: () => (...args: A) => Promise<R>\n\t) => {\n\tconst wrapped = async (...args: A): Promise<R> => {\n\t\tawait promoteIfNeeded();\n\t\tconst fn = getter();\n\t\treturn fn(...args);\n\t};\n\t\treturn wrapped;\n\t};\n\n  const universalProxy = new Proxy({} as PushChain[\"universal\"], {\n    get(_t, p, _r) {\n      const u = clientRef.current.universal;\n      if (p === \"sendTransaction\") {\n        return wrapWrite(() => clientRef.current.universal.sendTransaction);\n      }\n      if (p === \"signMessage\") {\n        return wrapWrite(() => clientRef.current.universal.signMessage);\n      }\n      if (p === \"signTypedData\") {\n        return wrapWrite(() => clientRef.current.universal.signTypedData);\n      }\n      // @ts-expect-error: index access for dynamic property\n      return u[p];\n    },\n  });\n\n  const clientProxy = new Proxy(baseClient, {\n    get(_target, prop, _receiver) {\n      if (prop === \"universal\") return universalProxy;\n      // @ts-expect-error: index access for dynamic property\n      return clientRef.current[prop];\n    },\n  });\n\n  return clientProxy;\n}\n",
  "packages/ui-kit/src/lib/helpers/wallet.helpers.ts": "import { CHAIN } from '@pushchain/core/src/lib/constants/enums';\n\nexport const getWalletDataFromAccount = (\n  account: string\n): {\n  chainId: string;\n  chain: string;\n  address: string;\n} => {\n  const addressComponent = account.split(':');\n\n  // Handle cases where there are exactly three components (chain, chainId, address)\n  if (addressComponent.length === 3) {\n    return {\n      chain: addressComponent[0],\n      chainId: addressComponent[1],\n      address: addressComponent[2],\n    };\n  }\n  // Handle cases where there are exactly two components (chain, address)\n  else if (addressComponent.length === 2) {\n    return {\n      chain: addressComponent[0],\n      chainId: '',\n      address: addressComponent[1],\n    };\n  }\n  // If the input doesn't match the expected format, return the address only\n  else {\n    return {\n      chain: '',\n      chainId: '',\n      address: account,\n    };\n  }\n};\n\nexport function centerMaskString(str: string, len = 6) {\n  if (str && str.length > 15) {\n    const start = str.substring(0, len);\n    const end = str.substring(str.length - len);\n    return start + '...' + end;\n  }\n  // If the string is too short, return it as is\n  return str;\n}\n\nexport const getChainId = (chain: CHAIN) => {\n  const parts = chain.split(':');\n  return parts[1];\n};\n",
  "packages/ui-kit/src/lib/hooks/useAppMetadata.ts": "// hooks/useAppMetadata.ts\nimport { useContext } from 'react';\nimport { WalletContext } from '../context/WalletContext';\nexport const useAppMetadata = (uid?: string) => useContext(WalletContext)?.app;",
  "packages/ui-kit/src/lib/hooks/usePushChain.ts": "import { useMemo } from 'react';\nimport { PushChain as PushChainCore } from '@pushchain/core';\n\nexport const usePushChain = () => {\n  const PushChain = useMemo(() => PushChainCore, []);\n  return { PushChain };\n};",
  "packages/ui-kit/src/lib/hooks/usePushChainClient.ts": "import { PushChain } from '@pushchain/core';\nimport { PROGRESS_HOOK } from '@pushchain/core/src/lib/progress-hook/progress-hook.types';\nimport { usePushWalletContext } from './usePushWallet';\nimport { useEffect, useState } from 'react';\nimport { createGuardedPushChain } from '../helpers/txnAuthGuard';\nimport { useRef } from 'react';\n\nexport const usePushChainClient = (uid?: string) => {\n  const {\n    universalAccount,\n    handleSignMessage,\n    handleSignAndSendTransaction,\n    handleSignTypedData,\n    handleExternalWalletConnection,\n    requestPushWalletConnection,\n    config,\n    setProgress,\n    isReadOnly,\n    setIsReadOnly\n  } = usePushWalletContext(uid);\n  const [pushChain, setPushChain] = useState<PushChain | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // initialise Push Chain instance here and export that\n  useEffect(() => {\n    const initializePushChain = async () => {\n      if (!universalAccount) {\n        setPushChain(null);\n        return;\n      }\n\n      const CHAINS = PushChain.CONSTANTS.CHAIN;\n\n      const isSolana = [\n        CHAINS.SOLANA_DEVNET,\n        CHAINS.SOLANA_MAINNET,\n        CHAINS.SOLANA_TESTNET,\n      ].includes(universalAccount.chain);\n\n      try {\n        const signerSkeleton = PushChain.utils.signer.construct(\n          universalAccount,\n          {\n            signMessage: handleSignMessage,\n            signAndSendTransaction: handleSignAndSendTransaction,\n            signTypedData: isSolana ? undefined : handleSignTypedData,\n          }\n        );\n\n        const universalSigner = await PushChain.utils.signer.toUniversal(\n          signerSkeleton\n        );\n\n        const intializeProps = {\n          network: config.network,\n          progressHook: async (progress: any) => {\n            if (timeoutRef.current) {\n              clearTimeout(timeoutRef.current);\n              timeoutRef.current = null;\n            }\n            setProgress(progress);\n\n            if (\n              progress.level === 'SUCCESS' ||\n              progress.level === 'ERROR'\n            ) {\n              timeoutRef.current = setTimeout(() => setProgress(null), 5000);\n            }\n          },\n          rpcUrls: config.chainConfig?.rpcUrls,\n          blockExplorers: config.chainConfig?.blockExplorers,\n          printTraces: config.chainConfig?.printTraces,\n        }\n\n        if (isReadOnly) {\n          const pushChainClient = await PushChain.initialize(universalAccount, {\n            network: config.network,\n          });\n          setPushChain(\n            createGuardedPushChain(\n              pushChainClient,\n              handleExternalWalletConnection,\n              requestPushWalletConnection,\n              universalSigner,\n              intializeProps,\n              () => {\n                setIsReadOnly(false);\n              },\n            )\n          );\n        } else {\n          const pushChainClient = await PushChain.initialize(universalSigner, intializeProps);\n          setPushChain(pushChainClient);\n        }\n        setError(null);\n\n      } catch (err) {\n        console.log('Error occured when initialising Push chain', err);\n        setError(\n          err instanceof Error\n            ? err\n            : new Error('Failed to initialize PushChain')\n        );\n        setPushChain(null);\n      }\n    };\n\n    initializePushChain();\n  }, [universalAccount, config]);\n\n  return {\n    pushChainClient: pushChain,\n    error,\n    isInitialized: !!pushChain && !error,\n  };\n};\n",
  "packages/ui-kit/src/lib/hooks/usePushWallet.ts": "import { useContext } from 'react';\nimport { WalletContextType } from '../context/WalletContext';\nimport { getWalletContext } from '../context/WalletContextMap';\n\n// Custom hook to use WalletContext\nexport const usePushWalletContext = (uid?: string): WalletContextType => {\n  const context = useContext(getWalletContext(uid || 'default'));\n  if (!context) {\n    throw new Error(\n      'usePushWalletContext must be used within a PushWalletProvider'\n    );\n  }\n  return context;\n};\n",
  "packages/ui-kit/src/lib/index.ts": "export * from './constants';\n// export * from './walletDeprecated';\nexport * from './providers/PushWalletProvider';\nexport * from './types';\n\nexport * from './components/PushUniversalAccountButton';\nexport * from './hooks/usePushWallet';\nexport * from './hooks/usePushChainClient';\nexport * from './hooks/usePushChain';\n",
  "packages/ui-kit/src/lib/polyfills/index.ts": "import { Buffer as PolyBuffer } from 'buffer';\nimport type { Buffer as BufferType } from 'buffer';\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var Buffer: BufferType;\n}\n\nconst g: any = globalThis;\nif (!g.Buffer || !g.Buffer.from || !g.Buffer.alloc) g.Buffer = PolyBuffer;\n\nif (typeof globalThis.process === 'undefined') {\n  (globalThis as any).process = { env: {} };\n}\n\nif (typeof globalThis.global === 'undefined') {\n  (globalThis as any).global = globalThis;\n}",
  "packages/ui-kit/src/lib/providers/PushWalletProvider.tsx": "/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport React, { FC } from 'react';\nimport { ProviderConfigProps, PushWalletProviderProps } from '../types/index';\nimport { WalletContextProvider } from '../context/WalletContext';\nimport { PushUI } from '../constants';\nimport {\n  createGlobalStyle,\n  DefaultTheme,\n  ThemeProvider,\n} from 'styled-components';\nimport {\n  themeDefault,\n  lightThemeDefault,\n  darkThemeDefault,\n  ThemeOverrides,\n  buttonThemeDefault,\n} from '../styles/token';\nimport { mapCoreToInt } from '../utils/theme';\n\ninterface CustomTheme extends DefaultTheme {\n  themeMode: string;\n  themeOverrides: ThemeOverrides;\n}\n\nconst loginDefaultConfig = {\n  email: true,\n  google: true,\n  wallet: {\n    enabled: true,\n  },\n};\n\nconst PushWalletConfigDefault: ProviderConfigProps = {\n  uid: 'default',\n  login: loginDefaultConfig,\n  network: PushUI.CONSTANTS.PUSH_NETWORK.TESTNET_DONUT,\n  modal: {\n    loginLayout: PushUI.CONSTANTS.LOGIN.LAYOUT.SIMPLE,\n    appPreview: false,\n    connectedInteraction: PushUI.CONSTANTS.CONNECTED.INTERACTION.BLUR,\n    connectedLayout: PushUI.CONSTANTS.CONNECTED.LAYOUT.HOVER,\n  },\n};\n\nconst GlobalStyle = createGlobalStyle<{ uid: string }>`\n  [data-pw-wrapper='${(props) => props.uid}']{\n    #w3m-modal {\n      z-index: 9999 !important;\n      position: fixed !important;\n    }\n\n    ${(props) => {\n      const { themeMode, themeOverrides } = props.theme as CustomTheme;\n      const isLightMode = themeMode === PushUI.CONSTANTS.THEME.LIGHT;\n      const { dark, light, ...globalOverrides } = themeOverrides;\n      const newOverrides = {\n        ...{\n          ...themeDefault,\n          ...buttonThemeDefault,\n          ...(isLightMode ? lightThemeDefault : darkThemeDefault),\n        },\n        ...mapCoreToInt(globalOverrides),\n        ...mapCoreToInt((isLightMode ? light : dark) ?? {}),\n      };\n      return Object.entries(newOverrides)\n        .map(([key, value]) => `${key}: ${value};`)\n        .join('\\n');\n    }}\n  }\n`;\n\nexport const PushUniversalWalletProvider: FC<PushWalletProviderProps> = ({\n  config,\n  app,\n  themeMode = PushUI.CONSTANTS.THEME.LIGHT,\n  themeOverrides = {},\n  children,\n}) => {\n\n  const mergedConfig: ProviderConfigProps = {\n    ...PushWalletConfigDefault,\n    ...config,\n    login: {\n      ...loginDefaultConfig,\n      ...(config?.login || {}),\n      wallet: {\n        ...loginDefaultConfig.wallet,\n        ...(config?.login?.wallet || {}),\n      },\n    },\n    modal: {\n      ...PushWalletConfigDefault.modal,\n      ...config.modal,\n    },\n  };\n\n  return (\n    <ThemeProvider theme={{ themeMode, themeOverrides }}>\n      <GlobalStyle uid={mergedConfig.uid!} />\n      <div data-pw-wrapper={mergedConfig.uid}>\n        <WalletContextProvider\n          config={mergedConfig}\n          app={app}\n          themeMode={themeMode}\n          themeOverrides={themeOverrides}\n        >\n          {children}\n        </WalletContextProvider>\n      </div>\n    </ThemeProvider>\n  );\n};\n",
  "packages/ui-kit/src/lib/providers/theme/ThemeContext.tsx": "",
  "packages/ui-kit/src/lib/providers/walletProviders/BaseWalletProvider.ts": "import { toCAIPFormat } from './helpers/address';\nimport {\n  ChainType,\n  IWalletProvider,\n  ITypedData,\n} from '../../types/wallet.types';\n\nexport abstract class BaseWalletProvider implements IWalletProvider {\n  public readonly name: string;\n  public readonly icon: string;\n  public readonly supportedChains: ChainType[];\n\n  constructor(name: string, icon: string, supportedChains: ChainType[]) {\n    this.name = name;\n    this.icon = icon;\n    this.supportedChains = supportedChains;\n  }\n\n  abstract connect(chainType?: ChainType): Promise<{ caipAddress: string }>;\n  abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\n  abstract signAndSendTransaction(txn: Uint8Array): Promise<Uint8Array>;\n  abstract signTypedData(typedData: ITypedData): Promise<Uint8Array>;\n  abstract disconnect(): Promise<void>;\n  abstract getChainId(): Promise<unknown>;\n\n  protected formatAddress(\n    rawAddress: string,\n    chainType: ChainType,\n    chainId: number\n  ): { caipAddress: string } {\n    const caipAddress = toCAIPFormat(rawAddress, chainType, chainId);\n    return { caipAddress };\n  }\n\n  protected validateChainType(chainType?: ChainType): ChainType {\n    if (!chainType && this.supportedChains.length === 1) {\n      return this.supportedChains[0];\n    }\n\n    if (chainType && !this.supportedChains.includes(chainType)) {\n      throw new Error(`${this.name} does not support ${chainType}`);\n    }\n\n    return chainType as ChainType;\n  }\n}\n",
  "packages/ui-kit/src/lib/providers/walletProviders/WalletProviderRegistry.ts": "import { MetamaskProvider } from './ethereum/metamask';\nimport { PhantomProvider } from './solana/phantom';\nimport { ChainType, IWalletProvider } from '../../types/wallet.types';\nimport { WalletConnectProvider } from './ethereum/walletConnect';\n\nclass WalletProviderRegistry {\n  private providers: Map<string, IWalletProvider> = new Map();\n  private chainProviders: Map<ChainType, IWalletProvider[]> = new Map();\n\n  constructor() {\n    this.registerProvider(new MetamaskProvider());\n    this.registerProvider(new PhantomProvider());\n    this.registerProvider(new WalletConnectProvider());\n  }\n\n  registerProvider(provider: IWalletProvider): void {\n    this.providers.set(provider.name, provider);\n\n    provider.supportedChains.forEach((chain) => {\n      if (!this.chainProviders.has(chain)) {\n        this.chainProviders.set(chain, []);\n      }\n      this.chainProviders.get(chain)?.push(provider);\n    });\n  }\n\n  getProvider(name: string): IWalletProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  getProvidersByChain(chain: ChainType): IWalletProvider[] {\n    return this.chainProviders.get(chain) || [];\n  }\n\n  getAllProviders(): IWalletProvider[] {\n    return Array.from(this.providers.values());\n  }\n\n  getAllSupportedChains(): ChainType[] {\n    return Array.from(this.chainProviders.keys());\n  }\n}\n\nexport const walletRegistry = new WalletProviderRegistry();\n",
  "packages/ui-kit/src/lib/providers/walletProviders/ethereum/chains.ts": "import { defineChain } from 'viem';\nimport * as viemChains from 'viem/chains';\n\ntype ChainType = typeof viemChains & Record<string, unknown>;\n\nexport const pushWalletDonut = defineChain({\n  id: 42101,\n  name: 'Push Testnet Donut',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Push Chain',\n    symbol: 'PC',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://evm.donut.rpc.push.org/'],\n      webSocket: ['wss://evm.pn1.dev.push.org'],\n    },\n  },\n  blockExplorers: {\n    default: { name: 'Explorer', url: 'https://explorer.testnet.push.org' },\n  },\n});\n\nexport const chains: ChainType = {\n  ...viemChains,\n  pushWalletDonut,\n};\n",
  "packages/ui-kit/src/lib/providers/walletProviders/ethereum/metamask.ts": "import { MetaMaskSDK } from '@metamask/sdk';\nimport { BaseWalletProvider } from '../BaseWalletProvider';\nimport { ChainType, ITypedData } from '../../../types/wallet.types';\nimport { BrowserProvider, getAddress } from 'ethers';\nimport { HexString } from 'ethers/lib.commonjs/utils/data';\nimport { chains } from './chains';\nimport { bytesToHex, Chain, hexToBytes } from 'viem';\nimport { parseTransaction, toHex } from 'viem';\n\nexport class MetamaskProvider extends BaseWalletProvider {\n  private sdk: MetaMaskSDK;\n\n  constructor() {\n    super('MetaMask', 'https://metamask.io/images/metamask-fox.svg', [\n      ChainType.ETHEREUM,\n      ChainType.ARBITRUM,\n      ChainType.BASE,\n      ChainType.BINANCE,\n      ChainType.PUSH_WALLET,\n    ]);\n    this.sdk = new MetaMaskSDK({\n      dappMetadata: {\n        url: 'https://push.org/',\n      }\n    });\n  }\n\n  isInstalled = async (): Promise<boolean> => {\n    const provider = this.sdk.getProvider();\n    return !!provider;\n  };\n\n  getProvider = () => {\n    return this.sdk.getProvider();\n  };\n\n  getSigner = async () => {\n    const sdkProvider = this.sdk.getProvider();\n    if (!sdkProvider) {\n      throw new Error('Provider is undefined');\n    }\n    const browserProvider = new BrowserProvider(sdkProvider);\n    return await browserProvider.getSigner();\n  };\n\n  async connect(chainType: ChainType): Promise<{ caipAddress: string }> {\n    try {\n      const accounts = await this.sdk.connect();\n      const rawAddress = accounts[0];\n      const checksumAddress = getAddress(rawAddress);\n\n      await this.switchNetwork(chainType);\n\n      const chainId = await this.getChainId();\n\n      const addressincaip = this.formatAddress(\n        checksumAddress,\n        ChainType.ETHEREUM,\n        chainId\n      );\n\n      return addressincaip;\n    } catch (error) {\n      console.error('Failed to connect to MetaMask:', error);\n      throw error;\n    }\n  }\n\n  getChainId = async (): Promise<number> => {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error('Provider is undefined');\n    }\n    const hexChainId = (await provider.request({\n      method: 'eth_chainId',\n      params: [],\n    })) as HexString;\n\n    const chainId = parseInt(hexChainId.toString(), 16);\n    return chainId;\n  };\n\n  switchNetwork = async (chainName: ChainType) => {\n    const network = chains[chainName] as Chain;\n    const provider = this.getProvider();\n\n    if (!provider)\n      throw new Error('Provider not found while switching network');\n\n    const hexNetworkId = toHex(network.id);\n\n    try {\n      // Try to switch to the network\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: hexNetworkId }],\n      });\n    } catch (err) {\n      // If the error code is 4902, the network needs to be added\n      if ((err as any).code === 4902) {\n        try {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: hexNetworkId,\n                chainName: network.name,\n                rpcUrls: network.rpcUrls.default.http,\n                nativeCurrency: network.nativeCurrency,\n                blockExplorerUrls: network.blockExplorers?.default.url,\n              },\n            ],\n          });\n        } catch (addError) {\n          console.error('Error adding network:', addError);\n          throw addError;\n        }\n      } else {\n        console.error('Error switching network:', err);\n        throw err;\n      }\n    }\n  };\n\n  signAndSendTransaction = async (txn: Uint8Array): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      const hex = bytesToHex(txn);\n      const parsed = parseTransaction(hex);\n\n      const txParams = {\n        from: accounts[0],\n        to: parsed.to,\n        value: parsed.value ? '0x' + parsed.value.toString(16) : undefined,\n        data: parsed.data,\n        gas: parsed.gas ? '0x' + parsed.gas.toString(16) : undefined,\n        maxPriorityFeePerGas: parsed.maxPriorityFeePerGas\n          ? '0x' + parsed.maxPriorityFeePerGas.toString(16)\n          : undefined,\n        maxFeePerGas: parsed.maxFeePerGas\n          ? '0x' + parsed.maxFeePerGas.toString(16)\n          : undefined,\n      };\n\n      const signature = await provider.request({\n        method: 'eth_sendTransaction',\n        params: [txParams],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  signMessage = async (message: Uint8Array): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      const hexMessage = bytesToHex(message);\n\n      const signature = await provider.request({\n        method: 'personal_sign',\n        params: [hexMessage, accounts[0]],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  signTypedData = async (typedData: ITypedData): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      typedData.types = {\n        EIP712Domain: [\n          { name: 'version', type: 'string' },\n          { name: 'chainId', type: 'uint256' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        UniversalPayload: typedData.types['UniversalPayload'],\n      }\n\n      const safeTypedData = JSON.parse(\n        JSON.stringify(typedData, (_key, value) =>\n          typeof value === 'bigint' ? value.toString() : value\n        )\n      );\n\n      const signature = await provider.request({\n        method: 'eth_signTypedData_v4',\n        params: [accounts[0], JSON.stringify(safeTypedData)],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  disconnect = async () => {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error('Provider is undefined');\n    }\n    await provider.request({\n      method: 'wallet_revokePermissions',\n      params: [\n        {\n          eth_accounts: {},\n        },\n      ],\n    });\n  };\n}\n",
  "packages/ui-kit/src/lib/providers/walletProviders/ethereum/walletConnect.ts": "import { EthereumProvider } from '@walletconnect/ethereum-provider';\nimport { getAddress } from 'ethers';\nimport { BaseWalletProvider } from '../BaseWalletProvider';\nimport { ChainType, ITypedData } from '../../../types/wallet.types';\nimport * as chains from 'viem/chains';\nimport { bytesToHex, hexToBytes, parseTransaction, toHex } from 'viem';\nimport { HexString } from 'ethers/lib.commonjs/utils/data';\n\nexport class WalletConnectProvider extends BaseWalletProvider {\n  private provider: InstanceType<typeof EthereumProvider> | null = null;\n\n  constructor() {\n    super('WalletConnect', 'https://walletconnect.com/walletconnect-logo.svg', [\n      ChainType.WALLET_CONNECT,\n    ]);\n  }\n\n  isInstalled = async (): Promise<boolean> => {\n    return true; // WalletConnect doesn't require installation\n  };\n\n  getProvider = () => {\n    if (!this.provider) {\n      throw new Error('WalletConnect provider not initialized');\n    }\n    return this.provider;\n  };\n\n  private async initProvider(chainId: number) {\n    console.log('Provder >>', this.provider);\n\n    if (this.provider) {\n      return;\n    }\n\n    this.provider = await EthereumProvider.init({\n      projectId: '575a3e339ad56f54669c32264c133172',\n      chains: [chainId],\n      methods: ['eth_sendTransaction', 'personal_sign', 'eth_signTypedData_v4', 'eth_requestAccounts', 'eth_chainId', 'eth_accounts'],\n      showQrModal: true,\n      rpcMap: {\n        '11155111': 'https://sepolia.gateway.tenderly.co/',\n      },\n      optionalChains: [],\n    });\n\n    await this.provider.enable();\n  }\n\n  async connect(): Promise<{ caipAddress: string }> {\n    try {\n      const chain = chains['sepolia'] as chains.Chain;\n      const chainId = chain.id;\n\n      await this.initProvider(chainId);\n\n      const accounts = (await this.provider!.request({\n        method: 'eth_requestAccounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      const rawAddress = accounts[0];\n      const checksumAddress = getAddress(rawAddress);\n\n      const caipAddress = this.formatAddress(\n        checksumAddress,\n        ChainType.ETHEREUM,\n        chainId\n      );\n      return caipAddress;\n    } catch (error) {\n      console.error('Failed to connect to MetaMask:', error);\n      throw error;\n    }\n  }\n\n  getChainId = async (): Promise<number> => {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error('Provider is undefined');\n    }\n    const hexChainId = (await provider.request({\n      method: 'eth_chainId',\n      params: [],\n    })) as HexString;\n\n    const chainId = parseInt(hexChainId.toString(), 16);\n    return chainId;\n  };\n\n  signAndSendTransaction = async (txn: Uint8Array): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      const hex = bytesToHex(txn);\n      const parsed = parseTransaction(hex);\n\n      const txParams = {\n        from: accounts[0],\n        to: parsed.to,\n        value: parsed.value ? '0x' + parsed.value.toString(16) : undefined,\n        data: parsed.data,\n        gas: parsed.gas ? '0x' + parsed.gas.toString(16) : undefined,\n        maxPriorityFeePerGas: parsed.maxPriorityFeePerGas\n          ? '0x' + parsed.maxPriorityFeePerGas.toString(16)\n          : undefined,\n        maxFeePerGas: parsed.maxFeePerGas\n          ? '0x' + parsed.maxFeePerGas.toString(16)\n          : undefined,\n      };\n\n      const signature = await provider.request({\n        method: 'eth_sendTransaction',\n        params: [txParams],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  signMessage = async (message: Uint8Array): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      const hexMessage = bytesToHex(message);\n\n      const signature = await provider.request({\n        method: 'personal_sign',\n        params: [hexMessage, accounts[0]],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  signTypedData = async (typedData: ITypedData): Promise<Uint8Array> => {\n    try {\n      const provider = this.getProvider();\n      if (!provider) {\n        throw new Error('Provider is undefined');\n      }\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[];\n\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No connected account');\n      }\n\n      typedData.types = {\n        EIP712Domain: [\n          { name: 'version', type: 'string' },\n          { name: 'chainId', type: 'uint256' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        UniversalPayload: typedData.types['UniversalPayload'],\n      }\n\n      const signature = await provider.request({\n        method: 'eth_signTypedData_v4',\n        params: [accounts[0], JSON.stringify(typedData)],\n      });\n\n      return hexToBytes(signature as `0x${string}`);\n    } catch (error) {\n      console.error('MetaMask signing error:', error);\n      throw error;\n    }\n  };\n\n  disconnect = async () => {\n    const provider = this.getProvider();\n    if (provider && typeof provider.disconnect === 'function') {\n      await provider.disconnect();\n    }\n    this.provider = null;\n  };\n}\n",
  "packages/ui-kit/src/lib/providers/walletProviders/helpers/address.ts": "import { TransactionRequest } from 'ethers';\nimport { ChainType } from '../../../types/wallet.types';\nimport { bytesToHex, parseTransaction } from 'viem';\n\nexport const chainToNamespace = {\n  EVM: 'eip155',\n  SOL: 'solana',\n};\n\nexport function fromCAIPFormat(caipAddress: string) {\n  const parts = caipAddress.split(':');\n\n  if (parts.length !== 3) {\n    throw new Error('Invalid CAIP-10 address format');\n  }\n\n  const namespace = parts[0];\n  const chainId = parts[1];\n  const rawAddress = parts[2];\n\n  let chain: ChainType | null = null;\n\n  if (namespace === 'eip155') {\n    if (chainId === '1') {\n      chain = ChainType.ETHEREUM;\n    } else if (chainId === '56') {\n      chain = ChainType.BINANCE;\n    } else if (chainId === '42161') {\n      chain = ChainType.ARBITRUM;\n    } else if (chainId === '43114') {\n      chain = ChainType.AVALANCHE;\n    } else {\n      chain = ChainType.ETHEREUM;\n    }\n  } else if (namespace === 'solana') {\n    chain = ChainType.SOLANA;\n  } else {\n    throw new Error('Unsupported namespace');\n  }\n\n  return {\n    chain,\n    chainId,\n    rawAddress,\n  };\n}\n\nexport function toCAIPFormat(\n  rawAddress: string,\n  chain: ChainType,\n  chainId: number | string\n) {\n  const formattedAddress = rawAddress;\n  let formattedChainId = chainId;\n  let namespace = '';\n\n  if (\n    chain.toLowerCase() === ChainType.ETHEREUM ||\n    chain.toLowerCase() === ChainType.BINANCE ||\n    chain.toLowerCase() === ChainType.ARBITRUM ||\n    chain.toLowerCase() === ChainType.AVALANCHE\n  ) {\n    namespace = 'eip155';\n\n    if (typeof chainId === 'string' && chainId.startsWith('0x')) {\n      formattedChainId = parseInt(chainId, 16);\n    }\n  } else if (chain.toLowerCase() === ChainType.SOLANA) {\n    namespace = 'solana';\n\n    // TODO: Find a method to get the solana chain id in caip format\n    formattedChainId = 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1'; //devnet\n  } else {\n    throw new Error(\"Unsupported chain. Use 'ethereum' or 'solana'.\");\n  }\n\n  return `${namespace}:${formattedChainId}:${formattedAddress}`;\n}\n",
  "packages/ui-kit/src/lib/providers/walletProviders/solana/phantom.ts": "import { getAddress } from 'ethers';\nimport { BaseWalletProvider } from '../BaseWalletProvider';\nimport { ChainType, ITypedData } from '../../../types/wallet.types';\nimport { Transaction } from '@solana/web3.js';\nimport { bytesToHex, createWalletClient, custom, hexToBytes, parseTransaction } from 'viem';\nimport { bs58 } from '@coral-xyz/anchor/dist/cjs/utils/bytes';\nimport { sepolia } from 'viem/chains';\n\ndeclare global {\n  interface Window {\n    phantom?: {\n      ethereum?: {\n        isConnected?: boolean;\n        request: (args: { method: string; params?: any[] }) => Promise<any>;\n      };\n      solana?: {\n        isConnected?: boolean;\n        chainId?: number;\n        connect: () => Promise<{ publicKey: { toString: () => string } }>;\n        disconnect: () => Promise<void>;\n        signMessage: (\n          message: Uint8Array,\n          encoding: string\n        ) => Promise<{ signature: Uint8Array }>;\n        signAndSendTransaction: (txn: Transaction) => Promise<string>;\n      };\n    };\n    ethereum?: any;\n  }\n}\n\nexport class PhantomProvider extends BaseWalletProvider {\n  constructor() {\n    super('Phantom', 'https://www.phantom.app/img/logo.png', [\n      ChainType.ETHEREUM,\n      ChainType.SOLANA,\n    ]);\n  }\n\n  private connectedChainType: ChainType | null = null;\n\n  isInstalled = async (): Promise<boolean> => {\n    return (\n      typeof window !== 'undefined' && typeof window.phantom !== 'undefined'\n    );\n  };\n\n  private connectEthereum = async (): Promise<{ caipAddress: string }> => {\n    if (!window.phantom?.ethereum) {\n      throw new Error('Phantom not installed for Ethereum');\n    }\n\n    const provider = window.phantom?.ethereum;\n    const accounts = await provider.request({ method: 'eth_requestAccounts' });\n    const rawAddress = accounts[0];\n\n    const checksumAddress = getAddress(rawAddress);\n\n    const chainId = await this.getChainId(ChainType.ETHEREUM);\n\n    this.connectedChainType = ChainType.ETHEREUM;\n\n    const caipAddress = this.formatAddress(\n      checksumAddress,\n      ChainType.ETHEREUM,\n      chainId\n    );\n    return caipAddress;\n  };\n\n  private connectSolana = async (): Promise<{ caipAddress: string }> => {\n    if (!window.phantom?.solana) {\n      throw new Error('Phantom not installed for Solana');\n    }\n\n    const provider = window.phantom?.solana;\n    const accounts = await provider.connect();\n\n    const chainId = await this.getChainId(ChainType.SOLANA);\n\n    this.connectedChainType = ChainType.SOLANA;\n\n    const caipAddress = this.formatAddress(\n      accounts.publicKey.toString(),\n      ChainType.SOLANA,\n      chainId\n    );\n\n    return caipAddress;\n  };\n\n  connect = async (chainType?: ChainType): Promise<{ caipAddress: string }> => {\n    let account;\n    if (!chainType || chainType === ChainType.SOLANA) {\n      account = this.connectSolana();\n    } else if (chainType === ChainType.ETHEREUM) {\n      account = this.connectEthereum();\n    }\n\n    if (!account) {\n      throw new Error('Error in connecting to phantom');\n    }\n\n    return account;\n  };\n\n  getChainId = async (chainType?: ChainType): Promise<number> => {\n    if (chainType === ChainType.ETHEREUM) {\n      const provider = window.phantom?.ethereum;\n      if (!provider) throw new Error('No Phantom Ethereum wallet connected');\n      const chainId = await provider.request({ method: 'eth_chainId' });\n      return parseInt(chainId, 16);\n    } else if (chainType === ChainType.SOLANA) {\n      const provider = window.phantom?.solana;\n      if (!provider) throw new Error('No Phantom Solana wallet connected');\n\n      return provider.chainId || 1;\n    }\n    throw new Error('No Phantom wallet connected');\n  };\n\n  signMessage = async (message: Uint8Array): Promise<Uint8Array> => {\n    const isInstalled = this.isInstalled();\n    if (!isInstalled) {\n      throw new Error('No Phantom wallet installed');\n    }\n\n    if (this.connectedChainType === ChainType.SOLANA && window.phantom?.solana) {\n      try {\n        const provider = window.phantom?.solana;\n        const signedMessage = await provider.signMessage(message, 'utf8');\n\n        return signedMessage.signature;\n      } catch (error) {\n        console.error('Phantom Solana signing error:', error);\n        throw error;\n      }\n    } else if (this.connectedChainType === ChainType.ETHEREUM && window.phantom?.ethereum) {\n      try {\n        const provider = window.phantom?.ethereum;\n\n        const accounts = await provider.request({\n          method: 'eth_accounts',\n        });\n\n        if (!accounts || accounts.length === 0) {\n          throw new Error('No connected account');\n        }\n\n        const hexMessage = bytesToHex(message);\n\n        const signature = await provider.request({\n          method: 'personal_sign',\n          params: [hexMessage, accounts[0]],\n        });\n\n        return hexToBytes(signature as `0x${string}`);\n      } catch (error) {\n        console.error('Phantom Ethereum signing error:', error);\n        throw error;\n      }\n    } else {\n      throw new Error('No Phantom wallet connected');\n    }\n  };\n\n  signAndSendTransaction = async (txn: Uint8Array): Promise<Uint8Array> => {\n    const isInstalled = this.isInstalled();\n    if (!isInstalled) {\n      throw new Error('No Phantom wallet installed');\n    }\n\n    if (this.connectedChainType === ChainType.SOLANA && window.phantom?.solana) {\n      try {\n        const provider = window.phantom?.solana;\n\n        const transaction = Transaction.from(txn);\n        const signedTransaction = await provider.signAndSendTransaction(\n          transaction\n        );\n\n        return bs58.decode((signedTransaction as any).signature);\n      } catch (error) {\n        console.error('Phantom Solana signing error:', error);\n        throw error;\n      }\n    } else if (this.connectedChainType === ChainType.ETHEREUM && window.phantom?.ethereum) {\n      try {\n        const provider = window.phantom?.ethereum;\n\n        const accounts = await provider.request({\n          method: 'eth_accounts',\n        });\n\n        if (!accounts || accounts.length === 0) {\n          throw new Error('No connected account');\n        }\n\n        const hex = bytesToHex(txn);\n        const parsed = parseTransaction(hex);\n\n        const txParams = {\n          from: accounts[0],\n          to: parsed.to,\n          value: parsed.value ? '0x' + parsed.value.toString(16) : undefined,\n          data: parsed.data,\n          gas: parsed.gas ? '0x' + parsed.gas.toString(16) : undefined,\n          maxPriorityFeePerGas: parsed.maxPriorityFeePerGas\n            ? '0x' + parsed.maxPriorityFeePerGas.toString(16)\n            : undefined,\n          maxFeePerGas: parsed.maxFeePerGas\n            ? '0x' + parsed.maxFeePerGas.toString(16)\n            : undefined,\n        };\n\n        const signature = await provider.request({\n          method: 'eth_sendTransaction',\n          params: [txParams],\n        });\n\n        return hexToBytes(signature as `0x${string}`);\n      } catch (error) {\n        console.error('Phantom Ethereum signing error:', error);\n        throw error;\n      }\n    } else {\n      throw new Error('No Phantom wallet connected');\n    }\n  };\n\n  signTypedData = async (typedData: ITypedData): Promise<Uint8Array> => {\n    const isInstalled = this.isInstalled();\n    if (!isInstalled) {\n      throw new Error('No Phantom wallet installed');\n    }\n\n    if (this.connectedChainType === ChainType.SOLANA && window.phantom?.solana) {\n      throw new Error('signTypedData is not implemented for this provider');\n    } else if (this.connectedChainType === ChainType.ETHEREUM && window.phantom?.ethereum) {\n      try {\n        const walletClient = createWalletClient({\n          chain: sepolia,\n          transport: custom(window.ethereum!),\n        })\n\n        const accounts = await walletClient.request({\n          method: 'eth_accounts',\n        });\n\n        if (!accounts || accounts.length === 0) {\n          throw new Error('No connected account');\n        }\n\n        const signature = await walletClient.signTypedData({\n          account: accounts[0],\n          ...typedData\n        });\n\n        return hexToBytes(signature);\n      } catch (error) {\n        console.error('Phantom Ethereum signing error:', error);\n        throw error;\n      }\n    } else {\n      throw new Error('No Phantom wallet connected');\n    }\n  }\n\n  disconnect = async (): Promise<void> => {\n    const isInstalled = this.isInstalled();\n    if (!isInstalled) return;\n\n    if (this.connectedChainType === ChainType.SOLANA && window.phantom?.solana) {\n      const provider = window.phantom?.solana;\n      this.connectedChainType = null;\n      await provider.disconnect();\n    }\n\n    if (this.connectedChainType === ChainType.ETHEREUM && window.phantom?.ethereum) {\n      this.connectedChainType = null;\n      //TOOD: find how to disconnect ethereum\n    }\n\n    return Promise.resolve();\n  };\n}\n",
  "packages/ui-kit/src/lib/styles/token.ts": "type ColorThemeTokens = {\n  // Brand Colors\n  '--pw-core-brand-primary-color': string;\n\n  // Text Colors\n  '--pw-core-text-primary-color': string;\n  '--pw-core-text-secondary-color': string;\n  '--pw-core-text-tertiary-color': string;\n  '--pw-core-text-link-color': string;\n  '--pw-core-text-disabled-color': string;\n\n  // Background Colors & Filter\n  '--pw-core-bg-primary-color': string;\n  '--pw-core-bg-secondary-color': string;\n  '--pw-core-bg-tertiary-color': string;\n  '--pw-core-bg-disabled-color': string;\n\n  // State Colors\n  '--pw-core-success-primary-color': string;\n  '--pw-core-error-primary-color': string;\n\n  // Button\n  '--pw-core-btn-primary-bg-color': string;\n  '--pw-core-btn-primary-text-color': string;\n\n  // Push Universal Account Button\n  '--pwauth-btn-connect-text-color': string;\n  '--pwauth-btn-connect-bg-color': string;\n  '--pwauth-btn-connected-text-color': string;\n  '--pwauth-btn-connected-bg-color': string;\n  '--pwauth-btn-connect-border-radius': string;\n};\n\ntype ThemeTokens = ColorThemeTokens & {\n  // Typography\n  '--pw-core-font-family': string;\n  '--pw-core-text-size': string;\n\n  // Sizing & Spacing\n  '--pw-core-modal-border': string;\n  '--pw-core-modal-border-radius': string;\n  '--pw-core-modal-width': string;\n  '--pw-core-modal-padding': string;\n  '--pw-core-list-spacing': string;\n  '--pw-core-btn-border-radius': string;\n\n  // Push Universal Account Button\n  '--pwauth-btn-connect-border-radius': string;\n};\n\ntype ButtonColorTokens = {\n  // Push Universal Account Button\n  '--pwauth-btn-connect-text-color': string;\n  '--pwauth-btn-connect-bg-color': string;\n  '--pwauth-btn-connected-text-color': string;\n  '--pwauth-btn-connected-bg-color': string;\n};\n\ntype ButtonThemeTokens = ButtonColorTokens & {\n  // Push Universal Account Button\n  '--pwauth-btn-connect-border-radius': string;\n};\n\nexport type ThemeOverrides = Partial<ThemeTokens> & {\n  light?: Partial<ColorThemeTokens>;\n  dark?: Partial<ColorThemeTokens>;\n};\n\nexport type ButtonThemeOverrides = Partial<ButtonThemeTokens> & {\n  light?: Partial<ButtonColorTokens>;\n  dark?: Partial<ButtonColorTokens>;\n};\n\nexport const themeDefault = {\n  '--pw-int-text-heading-xsmall-size': '18px',\n  '--pw-int-text-body-large-size': '16px',\n  '--pw-int-font-family': '\"Arial\", sans-serif',\n  '--pw-int-modal-width': '376px',\n};\n\nexport const lightThemeDefault = {\n  '--pw-int-bg-primary-color': '#F5F6F8',\n  '--pw-int-text-primary-color': '#17181B',\n  '--pw-int-text-secondary-color': '#313338',\n  '--pw-int-brand-primary-color': '#CF59E2',\n};\n\nexport const darkThemeDefault = {\n  '--pw-int-bg-primary-color': '#17181B',\n  '--pw-int-text-primary-color': '#F5F6F8',\n  '--pw-int-text-secondary-color': '#C4CBD5',\n  '--pw-int-brand-primary-color': '#D548EC',\n};\n\nexport const buttonThemeDefault = {\n  '--pwauth-btn-connect-text-color': '#FFF',\n  '--pwauth-btn-connect-bg-color': '#D548EC',\n  '--pwauth-btn-connected-text-color': '#FFF',\n  '--pwauth-btn-connected-bg-color': '#000',\n  '--pwauth-btn-connect-border-radius': '12px',\n};\n\nexport const defaultThemeKeys = Object.keys({\n  ...themeDefault,\n  ...lightThemeDefault,\n  ...buttonThemeDefault,\n});\n",
  "packages/ui-kit/src/lib/types/PushWalletProvider.types.ts": "import { CHAIN, PUSH_NETWORK } from '@pushchain/core/src/lib/constants/enums';\nimport { PushUI } from '../constants';\nimport { ThemeOverrides } from '../styles/token';\n\nexport type LoginMethodConfig = {\n  email?: boolean;\n  google?: boolean;\n  wallet?: {\n    enabled?: boolean;\n    chains?: (typeof PushUI.CONSTANTS.CHAIN)[keyof typeof PushUI.CONSTANTS.CHAIN][];\n    excludedChains?: (typeof PushUI.CONSTANTS.CHAIN)[keyof typeof PushUI.CONSTANTS.CHAIN][];\n  };\n  appPreview?: boolean;\n};\n\nexport type ChainConfig = {\n  rpcUrls?: Partial<Record<CHAIN, string[]>>;\n  blockExplorers?: Partial<Record<CHAIN, string[]>>;\n  printTraces?: boolean;\n};\n\nexport type ProviderConfigProps = {\n  uid?: string;\n  network: PUSH_NETWORK;\n  rpcUrl?: string;\n  login?: LoginMethodConfig;\n  modal?: ModalProps;\n  chainConfig?: ChainConfig;\n};\n\nexport type AppMetadata = {\n  title?: string;\n  logoUrl?: string;\n  description?: string;\n};\n\nexport type ModalProps = {\n  /**\n   * split shows the preview pane side-by-side with the iframe\n   * simple shows only the iframe (no preview)\n   */\n  loginLayout?:\n    | typeof PushUI.CONSTANTS.LOGIN.LAYOUT.SPLIT\n    | typeof PushUI.CONSTANTS.LOGIN.LAYOUT.SIMPLE;\n  /** if true (and `app` is provided), show the preview pane in the wrapper */\n  appPreview?: boolean;\n  /** CSS background-image for wrapper or preview pane */\n  bgImage?: string;\n  /** when connected, how the account menu appears */\n  connectedLayout?:\n    | typeof PushUI.CONSTANTS.CONNECTED.LAYOUT.FULL\n    | typeof PushUI.CONSTANTS.CONNECTED.LAYOUT.HOVER;\n  connectedInteraction?:\n    | typeof PushUI.CONSTANTS.CONNECTED.INTERACTION.INTERACTIVE\n    | typeof PushUI.CONSTANTS.CONNECTED.INTERACTION.BLUR;\n};\n\nexport type ThemeMode =\n  | typeof PushUI.CONSTANTS.THEME.LIGHT\n  | typeof PushUI.CONSTANTS.THEME.DARK;\n\nexport type PushWalletProviderProps = {\n  children: React.ReactNode;\n  config: ProviderConfigProps;\n  app?: AppMetadata;\n  themeMode?: ThemeMode;\n  themeOverrides?: ThemeOverrides;\n};\n\n// Dapp details that display in the preview pane\nexport type ModalAppDetails = {\n  logoURL?: string;\n  title?: string;\n  description?: string;\n};\n\n// Dapp details that goes to the wallet\nexport type WalletAppDetails = {\n  logoURL?: string;\n  title?: string;\n  description?: string;\n};\n",
  "packages/ui-kit/src/lib/types/index.ts": "export * from './wallet.types';\nexport * from './PushWalletProvider.types';\n",
  "packages/ui-kit/src/lib/types/wallet.types.ts": "import { CHAIN } from '@pushchain/core/src/lib/constants/enums';\nimport { TypedData, TypedDataDomain } from 'viem';\n\nexport enum ChainType {\n  ETHEREUM = 'sepolia',\n  SOLANA = 'solana',\n  BINANCE = 'bscTestnet',\n  ARBITRUM = 'arbitrumSepolia',\n  BASE = \"baseSepolia\",\n  AVALANCHE = 'avalanche',\n  WALLET_CONNECT = 'walletConnect',\n  PUSH_WALLET = 'pushWalletDonut',\n}\nexport interface WalletInfo {\n  address: string;\n  chainType: ChainType;\n  providerName: string;\n}\n\nexport interface ITypedData {\n  domain: TypedDataDomain;\n  types: TypedData;\n  primaryType: string;\n  message: Record<string, unknown>;\n}\n\nexport interface IWalletProvider {\n  name: string;\n  icon: string;\n  supportedChains: ChainType[];\n  connect(chainType?: ChainType): Promise<{ caipAddress: string }>;\n  signMessage(message: Uint8Array): Promise<Uint8Array>;\n  signAndSendTransaction(txn: Uint8Array): Promise<Uint8Array>;\n  signTypedData(typedData: ITypedData): Promise<Uint8Array>;\n  disconnect(): Promise<void>;\n  getChainId(): Promise<unknown>;\n  switchNetwork?(chainName: ChainType): Promise<void>;\n}\n\nexport type UniversalAccount = {\n  chain: CHAIN;\n  address: string;\n};\n\nexport enum ConnectionStatus {\n  NOT_CONNECTED = 'notConnected',\n  CONNECTING = 'connecting',\n  AUTHENTICATING = 'authenticating',\n  CONNECTED = 'connected',\n  RETRY = 'retry',\n}\n\nexport type WalletEventRespoonse = {\n  signature?: Uint8Array;\n  account?: UniversalAccount;\n};\n",
  "packages/ui-kit/src/lib/utils/theme.ts": "import { buttonThemeDefault, defaultThemeKeys } from '../styles/token';\n\nexport const mapCoreToInt = (\n  obj: Record<string, string | undefined>\n): Record<string, string> => {\n  const result: Record<string, string> = {};\n\n  for (const key in obj) {\n    if (key === '--pw-core-text-size') {\n      const size = parseInt(obj[key] || '', 10);\n      const px = (val: number) => `${Math.round(val)}px`;\n      if (!isNaN(size)) {\n        result['--pw-int-text-heading-xsmall-size'] = px(size * 0.7);\n        result['--pw-int-text-body-large-size'] = px(size * 0.6);\n      }\n      continue;\n    }\n    const intKey = key.replace('core', 'int');\n    if (defaultThemeKeys.includes(intKey)) {\n      result[intKey] = obj[key] as string;\n    }\n  }\n\n  return result;\n};\n\nexport const mapButtonCoreToInt = (\n  obj: Record<string, string | undefined>\n): Record<string, string> => {\n  const result: Record<string, string> = {};\n\n  for (const key in obj) {\n    if (Object.keys(buttonThemeDefault).includes(key)) {\n      result[key] = obj[key] as string;\n    }\n  }\n\n  return result;\n};\n"
}